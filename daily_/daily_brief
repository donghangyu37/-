# === daily_brief.py · 每日情报站（并发/快速版 + 主盘OU/AH + 角球OU + 全线榜单 + 盘口矩阵 + picks.csv）===
from __future__ import annotations
from datetime import datetime, timezone
from typing import Dict, List, Tuple, Optional, Set
import math, os, csv, traceback, random

from concurrent.futures import ThreadPoolExecutor, as_completed
import numpy as np

# —— 项目内模块
from src.api.football_api import fixtures_by_date, team_statistics, odds_by_fixture, recent_fixtures_by_team
from src.data.transform import league_goal_averages
from src.models.poisson_mc import expected_goals_from_strengths, monte_carlo_simulate, simulate_goals
from src.markets.asian_handicap import ah_probabilities_from_lams, ah_ev_kelly
from src.config import HOME_ADV
from daily_.value_engine import (
    LEAGUE_TIER_OTHER,
    LEAGUE_TIER_TOP,
    classify_league_tier,
    evaluate_ev_market,
    value_index as ve_value_index,
)

# ================== 可调参数 ==================
FAST_MODE = 1
N_SIMS_GOALS   = 12000 if FAST_MODE else 25000
N_SIMS_CORNERS = 12000 if FAST_MODE else 25000
USE_RECENT = 0 if FAST_MODE else 1

CONCURRENCY = 6

# 主盘诊断阈值
STRICT_OU_MAIN  = 1; OU_MIN_CNT  = 3; OU_MAX_OR  = 1.12
STRICT_CRN_MAIN = 1; CRN_MIN_CNT = 3; CRN_MAX_OR = 1.20

# —— 新增：AH 主盘诊断阈值（与 OU/CRN 一致思路）
STRICT_AH_MAIN = 1     # 开启严格筛选：样本数与超盘限制
AH_MIN_CNT     = 3     # home/away 各至少多少条报价
AH_MAX_OR      = 1.20  # 超盘上限（1/oh + 1/oa）

# 异常 EV 拦截
def is_ev_outlier(ev: float) -> bool: return ev > 0.35

# 噪声赛事过滤
EXCLUDE_NOISY = 0
EXCLUDE_KEYS = ["u21","u23","res.","reserve","friendly","club friendlies"]

TOP_K  = 10
MIN_EV = 0.02

# 角球 λ 兜底
CORNER_BASE = 7.5
CORNER_PER_GOAL = 0.9

def _env_float(name: str, default: float) -> float:
    try:
        raw = os.getenv(name)
        if raw is None or raw == "":
            return float(default)
        return float(raw)
    except Exception:
        return float(default)

def _env_int(name: str, default: int) -> int:
    try:
        raw = os.getenv(name)
        if raw is None or raw == "":
            return int(default)
        return int(float(raw))
    except Exception:
        return int(default)

LAMBDA_MODEL_CONFIG = {
    "season": {
        "weight": _env_float("LAM_WEIGHT_SEASON", 0.6),
    },
    "recent": {
        "weight": _env_float("LAM_WEIGHT_RECENT", 0.4 if USE_RECENT else 0.0),
        "recent_games": _env_int("LAM_RECENT_GAMES", 6),
        "min_games": _env_int("LAM_RECENT_MIN_GAMES", 3),
        "decay": _env_float("LAM_RECENT_DECAY", 0.85),
        "fetch_last": _env_int("LAM_RECENT_FETCH_LAST", 12),
        "season_mix": _env_float("LAM_RECENT_SEASON_MIX", 0.3),
    },
}

if LAMBDA_MODEL_CONFIG["recent"]["min_games"] > LAMBDA_MODEL_CONFIG["recent"]["recent_games"]:
    LAMBDA_MODEL_CONFIG["recent"]["min_games"] = LAMBDA_MODEL_CONFIG["recent"]["recent_games"]

if LAMBDA_MODEL_CONFIG["recent"]["fetch_last"] < LAMBDA_MODEL_CONFIG["recent"]["recent_games"]:
    LAMBDA_MODEL_CONFIG["recent"]["fetch_last"] = LAMBDA_MODEL_CONFIG["recent"]["recent_games"]

LOG_LAMBDA_BLEND = _env_int("LAM_LOG_BLEND", 1)

# ===== Picks 导出配置 =====
EXPORT_PICKS = 1
PICKS_TOP_N = 100
PICKS_MIN_EV = 0.05
PICKS_MIN_KELLY = 0.05
PICKS_MIN_VI = 0.00
KELLY_FRACTION = 0.25
STAKE_CAP_PCT = 2.0
STAKE_MIN_PCT = 0.0

PICKS_GUARD_MIN = 3
PICKS_BACKOFF_PERCENTILE = 0.7
PICKS_MARKET_ORDER = ("ou", "1x2", "ah")
PICKS_TIER_ORDER = (LEAGUE_TIER_TOP, LEAGUE_TIER_OTHER, "unknown")
PICKS_ALLOWED_BACKOFF_TIERS = {LEAGUE_TIER_TOP, LEAGUE_TIER_OTHER}
PICKS_STRICT_RULES = {
    "ou": {"ev": 0.05, "kelly": 0.05, "quality": 0.6, "liquidity": 4.0},
    "1x2": {"ev": 0.04, "kelly": 0.04, "quality": 0.6, "liquidity": 4.0},
    "ah": {"ev": 0.04, "kelly": 0.04, "quality": 0.6, "liquidity": 3.0},
}
PICKS_BACKOFF1_EV_DELTA = 0.01
PICKS_BACKOFF1_KELLY = {"ou": 0.03, "1x2": 0.03, "ah": 0.03}
PICKS_BACKOFF2_KELLY = 0.02
PICKS_BACKOFF2_EXTRA_EV = 0.02
PICKS_BACKOFF2_COMPOSITE_MIN = 0.10
PICKS_BACKOFF2_ODDS_RANGE = (1.6, 2.6)
PICKS_BACKOFF2_OU_LINE_RANGE = (2.25, 3.0)

# ================== 工具函数 ==================
def _today_utc_date() -> str:
    return datetime.now(timezone.utc).date().isoformat()

def sanitize_ou_pair(o_over: float | None, o_under: float | None) -> Tuple[float, float] | None:
    if o_over is None or o_under is None: return None
    try: oo, uu = float(o_over), float(o_under)
    except: return None
    if not (1.10 <= oo <= 50.0 and 1.10 <= uu <= 50.0): return None
    imp = 1/oo + 1/uu
    if not (1.00 <= imp <= 1.25): return None
    return oo, uu

def sanitize_1x2(o_h: float | None, o_d: float | None, o_a: float | None):
    try:
        if None in (o_h, o_d, o_a): return None
        oh, od, oa = float(o_h), float(o_d), float(o_a)
    except: return None
    if not all(1.10 <= v <= 100.0 for v in (oh, od, oa)): return None
    imp = 1/oh + 1/od + 1/oa
    if not (1.00 <= imp <= 1.30): return None
    return oh, od, oa

def ev_kelly_binary(p: float, odds: float) -> Tuple[float, float]:
    b = odds - 1.0
    EV = p*b - (1-p)
    K  = 0.0 if b<=0 else max(0.0, (b*p - (1-p))/b)
    return float(EV), float(K)

def value_index(ev: float | None, kelly: float | None) -> float:
    vi = ve_value_index(ev, kelly)
    if vi is None:
        return -999.0
    return float(vi)


def apply_ev_filter(
    key: str,
    ev: float | None,
    kelly: float | None,
    market: str,
    tier: str,
    *,
    min_bookmakers: int | None,
    overround: float | None,
    update_age: float | None,
    flag_map: Dict[str, str],
    reason_map: Dict[str, str],
    vi_map: Dict[str, float | None],
    meta_map: Dict[str, Dict[str, object]] | None = None,
    odds: float | None = None,
    model_prob: float | None = None,
    consensus_prob: float | None = None,
    data_quality: float | None = None,
    sample_size: float | None = None,
) -> tuple[float | None, float | None]:
    if ev is None or kelly is None:
        flag_map[key] = "invalid"
        vi_map[key] = None
        return None, None

    res = evaluate_ev_market(
        ev,
        kelly,
        market,
        tier,
        min_bookmakers=min_bookmakers,
        overround=overround,
        update_age=update_age,
        odds=odds,
        model_probability=model_prob,
        consensus_probability=consensus_prob,
        data_quality=data_quality,
        sample_size=sample_size,
    )
    flag = res.get("tag", "invalid")
    flag_map[key] = flag
    reasons = res.get("reasons") or ()
    if reasons:
        reason_map[key] = ",".join(str(r) for r in reasons)
    vi_map[key] = res.get("value_index")
    if meta_map is not None:
        diagnostics = meta_map.setdefault("diagnostics", {})
        meta_entry: Dict[str, object] = {}
        quality = res.get("quality")
        if quality is not None:
            try:
                meta_entry["quality"] = round(float(quality), 6)
            except (TypeError, ValueError):
                pass
        ev_input = res.get("ev_input")
        if ev_input is not None:
            try:
                meta_entry["ev_input"] = round(float(ev_input), 6)
            except (TypeError, ValueError):
                pass
        ev_cal = res.get("ev_calibrated")
        if ev_cal is not None:
            try:
                meta_entry["ev_calibrated"] = round(float(ev_cal), 6)
            except (TypeError, ValueError):
                pass
        thresholds = res.get("thresholds")
        if isinstance(thresholds, dict) and thresholds:
            meta_entry["thresholds"] = thresholds
        if meta_entry:
            diagnostics[key] = meta_entry
    return res.get("ev"), res.get("kelly")

# ===== 四分之一盘精结算（基于 totals 样本）=====
def ou_ev_kelly_from_totals_quarter(line: float, over_odds: float, under_odds: float, totals) -> dict:
    if totals is None:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}
    try:
        totals_list = list(totals)
    except TypeError:
        totals_list = [totals]
    if len(totals_list) == 0:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}

    a = int(line // 1)
    frac = round(line - a, 2)
    n = len(totals_list)

    def counts_over(a, frac):
        if frac == 0.0:
            fw = sum(t > a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t > a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t >= a + 1 for t in totals_list) / n
            hl = sum(t == a for t in totals_list) / n
            fl = sum(t <= a - 1 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, 0.0, hl, fl + max(0.0, remain)
        elif frac == 0.75:
            fw = sum(t >= a + 2 for t in totals_list) / n
            hw = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t <= a for t in totals_list) / n
            remain = 1.0 - fw - hw - fl
            return fw, hw, remain, 0.0, fl
        else:
            fw = sum(t > line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    def counts_under(a, frac):
        if frac == 0.0:
            fw = sum(t < a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t < a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t < a for t in totals_list) / n
            hw = sum(t == a for t in totals_list) / n
            fl = sum(t >= a + 1 for t in totals_list) / n
            remain = max(0.0, 1.0 - fw - hw - fl)
            return fw, hw, remain, 0.0, fl
        elif frac == 0.75:
            fw = sum(t <= a for t in totals_list) / n
            hl = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t >= a + 2 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, remain, hl, fl
        else:
            fw = sum(t < line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    fw_o, hw_o, pu_o, hl_o, fl_o = counts_over(a, frac)
    fw_u, hw_u, pu_u, hl_u, fl_u = counts_under(a, frac)

    b_over  = max(0.0, over_odds - 1.0)
    b_under = max(0.0, under_odds - 1.0)

    EV_over  = fw_o*b_over + hw_o*(0.5*b_over) - hl_o*0.5 - fl_o*1.0
    EV_under = fw_u*b_under + hw_u*(0.5*b_under) - hl_u*0.5 - fl_u*1.0

    pwin_o, plose_o = fw_o + 0.5*hw_o, fl_o + 0.5*hl_o
    pwin_u, plose_u = fw_u + 0.5*hw_u, fl_u + 0.5*hl_u

    K_over  = 0.0 if b_over  <= 0 else max(0.0, (b_over*pwin_o  - plose_o)/b_over)
    K_under = 0.0 if b_under <= 0 else max(0.0, (b_under*pwin_u - plose_u)/b_under)

    return {
        "EV_over": float(EV_over),
        "Kelly_over": float(K_over),
        "EV_under": float(EV_under),
        "Kelly_under": float(K_under),
        "p_over_full_win": float(fw_o),
        "p_over_half_win": float(hw_o),
        "p_over_push": float(pu_o),
        "p_over_half_loss": float(hl_o),
        "p_over_full_loss": float(fl_o),
        "p_under_full_win": float(fw_u),
        "p_under_half_win": float(hw_u),
        "p_under_push": float(pu_u),
        "p_under_half_loss": float(hl_u),
        "p_under_full_loss": float(fl_u),
        "p_over_success": float(pwin_o),
        "p_over_negative": float(plose_o),
        "p_under_success": float(pwin_u),
        "p_under_negative": float(plose_u),
    }

def _regression_check_quarter_under() -> None:
    """Verify under-quarter lines treat integer totals as half wins."""
    totals = [1, 2, 3, 4]
    res = ou_ev_kelly_from_totals_quarter(2.25, 2.0, 2.0, totals)
    expected_ev_under = -0.125
    if not math.isclose(res["EV_under"], expected_ev_under, rel_tol=1e-12, abs_tol=1e-12):
        raise AssertionError(
            f"Quarter-line under regression failed: expected EV_under {expected_ev_under}, got {res['EV_under']}"
        )

# ================== 预取与缓存 ==================
TEAM_STATS_CACHE: dict[tuple[int,int,int], dict] = {}

def prefetch_team_stats(fixtures: List[Dict]):
    tasks: Set[tuple[int,int,int]] = set()
    for fx in fixtures:
        try:
            lg = fx["league"]["id"]; ss = fx["league"]["season"]
            hid = fx["teams"]["home"]["id"]; aid = fx["teams"]["away"]["id"]
            tasks.add((lg, ss, hid)); tasks.add((lg, ss, aid))
        except: pass

    def _job(key):
        if key in TEAM_STATS_CACHE: return key, TEAM_STATS_CACHE[key]
        lg, ss, tid = key
        try:
            st = team_statistics(lg, ss, tid)
            TEAM_STATS_CACHE[key] = st or {}
            return key, TEAM_STATS_CACHE[key]
        except Exception:
            return key, {}

    if not tasks: return
    with ThreadPoolExecutor(max_workers=CONCURRENCY) as ex:
        futures = {ex.submit(_job, k): k for k in tasks}
        done = 0
        for _ in as_completed(futures):
            done += 1
            if done % 20 == 0 or done == len(tasks):
                print(f"……已预取球队统计 {done}/{len(tasks)}")

def compute_league_avg_from_cache(league_id: int, season: int) -> float:
    stats_list = []
    for (lg, ss, _tid), st in TEAM_STATS_CACHE.items():
        if lg == league_id and ss == season and st:
            stats_list.append(st)
    if not stats_list:
        return 2.6
    league_avg, _ = league_goal_averages(stats_list)
    return float(league_avg or 2.6)

def estimate_corners_lambda_total(h_stats: dict, a_stats: dict, lam_home: float, lam_away: float) -> float:
    def _safe(path, d):
        cur = d
        for k in path:
            if not isinstance(cur, dict): return None
            cur = cur.get(k)
            if cur is None: return None
        try: return float(cur)
        except: return None
    h_c_home = _safe(["corners","for","average","home"], h_stats)
    a_c_away = _safe(["corners","for","average","away"], a_stats)
    if h_c_home and a_c_away and h_c_home > 0 and a_c_away > 0:
        return float(h_c_home + a_c_away)
    return float(CORNER_BASE + CORNER_PER_GOAL * (lam_home + lam_away))

# ================== λ 多模型融合 ==================
RECENT_FORM_CACHE: dict[tuple[int, int, int, int], List[Dict]] = {}

def _safe_stat(path: List[str], data: dict, default: float) -> float:
    cur = data or {}
    for key in path:
        if not isinstance(cur, dict):
            return float(default)
        cur = cur.get(key)
        if cur is None:
            return float(default)
    try:
        return float(cur)
    except Exception:
        return float(default)

def _fixture_timestamp(fixture: Dict) -> float:
    info = (fixture or {}).get("fixture") or {}
    ts = info.get("timestamp")
    if isinstance(ts, (int, float)):
        return float(ts)
    date_str = info.get("date")
    if isinstance(date_str, str):
        try:
            if date_str.endswith("Z"):
                date_str = date_str[:-1] + "+00:00"
            return datetime.fromisoformat(date_str).timestamp()
        except Exception:
            pass
    return 0.0

def _recent_weighted_avg(fixtures: List[Dict], team_id: int, want_home: bool, max_games: int, decay: float) -> tuple[Optional[float], Optional[float], int]:
    if max_games <= 0:
        return None, None, 0
    entries: List[tuple[float, float, float]] = []
    for fx in fixtures or []:
        teams = fx.get("teams") or {}
        home = (teams.get("home") or {}).get("id")
        away = (teams.get("away") or {}).get("id")
        if want_home:
            if home != team_id:
                continue
            g_for = (fx.get("goals") or {}).get("home")
            g_against = (fx.get("goals") or {}).get("away")
        else:
            if away != team_id:
                continue
            g_for = (fx.get("goals") or {}).get("away")
            g_against = (fx.get("goals") or {}).get("home")
        if g_for is None or g_against is None:
            score_ft = ((fx.get("score") or {}).get("fulltime") or {})
            if g_for is None:
                g_for = score_ft.get("home" if want_home else "away")
            if g_against is None:
                g_against = score_ft.get("away" if want_home else "home")
        try:
            gf_val = float(g_for)
            ga_val = float(g_against)
        except (TypeError, ValueError):
            continue
        entries.append((_fixture_timestamp(fx), gf_val, ga_val))

    if not entries:
        return None, None, 0

    entries.sort(key=lambda x: x[0], reverse=True)
    try:
        decay_val = float(decay)
    except Exception:
        decay_val = 0.85
    if decay_val <= 0:
        decay_val = 0.85
    if decay_val > 1:
        decay_val = 1.0

    weight_sum = 0.0
    gf_sum = 0.0
    ga_sum = 0.0
    used = 0
    for _, gf_val, ga_val in entries:
        weight = decay_val ** used
        gf_sum += weight * gf_val
        ga_sum += weight * ga_val
        weight_sum += weight
        used += 1
        if used >= max_games:
            break

    if weight_sum <= 0:
        return None, None, used

    return gf_sum / weight_sum, ga_sum / weight_sum, used

def fetch_recent_form(team_id: int, league_id: int, season: int, fetch_last: int) -> List[Dict]:
    key = (league_id, season, team_id, fetch_last)
    if key in RECENT_FORM_CACHE:
        return RECENT_FORM_CACHE[key]
    try:
        fixtures = recent_fixtures_by_team(team_id=team_id, season=season, last=fetch_last, league_id=league_id)
    except Exception as e:
        fixtures = []
        if LOG_LAMBDA_BLEND:
            print(f"[λ模型] 获取近况赛程失败 team={team_id}: {e}")
    RECENT_FORM_CACHE[key] = fixtures or []
    return RECENT_FORM_CACHE[key]

def _blend_recent_value(recent_val: Optional[float], fallback_val: float, mix: float) -> float:
    if fallback_val is None and recent_val is None:
        return 0.0
    if recent_val is None:
        return float(fallback_val)
    if fallback_val is None:
        return float(recent_val)
    mix_clamped = max(0.0, min(1.0, float(mix)))
    return float(mix_clamped * float(fallback_val) + (1.0 - mix_clamped) * float(recent_val))

def lambda_from_season_stats(h_stats: dict, a_stats: dict, league_avg: float, home_adv: float) -> tuple[tuple[float, float], dict]:
    denom = max(float(league_avg or 0.0), 1e-6)
    h_gf_home = _safe_stat(["goals","for","average","home"], h_stats, 1.3)
    h_ga_home = _safe_stat(["goals","against","average","home"], h_stats, 1.3)
    a_gf_away = _safe_stat(["goals","for","average","away"], a_stats, 1.3)
    a_ga_away = _safe_stat(["goals","against","average","away"], a_stats, 1.3)

    h_att = max(0.05, h_gf_home) / denom
    h_def = max(0.05, h_ga_home) / denom
    a_att = max(0.05, a_gf_away) / denom
    a_def = max(0.05, a_ga_away) / denom

    lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, home_adv)
    meta = {
        "h_att": float(h_att),
        "h_def": float(h_def),
        "a_att": float(a_att),
        "a_def": float(a_def),
        "h_for_avg": float(h_gf_home),
        "h_against_avg": float(h_ga_home),
        "a_for_avg": float(a_gf_away),
        "a_against_avg": float(a_ga_away),
    }
    return (float(lam_home), float(lam_away)), meta

def lambda_from_recent_form(
    home_id: int,
    away_id: int,
    league_id: int,
    season: int,
    league_avg: float,
    home_adv: float,
    season_meta: dict,
    config: dict,
) -> tuple[tuple[float, float], dict]:
    recent_games = max(1, int(config.get("recent_games", 6)))
    min_games = max(1, int(config.get("min_games", 3)))
    if min_games > recent_games:
        min_games = recent_games
    try:
        decay = float(config.get("decay", 0.85))
    except Exception:
        decay = 0.85
    fetch_last = int(config.get("fetch_last", recent_games))
    fetch_last = max(fetch_last, recent_games * 2)

    home_fixtures = fetch_recent_form(home_id, league_id, season, fetch_last)
    away_fixtures = fetch_recent_form(away_id, league_id, season, fetch_last)

    h_recent_for, h_recent_against, cnt_home = _recent_weighted_avg(home_fixtures, home_id, True, recent_games, decay)
    a_recent_for, a_recent_against, cnt_away = _recent_weighted_avg(away_fixtures, away_id, False, recent_games, decay)

    coverage_home = min(1.0, cnt_home / recent_games) if recent_games else 0.0
    coverage_away = min(1.0, cnt_away / recent_games) if recent_games else 0.0

    try:
        base_mix = float(config.get("season_mix", 0.3))
    except Exception:
        base_mix = 0.3
    base_mix = max(0.0, min(1.0, base_mix))

    def _effective_mix(base: float, coverage: float, enough_games: bool) -> float:
        if not enough_games:
            return 1.0
        return base + (1.0 - coverage) * (1.0 - base)

    eff_mix_home = _effective_mix(base_mix, coverage_home, cnt_home >= min_games)
    eff_mix_away = _effective_mix(base_mix, coverage_away, cnt_away >= min_games)

    fallback_h_for = max(0.05, float(season_meta.get("h_for_avg", league_avg)))
    fallback_h_against = max(0.05, float(season_meta.get("h_against_avg", league_avg)))
    fallback_a_for = max(0.05, float(season_meta.get("a_for_avg", league_avg)))
    fallback_a_against = max(0.05, float(season_meta.get("a_against_avg", league_avg)))

    h_for_blend = max(0.05, _blend_recent_value(h_recent_for, fallback_h_for, eff_mix_home))
    h_against_blend = max(0.05, _blend_recent_value(h_recent_against, fallback_h_against, eff_mix_home))
    a_for_blend = max(0.05, _blend_recent_value(a_recent_for, fallback_a_for, eff_mix_away))
    a_against_blend = max(0.05, _blend_recent_value(a_recent_against, fallback_a_against, eff_mix_away))

    denom = max(float(league_avg or 0.0), 1e-6)
    h_att = h_for_blend / denom
    h_def = h_against_blend / denom
    a_att = a_for_blend / denom
    a_def = a_against_blend / denom

    lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, home_adv)
    meta = {
        "home_games_used": int(cnt_home),
        "away_games_used": int(cnt_away),
        "home_recent_for": None if h_recent_for is None else float(h_recent_for),
        "home_recent_against": None if h_recent_against is None else float(h_recent_against),
        "away_recent_for": None if a_recent_for is None else float(a_recent_for),
        "away_recent_against": None if a_recent_against is None else float(a_recent_against),
        "home_eff_mix": float(eff_mix_home),
        "away_eff_mix": float(eff_mix_away),
    }
    return (float(lam_home), float(lam_away)), meta

def compute_lambda_models(
    league_id: int,
    season: int,
    home_id: int,
    away_id: int,
    h_stats: dict,
    a_stats: dict,
    league_avg: float,
) -> Dict[str, dict]:
    models: Dict[str, dict] = {}
    (lam_season, lam_season_away), season_meta = lambda_from_season_stats(h_stats, a_stats, league_avg, HOME_ADV)
    models["season"] = {
        "lam_home": lam_season,
        "lam_away": lam_season_away,
        "meta": season_meta,
    }

    recent_cfg = LAMBDA_MODEL_CONFIG.get("recent") or {}
    if float(recent_cfg.get("weight", 0.0)) > 0:
        try:
            (lam_recent, lam_recent_away), recent_meta = lambda_from_recent_form(
                home_id, away_id, league_id, season, league_avg, HOME_ADV, season_meta, recent_cfg
            )
            models["recent"] = {
                "lam_home": lam_recent,
                "lam_away": lam_recent_away,
                "meta": recent_meta,
            }
        except Exception as e:
            if LOG_LAMBDA_BLEND:
                print(f"[λ模型] 近况模型计算失败 {home_id}-{away_id}: {e}")
    return models

def blend_lambda_models(models: Dict[str, dict], config: Dict[str, dict]) -> tuple[float, float, Dict[str, float]]:
    valid = {
        name: data
        for name, data in models.items()
        if isinstance(data, dict) and data.get("lam_home") is not None and data.get("lam_away") is not None
    }
    if not valid:
        raise RuntimeError("无可用 λ 模型")

    weights_used: Dict[str, float] = {}
    weighted_home = 0.0
    weighted_away = 0.0
    for name, data in valid.items():
        weight = float((config.get(name) or {}).get("weight", 0.0))
        if weight <= 0:
            continue
        lam_h = float(data.get("lam_home", 0.0))
        lam_a = float(data.get("lam_away", 0.0))
        weights_used[name] = weight
        weighted_home += weight * lam_h
        weighted_away += weight * lam_a

    if not weights_used:
        first_name, data = next(iter(valid.items()))
        fallback_weights = {name: (1.0 if name == first_name else 0.0) for name in valid}
        return float(data.get("lam_home", 1.4)), float(data.get("lam_away", 1.1)), fallback_weights

    total_weight = sum(weights_used.values()) or 1.0
    lam_home = weighted_home / total_weight
    lam_away = weighted_away / total_weight
    normalized = {name: (weights_used.get(name, 0.0) / total_weight) for name in valid}
    return float(lam_home), float(lam_away), normalized

def format_lambda_detail(models: Dict[str, dict], weights: Dict[str, float]) -> str:
    parts: List[str] = []
    for name, data in models.items():
        lam_h = data.get("lam_home")
        lam_a = data.get("lam_away")
        if lam_h is None or lam_a is None:
            continue
        weight = weights.get(name, 0.0)
        parts.append(f"{name}:{float(lam_h):.3f}/{float(lam_a):.3f} (w={weight:.2f})")
    return " | ".join(parts)

def log_lambda_blend(home_name: str, away_name: str, models: Dict[str, dict], weights: Dict[str, float], lam_home: float, lam_away: float) -> None:
    entries = []
    for name, data in models.items():
        lam_h = data.get("lam_home")
        lam_a = data.get("lam_away")
        if lam_h is None or lam_a is None:
            continue
        raw_weight = float((LAMBDA_MODEL_CONFIG.get(name) or {}).get("weight", 0.0))
        norm_weight = weights.get(name, 0.0)
        meta = data.get("meta") or {}
        extra = ""
        if name == "recent":
            extra = (
                f" cntH={meta.get('home_games_used', 0)} cntA={meta.get('away_games_used', 0)}"
                f" mixH={meta.get('home_eff_mix', 0):.2f} mixA={meta.get('away_eff_mix', 0):.2f}"
            )
        entries.append(
            f"{name}:λ=({float(lam_h):.2f},{float(lam_a):.2f}) w_cfg={raw_weight:.2f} w_norm={norm_weight:.2f}{extra}"
        )
    detail = " | ".join(entries)
    print(f"[λ模型] {home_name} vs {away_name} -> {detail} => blend=({lam_home:.2f},{lam_away:.2f})")

# ================== 打印 & 导出工具 ==================
def _fmt_ou_book(line, odds, is_corner=False):
    if line is None or odds is None: return ""
    tag = "CRN" if is_corner else "OU"
    try: return f"{tag}{float(line):g}@{float(odds):.2f}"
    except: return ""

def _fmt_ah_book(home_line, odds, side: str):
    if home_line is None or odds is None: return ""
    try:
        ln = float(home_line)
        ln_side = ln if side.lower()=="home" else -ln
        sign = "+" if ln_side > 0 else ""
        return f"AH{sign}{ln_side:g}@{float(odds):.2f}"
    except: return ""

def _stake_pct_from_kelly(k: Optional[float]) -> float:
    try:
        if k is None: return 0.0
        pct = 100.0 * float(k) * float(KELLY_FRACTION)
        return float(min(STAKE_CAP_PCT, max(STAKE_MIN_PCT, round(pct, 2))))
    except: return 0.0

def export_picks(rows_all: List[Dict], date_str: str):
    candidates: List[Dict] = []

    def _with_quality(payload: Dict, row: Dict, key: str) -> Dict:
        out = dict(payload)
        quality_val = row.get(f"quality_{key}")
        if quality_val is not None:
            try:
                out["quality"] = float(quality_val)
            except (TypeError, ValueError):
                pass
        ev_input_val = row.get(f"ev_input_{key}")
        if ev_input_val is not None:
            try:
                out["ev_input"] = float(ev_input_val)
            except (TypeError, ValueError):
                pass
        ev_cal_val = row.get(f"ev_calibrated_{key}")
        if ev_cal_val is not None:
            try:
                out["ev_calibrated"] = float(ev_cal_val)
            except (TypeError, ValueError):
                pass
        score_val = row.get(f"score_{key}")
        if score_val is not None:
            try:
                out["score"] = float(score_val)
            except (TypeError, ValueError):
                pass
        return out

    def _to_float_safe(value) -> float | None:
        try:
            if value is None:
                return None
            if isinstance(value, (int, float)):
                return float(value)
            txt = str(value).strip()
            if not txt:
                return None
            return float(txt)
        except (TypeError, ValueError):
            return None

    def _liquidity_for_market(row: Dict, market: str) -> float:
        if market == "ou":
            vals = [
                _to_float_safe(row.get("ou_main_over_cnt")),
                _to_float_safe(row.get("ou_main_under_cnt")),
            ]
        elif market == "1x2":
            vals = [
                _to_float_safe(row.get("1x2_home_cnt")),
                _to_float_safe(row.get("1x2_draw_cnt")),
                _to_float_safe(row.get("1x2_away_cnt")),
            ]
        elif market == "ah":
            vals = [
                _to_float_safe(row.get("ah_home_cnt")),
                _to_float_safe(row.get("ah_away_cnt")),
            ]
        else:
            return 0.0
        nums = [float(v) for v in vals if v is not None and v > 0]
        if not nums:
            return 0.0
        return float(min(nums))

    def _percentile_threshold(values: List[float], pct: float) -> float | None:
        arr = [float(v) for v in values if v is not None and math.isfinite(v)]
        if not arr:
            return None
        arr.sort()
        if len(arr) == 1:
            return arr[0]
        pct = max(0.0, min(1.0, pct))
        pos = pct * (len(arr) - 1)
        low = int(math.floor(pos))
        high = int(math.ceil(pos))
        if low == high:
            return arr[low]
        weight = pos - low
        return arr[low] + (arr[high] - arr[low]) * weight

    def _round_robin_select(pool: List[Dict], limit: int, already: Set[str]) -> List[Dict]:
        if limit <= 0:
            return []
        grouped: Dict[tuple[str, str], List[Dict]] = {}
        for cand in pool:
            if cand["id"] in already:
                continue
            tier = cand.get("league_tier") or "unknown"
            key = (cand["market_type"], tier)
            grouped.setdefault(key, []).append(cand)
        for group in grouped.values():
            group.sort(key=lambda c: c["vi"], reverse=True)
        order = sorted(
            grouped.keys(),
            key=lambda item: (
                PICKS_MARKET_ORDER.index(item[0]) if item[0] in PICKS_MARKET_ORDER else len(PICKS_MARKET_ORDER),
                PICKS_TIER_ORDER.index(item[1]) if item[1] in PICKS_TIER_ORDER else len(PICKS_TIER_ORDER),
            ),
        )
        selected: List[Dict] = []
        while len(selected) < limit:
            progress = False
            for key in order:
                group = grouped.get(key)
                if not group:
                    continue
                while group and group[0]["id"] in already:
                    group.pop(0)
                if group:
                    cand = group.pop(0)
                    already.add(cand["id"])
                    selected.append(cand)
                    progress = True
                    if len(selected) >= limit:
                        break
            if not progress:
                break
        return selected

    for idx, row in enumerate(rows_all):
        base = {
            "date_utc": row.get("date_utc"),
            "kickoff_utc": row.get("kickoff_utc"),
            "league": row.get("league"),
            "home": row.get("home"),
            "away": row.get("away"),
        }
        tier_val = row.get("league_tier")
        league_tier = str(tier_val) if tier_val not in (None, "") else "unknown"

        liquidity_ou = _liquidity_for_market(row, "ou")
        ou_line = _to_float_safe(row.get("ou_main_line"))
        for side, label in (("over", "OU-Over"), ("under", "OU-Under")):
            key = f"ev_ou_main_{side}"
            ev_val = _to_float_safe(row.get(key))
            kelly_val = _to_float_safe(row.get(f"kelly_ou_main_{side}"))
            if ev_val is None or kelly_val is None:
                continue
            flag_val = str(row.get(f"flag_{key}") or "")
            if flag_val not in ("keep", "review"):
                continue
            vi_val = value_index(ev_val, kelly_val)
            if vi_val is None:
                continue
            odds_val = _to_float_safe(row.get(f"odds_ou_main_{side}"))
            candidates.append(
                {
                    "id": f"{idx}:{key}",
                    "row": row,
                    "base": base,
                    "key": key,
                    "market_type": "ou",
                    "market_label": label,
                    "ev": float(ev_val),
                    "kelly": float(kelly_val),
                    "vi": float(vi_val),
                    "flag": flag_val,
                    "quality": _to_float_safe(row.get(f"quality_{key}")),
                    "liquidity": liquidity_ou,
                    "league_tier": league_tier,
                    "odds": odds_val,
                    "line": ou_line,
                    "book": _fmt_ou_book(row.get("ou_main_line"), row.get(f"odds_ou_main_{side}"), False),
                }
            )

        liquidity_1x2 = _liquidity_for_market(row, "1x2")
        for side, label in (("home", "1X2-Home"), ("draw", "1X2-Draw"), ("away", "1X2-Away")):
            key = f"ev_1x2_{side}"
            ev_val = _to_float_safe(row.get(key))
            kelly_val = _to_float_safe(row.get(f"kelly_1x2_{side}"))
            odds_val = _to_float_safe(row.get(f"odds_1x2_{side}"))
            if ev_val is None or kelly_val is None:
                continue
            flag_val = str(row.get(f"flag_{key}") or "")
            if flag_val not in ("keep", "review"):
                continue
            vi_val = value_index(ev_val, kelly_val)
            if vi_val is None:
                continue
            candidates.append(
                {
                    "id": f"{idx}:{key}",
                    "row": row,
                    "base": base,
                    "key": key,
                    "market_type": "1x2",
                    "market_label": label,
                    "ev": float(ev_val),
                    "kelly": float(kelly_val),
                    "vi": float(vi_val),
                    "flag": flag_val,
                    "quality": _to_float_safe(row.get(f"quality_{key}")),
                    "liquidity": liquidity_1x2,
                    "league_tier": league_tier,
                    "odds": odds_val,
                    "line": None,
                    "book": f"{label}@{odds_val:.2f}" if odds_val is not None else label,
                }
            )

        liquidity_ah = _liquidity_for_market(row, "ah")
        ah_line = _to_float_safe(row.get("ah_line"))
        if ah_line is not None:
            for side, label in (("home", "AH-Home"), ("away", "AH-Away")):
                key = f"ev_ah_{side}"
                ev_val = _to_float_safe(row.get(key))
                kelly_val = _to_float_safe(row.get(f"kelly_ah_{side}"))
                odds_val = _to_float_safe(row.get(f"odds_ah_{side}"))
                if ev_val is None or kelly_val is None:
                    continue
                flag_val = str(row.get(f"flag_{key}") or "")
                if flag_val not in ("keep", "review"):
                    continue
                vi_val = value_index(ev_val, kelly_val)
                if vi_val is None:
                    continue
                candidates.append(
                    {
                        "id": f"{idx}:{key}",
                        "row": row,
                        "base": base,
                        "key": key,
                        "market_type": "ah",
                        "market_label": label,
                        "ev": float(ev_val),
                        "kelly": float(kelly_val),
                        "vi": float(vi_val),
                        "flag": flag_val,
                        "quality": _to_float_safe(row.get(f"quality_{key}")),
                        "liquidity": liquidity_ah,
                        "league_tier": league_tier,
                        "odds": odds_val,
                        "line": ah_line,
                        "book": _fmt_ah_book(row.get("ah_line"), row.get(f"odds_ah_{side}"), side),
                    }
                )

    quality_thresholds = {
        market: _percentile_threshold(
            [cand.get("quality") for cand in candidates if cand.get("market_type") == market],
            PICKS_BACKOFF_PERCENTILE,
        )
        for market in PICKS_STRICT_RULES
    }
    liquidity_thresholds = {
        market: _percentile_threshold(
            [cand.get("liquidity") for cand in candidates if cand.get("market_type") == market and cand.get("liquidity")],
            PICKS_BACKOFF_PERCENTILE,
        )
        for market in PICKS_STRICT_RULES
    }

    def _assign_gate_level(candidate: Dict) -> str | None:
        market = candidate.get("market_type")
        rules = PICKS_STRICT_RULES.get(market)
        if not rules:
            return None
        quality_val = candidate.get("quality")
        if quality_val is None:
            quality_val = 0.0
        liquidity_val = candidate.get("liquidity")
        if liquidity_val is None:
            liquidity_val = 0.0
        flag_val = candidate.get("flag")
        ev_val = candidate.get("ev")
        kelly_val = candidate.get("kelly")

        if (
            flag_val == "keep"
            and ev_val is not None
            and kelly_val is not None
            and ev_val >= rules["ev"]
            and kelly_val >= rules["kelly"]
            and quality_val >= rules["quality"]
            and liquidity_val >= rules["liquidity"]
        ):
            return "strict"

        ev_backoff1 = max(0.0, rules["ev"] - PICKS_BACKOFF1_EV_DELTA)
        kelly_backoff1 = PICKS_BACKOFF1_KELLY.get(market, rules["kelly"])
        if (
            flag_val in ("keep", "review")
            and ev_val is not None
            and kelly_val is not None
            and ev_val >= ev_backoff1
            and kelly_val >= kelly_backoff1
            and quality_val >= rules["quality"]
            and liquidity_val >= rules["liquidity"]
        ):
            q_thr = quality_thresholds.get(market)
            l_thr = liquidity_thresholds.get(market)
            if (q_thr is None or quality_val >= q_thr) and (l_thr is None or liquidity_val >= l_thr):
                return "backoff1"

        ev_backoff2 = max(0.0, rules["ev"] - PICKS_BACKOFF2_EXTRA_EV)
        if (
            flag_val in ("keep", "review")
            and ev_val is not None
            and kelly_val is not None
            and ev_val >= ev_backoff2
            and kelly_val >= PICKS_BACKOFF2_KELLY
        ):
            tier = candidate.get("league_tier") or "unknown"
            if tier not in PICKS_ALLOWED_BACKOFF_TIERS:
                return None
            if market == "ou":
                line_val = candidate.get("line")
                if line_val is None:
                    return None
                if not (
                    PICKS_BACKOFF2_OU_LINE_RANGE[0] <= line_val <= PICKS_BACKOFF2_OU_LINE_RANGE[1]
                ):
                    return None
            else:
                odds_val = candidate.get("odds")
                if odds_val is None or not (
                    PICKS_BACKOFF2_ODDS_RANGE[0] <= odds_val <= PICKS_BACKOFF2_ODDS_RANGE[1]
                ):
                    return None
            quality_val = max(0.0, quality_val)
            liquidity_val = max(0.0, liquidity_val)
            composite = kelly_val * quality_val * max(liquidity_val, 1.0)
            candidate["gate_composite"] = composite
            if composite >= PICKS_BACKOFF2_COMPOSITE_MIN:
                return "backoff2"
        return None

    for cand in candidates:
        cand["gate_level"] = _assign_gate_level(cand)

    eligible = [cand for cand in candidates if cand.get("gate_level")]
    limit = len(eligible) if PICKS_TOP_N is None else min(int(PICKS_TOP_N), len(eligible))
    selected: List[Dict] = []
    already_ids: Set[str] = set()

    level_groups = {
        level: [cand for cand in eligible if cand.get("gate_level") == level]
        for level in ("strict", "backoff1", "backoff2")
    }

    selected.extend(_round_robin_select(level_groups["strict"], limit, already_ids))

    target_min = min(PICKS_GUARD_MIN, limit)
    if len(selected) < target_min:
        take = min(limit - len(selected), target_min - len(selected))
        selected.extend(_round_robin_select(level_groups["backoff1"], take, already_ids))
    if len(selected) < target_min:
        take = min(limit - len(selected), target_min - len(selected))
        selected.extend(_round_robin_select(level_groups["backoff2"], take, already_ids))

    for level in ("strict", "backoff1", "backoff2"):
        if len(selected) >= limit:
            break
        take = limit - len(selected)
        selected.extend(_round_robin_select(level_groups[level], take, already_ids))

    picks: List[Dict] = []
    for cand in selected:
        payload = {
            **cand["base"],
            "market": cand["market_label"],
            "book": cand.get("book"),
            "ev": float(cand["ev"]),
            "kelly": float(cand["kelly"]),
            "value_index": float(cand["vi"]),
            "stake_pct": _stake_pct_from_kelly(cand["kelly"]),
        }
        payload = _with_quality(payload, cand["row"], cand["key"])
        payload["gate_level"] = cand.get("gate_level")
        if cand.get("gate_composite") is not None:
            try:
                payload["gate_score"] = round(float(cand["gate_composite"]), 6)
            except (TypeError, ValueError):
                pass
        picks.append(payload)

    out_dir = os.path.join(os.getcwd(), "out")
    os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"picks_{date_str}.csv")
    fieldnames = [
        "date_utc",
        "kickoff_utc",
        "league",
        "home",
        "away",
        "market",
        "book",
        "ev",
        "kelly",
        "value_index",
        "stake_pct",
        "gate_level",
        "gate_score",
        "quality",
        "ev_input",
        "ev_calibrated",
        "score",
    ]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
        w.writeheader()
        for payload in picks[:limit]:
            w.writerow(payload)

    level_counts = {
        level: sum(1 for cand in selected if cand.get("gate_level") == level)
        for level in ("strict", "backoff1", "backoff2")
    }
    print(
        f"\n已导出下注清单到: {out_file}  （{len(picks[:limit])} 条，strict={level_counts['strict']} / backoff1={level_counts['backoff1']} / backoff2={level_counts['backoff2']}）"
    )

def _median(arr: List[float]) -> Optional[float]:
    arr = [float(x) for x in arr if x];
    if not arr: return None
    arr.sort(); n=len(arr)
    return arr[n//2] if n%2==1 else 0.5*(arr[n//2-1]+arr[n//2])

def _ou_overround(oo: float, uu: float) -> float:
    try: return 1.0/float(oo) + 1.0/float(uu)
    except: return 9.9

# —— 新增：通用小工具 & AH 全线归一 & 主盘选择 —— #
def _to_float(x, default=None):
    try:
        if isinstance(x, str):
            x = x.replace("+", "")
        return float(x)
    except:
        return default

def build_ah_lines(odds: dict) -> dict:
    """
    统一把 AH 全线提取/归一（支持多个可能的键名和数据形态）：
    输出:
      { "0.25": {"home_median":..., "away_median":..., "home_cnt":..., "away_cnt":..., "overround":...}, ... }
    """
    if not isinstance(odds, dict):
        return {}

    # 1) 已有标准结构
    if isinstance(odds.get("ah_lines"), dict) and odds["ah_lines"]:
        return odds["ah_lines"]

    # 2) 多候选键名（容错）
    cand_keys = ["_raw_ah_map", "ah_raw_map", "asian_handicap_map", "asian_map", "AH", "ah"]
    raw = None
    for k in cand_keys:
        if isinstance(odds.get(k), dict) and odds[k]:
            raw = odds[k]; break
    if raw is None:
        return {}

    out = {}
    for line_key, sides in raw.items():
        ln = _to_float(line_key, default=None)
        if ln is None or not isinstance(sides, dict):
            continue

        hs = sides.get("home")
        as_ = sides.get("away")

        # 支持“列表/单值”
        if isinstance(hs, (list, tuple)):
            hs = [_to_float(v) for v in hs if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oh = _median(hs)
            cnt_h = len(hs)
        else:
            oh = _to_float(hs)
            cnt_h = 1 if oh is not None else 0

        if isinstance(as_, (list, tuple)):
            as_ = [_to_float(v) for v in as_ if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oa = _median(as_)
            cnt_a = len(as_)
        else:
            oa = _to_float(as_)
            cnt_a = 1 if oa is not None else 0

        if oh is None or oa is None:
            continue

        oround = _ou_overround(oh, oa)
        out[str(float(ln))] = {
            "home_median": float(oh), "away_median": float(oa),
            "home_cnt": int(cnt_h), "away_cnt": int(cnt_a),
            "overround": float(oround)
        }
    return out

def select_best_ah_main(ah_lines: dict, strict: int = 1) -> dict | None:
    """
    从 ah_lines 中挑“主盘”：优先低超盘、样本多、|line|小。
    返回 (line, home_odds, away_odds) 或 None
    """
    if not isinstance(ah_lines, dict) or not ah_lines:
        return None

    cands = []
    for sline, info in ah_lines.items():
        ln = _to_float(sline, default=None)
        oh = _to_float((info or {}).get("home_median"), default=None)
        oa = _to_float((info or {}).get("away_median"), default=None)
        if ln is None or oh is None or oa is None:
            continue
        cnt_h = int((info or {}).get("home_cnt", 0) or 0)
        cnt_a = int((info or {}).get("away_cnt", 0) or 0)
        oround = _to_float((info or {}).get("overround"), default=9.9)

        if strict:
            if min(cnt_h, cnt_a) < AH_MIN_CNT:
                continue
            if not (1.00 <= oround <= AH_MAX_OR):
                continue

        cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        # 放宽再挑一次
        for sline, info in ah_lines.items():
            ln = _to_float(sline, default=None)
            oh = _to_float((info or {}).get("home_median"), default=None)
            oa = _to_float((info or {}).get("away_median"), default=None)
            if ln is None or oh is None or oa is None:
                continue
            cnt_h = int((info or {}).get("home_cnt", 0) or 0)
            cnt_a = int((info or {}).get("away_cnt", 0) or 0)
            oround = _to_float((info or {}).get("overround"), default=9.9)
            cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        return None

    cands.sort()
    _, _, _, ln, oh, oa = cands[0]
    info = ah_lines.get(str(float(ln))) or ah_lines.get(float(ln)) or {}
    return {
        "line": float(ln),
        "home_odds": float(oh),
        "away_odds": float(oa),
        "home_cnt": int((info or {}).get("home_cnt", 0) or 0),
        "away_cnt": int((info or {}).get("away_cnt", 0) or 0),
        "overround": float((info or {}).get("overround", 0.0) or 0.0),
        "update_age_min": (info or {}).get("update_age_min"),
    }

# ================== 主流程 ==================
def main():
    random.seed(42); np.random.seed(42)
    date_str = _today_utc_date()
    print(f"=== 37号 · 每日情报站（并发/快速版）@ {date_str} ===")

    fixtures = fixtures_by_date(date_str)
    if not fixtures:
        print("该日期无赛程或 API 无返回。"); return

    if EXCLUDE_NOISY:
        kept = []
        for fx in fixtures:
            lgname = ((fx.get("league") or {}).get("name") or "").lower()
            if not any(k in lgname for k in EXCLUDE_KEYS):
                kept.append(fx)
        fixtures = kept
    print(f"拉取赛程：{len(fixtures)} 场。正在预取球队统计…")

    prefetch_team_stats(fixtures)

    rows_all: List[Dict] = []
    matrix_rows: List[Dict] = []

    # 全线榜单池
    ou_all_over, ou_all_under = [], []
    crn_all_over, crn_all_under = [], []
    ah_all_home, ah_all_away = [], []

    # AH 诊断计数
    cnt_ah_has_line = cnt_ah_ev_home = cnt_ah_ev_away = 0

    done = 0
    for fx in fixtures:
        try:
            league = fx["league"]; league_id = league["id"]; season = league["season"]
            league_name = league.get("name")
            league_country = league.get("country")
            fixture_info = fx.get("fixture", {}); kickoff_utc = fixture_info.get("date"); fx_id = fixture_info.get("id")
            home = fx["teams"]["home"]; away = fx["teams"]["away"]
            home_id, away_id = home["id"], away["id"]
            home_name, away_name = home["name"], away["name"]
        except Exception as e:
            print(f"跳过一场（解析失败）：{e}"); continue

        league_avg = compute_league_avg_from_cache(league_id, season)
        league_tier = classify_league_tier(league_id, league_name, league_country)

        h_st = TEAM_STATS_CACHE.get((league_id, season, home_id), {}) or {}
        a_st = TEAM_STATS_CACHE.get((league_id, season, away_id), {}) or {}

        lambda_models = compute_lambda_models(
            league_id=league_id,
            season=season,
            home_id=home_id,
            away_id=away_id,
            h_stats=h_st,
            a_stats=a_st,
            league_avg=league_avg,
        )
        lam_home, lam_away, lam_weights = blend_lambda_models(lambda_models, LAMBDA_MODEL_CONFIG)
        lam_detail = format_lambda_detail(lambda_models, lam_weights)
        if LOG_LAMBDA_BLEND:
            log_lambda_blend(home_name, away_name, lambda_models, lam_weights, lam_home, lam_away)

        data_quality_score: float | None = None
        sample_size_recent: float | None = None
        recent_meta = (lambda_models.get("recent") or {}).get("meta") if isinstance(lambda_models.get("recent"), dict) else None
        if isinstance(recent_meta, dict) and recent_meta:
            try:
                eff_home = float(recent_meta.get("home_eff_mix", 1.0))
            except (TypeError, ValueError):
                eff_home = 1.0
            try:
                eff_away = float(recent_meta.get("away_eff_mix", 1.0))
            except (TypeError, ValueError):
                eff_away = 1.0
            coverage = 1.0 - 0.5 * (max(0.0, min(1.0, eff_home)) + max(0.0, min(1.0, eff_away)))
            data_quality_score = max(0.0, min(1.0, coverage))
            try:
                hg = float(recent_meta.get("home_games_used", 0.0))
                ag = float(recent_meta.get("away_games_used", 0.0))
                sample_size_recent = max(0.0, 0.5 * (hg + ag))
            except (TypeError, ValueError):
                sample_size_recent = None

        sim = monte_carlo_simulate(lam_home, lam_away, n_sims=N_SIMS_GOALS, over_line=2.5)
        _, _, totals = simulate_goals(lam_home, lam_away, n_sims=N_SIMS_GOALS)
        try: totals = [int(x) for x in totals]
        except: totals = [int(totals)]

        odds = odds_by_fixture(fx_id) if fx_id else {}

        flag_map: Dict[str, str] = {}
        flag_reason_map: Dict[str, str] = {}
        vi_map: Dict[str, float | None] = {}
        ev_meta_map: Dict[str, Dict[str, object]] = {}

        # ===== 1X2 =====
        o1_h,o1_d,o1_a = odds.get("1x2_home"),odds.get("1x2_draw"),odds.get("1x2_away")
        cnt_1x2_h = odds.get("1x2_home_cnt")
        cnt_1x2_d = odds.get("1x2_draw_cnt")
        cnt_1x2_a = odds.get("1x2_away_cnt")
        overround_1x2 = odds.get("1x2_overround")
        update_age_1x2 = odds.get("1x2_update_age_min")
        ev1_h=ev1_d=ev1_a=k1_h=k1_d=k1_a=None
        consensus_1x2: Dict[str, float] = {}
        ok1 = sanitize_1x2(o1_h,o1_d,o1_a)
        if ok1:
            o1_h,o1_d,o1_a = ok1
            ev1_h,k1_h = ev_kelly_binary(sim["p_home"], o1_h)
            ev1_d,k1_d = ev_kelly_binary(sim["p_draw"], o1_d)
            ev1_a,k1_a = ev_kelly_binary(sim["p_away"], o1_a)
            if is_ev_outlier(max([x for x in (ev1_h,ev1_d,ev1_a) if x is not None], default=0)):
                ev1_h=ev1_d=ev1_a=k1_h=k1_d=k1_a=None
            else:
                try:
                    inv_h = 1.0 / float(o1_h)
                    inv_d = 1.0 / float(o1_d)
                    inv_a = 1.0 / float(o1_a)
                    total_inv = inv_h + inv_d + inv_a
                    if total_inv > 0:
                        consensus_1x2 = {
                            "home": inv_h / total_inv,
                            "draw": inv_d / total_inv,
                            "away": inv_a / total_inv,
                        }
                except Exception:
                    consensus_1x2 = {}

        cnts_1x2 = [int(c) for c in (cnt_1x2_h, cnt_1x2_d, cnt_1x2_a) if isinstance(c, (int, float)) and c > 0]
        min_cnt_1x2 = min(cnts_1x2) if cnts_1x2 else None

        ev1_h, k1_h = apply_ev_filter(
            "ev_1x2_home",
            ev1_h,
            k1_h,
            "1x2",
            league_tier,
            min_bookmakers=min_cnt_1x2,
            overround=overround_1x2,
            update_age=update_age_1x2,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=o1_h,
            model_prob=sim.get("p_home"),
            consensus_prob=consensus_1x2.get("home") if consensus_1x2 else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )
        ev1_d, k1_d = apply_ev_filter(
            "ev_1x2_draw",
            ev1_d,
            k1_d,
            "1x2",
            league_tier,
            min_bookmakers=min_cnt_1x2,
            overround=overround_1x2,
            update_age=update_age_1x2,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=o1_d,
            model_prob=sim.get("p_draw"),
            consensus_prob=consensus_1x2.get("draw") if consensus_1x2 else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )
        ev1_a, k1_a = apply_ev_filter(
            "ev_1x2_away",
            ev1_a,
            k1_a,
            "1x2",
            league_tier,
            min_bookmakers=min_cnt_1x2,
            overround=overround_1x2,
            update_age=update_age_1x2,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=o1_a,
            model_prob=sim.get("p_away"),
            consensus_prob=consensus_1x2.get("away") if consensus_1x2 else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )

        # ===== Goals OU 主盘 =====
        ou_main_line   = odds.get("ou_main_line")
        ou_main_over   = odds.get("ou_main_over")
        ou_main_under  = odds.get("ou_main_under")
        ou_cnt_o       = odds.get("ou_main_over_cnt") or 0
        ou_cnt_u       = odds.get("ou_main_under_cnt") or 0
        ou_overround   = odds.get("ou_main_overround") or 9.9

        ev_main_over = ev_main_under = k_main_over = k_main_under = None
        p_model_ou_main_over = p_model_ou_main_under = None
        consensus_ou_main: Dict[str, float] = {}
        if ou_main_line is not None and ou_main_over is not None and ou_main_under is not None:
            pair = sanitize_ou_pair(ou_main_over, ou_main_under)
            if pair and (not STRICT_OU_MAIN or (ou_cnt_o >= OU_MIN_CNT and ou_cnt_u >= OU_MIN_CNT and ou_overround <= OU_MAX_OR)):
                ou_main_over, ou_main_under = pair
                res = ou_ev_kelly_from_totals_quarter(float(ou_main_line), float(ou_main_over), float(ou_main_under), totals)
                ev_main_over, k_main_over = res["EV_over"],  res["Kelly_over"]
                ev_main_under, k_main_under = res["EV_under"], res["Kelly_under"]
                p_model_ou_main_over = res.get("p_over_success")
                p_model_ou_main_under = res.get("p_under_success")
                if is_ev_outlier(max([x for x in (ev_main_over, ev_main_under) if x is not None], default=0)):
                    ev_main_over = ev_main_under = k_main_over = k_main_under = None
                    p_model_ou_main_over = p_model_ou_main_under = None
                else:
                    try:
                        inv_o = 1.0 / float(ou_main_over)
                        inv_u = 1.0 / float(ou_main_under)
                        total_inv = inv_o + inv_u
                        if total_inv > 0:
                            consensus_ou_main = {"over": inv_o / total_inv, "under": inv_u / total_inv}
                    except Exception:
                        consensus_ou_main = {}

        cnts_ou_main = [int(c) for c in (ou_cnt_o, ou_cnt_u) if isinstance(c, (int, float)) and c > 0]
        min_cnt_ou_main = min(cnts_ou_main) if cnts_ou_main else None
        update_age_ou_main = odds.get("ou_main_update_age_min")

        ev_main_over, k_main_over = apply_ev_filter(
            "ev_ou_main_over",
            ev_main_over,
            k_main_over,
            "ou",
            league_tier,
            min_bookmakers=min_cnt_ou_main,
            overround=ou_overround,
            update_age=update_age_ou_main,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=ou_main_over,
            model_prob=p_model_ou_main_over,
            consensus_prob=consensus_ou_main.get("over") if consensus_ou_main else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )
        ev_main_under, k_main_under = apply_ev_filter(
            "ev_ou_main_under",
            ev_main_under,
            k_main_under,
            "ou",
            league_tier,
            min_bookmakers=min_cnt_ou_main,
            overround=ou_overround,
            update_age=update_age_ou_main,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=ou_main_under,
            model_prob=p_model_ou_main_under,
            consensus_prob=consensus_ou_main.get("under") if consensus_ou_main else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )

        # ===== OU@2.5 参考 =====
        o25_over,o25_under = odds.get("ou_over_2_5"),odds.get("ou_under_2_5")
        ev25_over=ev25_under=k25_over=k25_under=None
        p_model_ou25_over = p_model_ou25_under = None
        consensus_ou25: Dict[str, float] = {}
        ok25 = sanitize_ou_pair(o25_over,o25_under)
        overround_ou25 = None
        if ok25:
            o25_over,o25_under = ok25
            res25 = ou_ev_kelly_from_totals_quarter(2.5, float(o25_over), float(o25_under), totals)
            ev25_over, k25_over = res25["EV_over"],  res25["Kelly_over"]
            ev25_under, k25_under = res25["EV_under"], res25["Kelly_under"]
            p_model_ou25_over = res25.get("p_over_success")
            p_model_ou25_under = res25.get("p_under_success")
            if is_ev_outlier(max([x for x in (ev25_over,ev25_under) if x is not None], default=0)):
                ev25_over=ev25_under=k25_over=k25_under=None
                p_model_ou25_over = p_model_ou25_under = None
            else:
                try:
                    overround_ou25 = float(1.0/float(o25_over) + 1.0/float(o25_under))
                    inv_o = 1.0 / float(o25_over)
                    inv_u = 1.0 / float(o25_under)
                    total_inv = inv_o + inv_u
                    if total_inv > 0:
                        consensus_ou25 = {"over": inv_o / total_inv, "under": inv_u / total_inv}
                except Exception:
                    overround_ou25 = None
                    consensus_ou25 = {}

        min_cnt_ou_25 = min_cnt_ou_main
        ev25_over, k25_over = apply_ev_filter(
            "ev_ou_over2.5",
            ev25_over,
            k25_over,
            "ou",
            league_tier,
            min_bookmakers=min_cnt_ou_25,
            overround=overround_ou25 if overround_ou25 is not None else ou_overround,
            update_age=update_age_ou_main,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=o25_over,
            model_prob=p_model_ou25_over,
            consensus_prob=consensus_ou25.get("over") if consensus_ou25 else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )
        ev25_under, k25_under = apply_ev_filter(
            "ev_ou_under2.5",
            ev25_under,
            k25_under,
            "ou",
            league_tier,
            min_bookmakers=min_cnt_ou_25,
            overround=ou_overround,
            update_age=update_age_ou_main,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=o25_under,
            model_prob=p_model_ou25_under,
            consensus_prob=consensus_ou25.get("under") if consensus_ou25 else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )

        # ===== AH 全线（统一归一）
        ah_lines = build_ah_lines(odds)

        # ===== AH 主盘（缺就从全线里自选）
        ah_line, ah_oh, ah_oa = odds.get("ah_line"), odds.get("ah_home_odds"), odds.get("ah_away_odds")
        ah_cnt_h = odds.get("ah_home_cnt") or 0
        ah_cnt_a = odds.get("ah_away_cnt") or 0
        ah_overround = odds.get("ah_overround")
        ah_update_age = odds.get("ah_main_update_age_min")
        if ah_line is None or ah_oh is None or ah_oa is None:
            pick = select_best_ah_main(ah_lines, strict=STRICT_AH_MAIN)
            if pick:
                ah_line = pick.get("line")
                ah_oh = pick.get("home_odds")
                ah_oa = pick.get("away_odds")
                ah_cnt_h = pick.get("home_cnt", ah_cnt_h)
                ah_cnt_a = pick.get("away_cnt", ah_cnt_a)
                ah_overround = pick.get("overround", ah_overround)
                ah_update_age = pick.get("update_age_min", ah_update_age)

        ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None
        p_model_ah_home = p_model_ah_away = None
        consensus_ah: Dict[str, float] = {}
        if ah_line is not None and ah_oh is not None and ah_oa is not None:
            cnt_ah_has_line += 1
            probs_ah = ah_probabilities_from_lams(lam_home, lam_away, h=float(ah_line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs_ah, odds_home=float(ah_oh), odds_away=float(ah_oa))
            home_info = probs_ah.get("home", {}) if isinstance(probs_ah, dict) else {}
            away_info = probs_ah.get("away", {}) if isinstance(probs_ah, dict) else {}
            if isinstance(evk.get("home"), dict):
                ev_ah_h, k_ah_h = evk["home"].get("EV"), evk["home"].get("Kelly")
            if isinstance(evk.get("away"), dict):
                ev_ah_a, k_ah_a = evk["away"].get("EV"), evk["away"].get("Kelly")
            if is_ev_outlier(max([x for x in (ev_ah_h, ev_ah_a) if x is not None], default=0)):
                ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None
            else:
                try:
                    p_model_ah_home = float(home_info.get("p_win", 0.0)) + 0.5 * float(home_info.get("p_push", 0.0))
                    p_model_ah_away = float(away_info.get("p_win", 0.0)) + 0.5 * float(away_info.get("p_push", 0.0))
                except Exception:
                    p_model_ah_home = p_model_ah_away = None
                try:
                    inv_h = 1.0 / float(ah_oh)
                    inv_a = 1.0 / float(ah_oa)
                    total_inv = float(ah_overround) if ah_overround else (inv_h + inv_a)
                    if total_inv > 0:
                        consensus_ah = {"home": inv_h / total_inv, "away": inv_a / total_inv}
                except Exception:
                    consensus_ah = {}

        cnts_ah = [int(c) for c in (ah_cnt_h, ah_cnt_a) if isinstance(c, (int, float)) and c > 0]
        min_cnt_ah = min(cnts_ah) if cnts_ah else None
        ev_ah_h, k_ah_h = apply_ev_filter(
            "ev_ah_home",
            ev_ah_h,
            k_ah_h,
            "ah",
            league_tier,
            min_bookmakers=min_cnt_ah,
            overround=ah_overround,
            update_age=ah_update_age,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=ah_oh,
            model_prob=p_model_ah_home,
            consensus_prob=consensus_ah.get("home") if consensus_ah else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )
        ev_ah_a, k_ah_a = apply_ev_filter(
            "ev_ah_away",
            ev_ah_a,
            k_ah_a,
            "ah",
            league_tier,
            min_bookmakers=min_cnt_ah,
            overround=ah_overround,
            update_age=ah_update_age,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=ah_oa,
            model_prob=p_model_ah_away,
            consensus_prob=consensus_ah.get("away") if consensus_ah else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )

        if flag_map.get("ev_ah_home") in ("keep", "review"):
            cnt_ah_ev_home += 1
        if flag_map.get("ev_ah_away") in ("keep", "review"):
            cnt_ah_ev_away += 1

        # ===== 角球 OU 主盘 =====
        crn_main_line  = odds.get("crn_main_line")
        crn_main_over  = odds.get("crn_main_over")
        crn_main_under = odds.get("crn_main_under")
        crn_cnt_o      = odds.get("crn_main_over_cnt") or 0
        crn_cnt_u      = odds.get("crn_main_under_cnt") or 0
        crn_overround  = odds.get("crn_main_overround") or 9.9

        ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None
        p_model_crn_over = p_model_crn_under = None
        consensus_crn: Dict[str, float] = {}
        crn_totals_list: List[int] | None = None

        if crn_main_line is not None and crn_main_over is not None and crn_main_under is not None:
            pair = sanitize_ou_pair(crn_main_over, crn_main_under)
            if pair and (not STRICT_CRN_MAIN or (crn_cnt_o >= CRN_MIN_CNT and crn_cnt_u >= CRN_MIN_CNT and crn_overround <= CRN_MAX_OR)):
                crn_main_over, crn_main_under = pair
                lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
                crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
                crn_totals_list = [int(x) for x in crn_totals]
                resC = ou_ev_kelly_from_totals_quarter(float(crn_main_line), float(crn_main_over), float(crn_main_under), crn_totals_list)
                ev_crn_over, k_crn_over = resC["EV_over"],  resC["Kelly_over"]
                ev_crn_under, k_crn_under = resC["EV_under"], resC["Kelly_under"]
                p_model_crn_over = resC.get("p_over_success")
                p_model_crn_under = resC.get("p_under_success")
                if is_ev_outlier(max([x for x in (ev_crn_over,ev_crn_under) if x is not None], default=0)):
                    ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None
                    p_model_crn_over = p_model_crn_under = None
                else:
                    try:
                        inv_o = 1.0 / float(crn_main_over)
                        inv_u = 1.0 / float(crn_main_under)
                        total_inv = inv_o + inv_u
                        if total_inv > 0:
                            consensus_crn = {"over": inv_o / total_inv, "under": inv_u / total_inv}
                    except Exception:
                        consensus_crn = {}

        cnts_crn = [int(c) for c in (crn_cnt_o, crn_cnt_u) if isinstance(c, (int, float)) and c > 0]
        min_cnt_crn = min(cnts_crn) if cnts_crn else None
        update_age_crn = odds.get("crn_main_update_age_min")

        ev_crn_over, k_crn_over = apply_ev_filter(
            "ev_crn_main_over",
            ev_crn_over,
            k_crn_over,
            "derivative",
            league_tier,
            min_bookmakers=min_cnt_crn,
            overround=crn_overround,
            update_age=update_age_crn,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=crn_main_over,
            model_prob=p_model_crn_over,
            consensus_prob=consensus_crn.get("over") if consensus_crn else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )
        ev_crn_under, k_crn_under = apply_ev_filter(
            "ev_crn_main_under",
            ev_crn_under,
            k_crn_under,
            "derivative",
            league_tier,
            min_bookmakers=min_cnt_crn,
            overround=crn_overround,
            update_age=update_age_crn,
            flag_map=flag_map,
            reason_map=flag_reason_map,
            vi_map=vi_map,
            meta_map=ev_meta_map,
            odds=crn_main_under,
            model_prob=p_model_crn_under,
            consensus_prob=consensus_crn.get("under") if consensus_crn else None,
            data_quality=data_quality_score,
            sample_size=sample_size_recent,
        )

        # ===== 全线榜单池 & 盘口矩阵（优先使用 *_lines；无则回退 _raw_*） =====
        ou_lines = odds.get("ou_lines") or {}
        crn_lines = odds.get("crn_lines") or {}
        # —— AH 用统一归一后的
        #   ah_lines 已在上面 build_ah_lines(odds) 生成

        # 回退：当 *_lines 缺失时，从 _raw_* 现算（OU/CRN 保持原逻辑）
        if not ou_lines and odds.get("_raw_ou_map"):
            for line, sides in odds["_raw_ou_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                ou_lines[str(float(line))] = {"over_median": om, "under_median": um,
                                              "over_cnt": len(ov), "under_cnt": len(un), "overround": oround}
        if not crn_lines and odds.get("_raw_crn_map"):
            for line, sides in odds["_raw_crn_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                crn_lines[str(float(line))] = {"over_median": om, "under_median": um,
                                               "over_cnt": len(ov), "under_cnt": len(un), "overround": oround}

        # —— 全线榜单池（OU）
        for sline, info in (ou_lines.items() if isinstance(ou_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            if om is None or um is None or not (1.00 <= float(oround) <= 1.25): continue
            resL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), totals)
            if resL["EV_over"] is not None and resL["Kelly_over"] is not None:
                vi = value_index(resL["EV_over"], resL["Kelly_over"])
                ou_all_over.append((vi, home_name, away_name, line, float(om), resL["EV_over"], resL["Kelly_over"]))
            if resL["EV_under"] is not None and resL["Kelly_under"] is not None:
                vi = value_index(resL["EV_under"], resL["Kelly_under"])
                ou_all_under.append((vi, home_name, away_name, line, float(um), resL["EV_under"], resL["Kelly_under"]))

        # —— 全线榜单池（CRN）
        if crn_totals_list is None:
            lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
            crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
            crn_totals_list = [int(x) for x in crn_totals]
        for sline, info in (crn_lines.items() if isinstance(crn_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            if om is None or um is None or not (1.00 <= float(oround) <= 1.30): continue
            resCL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), crn_totals_list)
            if resCL["EV_over"] is not None and resCL["Kelly_over"] is not None:
                vi = value_index(resCL["EV_over"], resCL["Kelly_over"])
                crn_all_over.append((vi, home_name, away_name, line, float(om), resCL["EV_over"], resCL["Kelly_over"]))
            if resCL["EV_under"] is not None and resCL["Kelly_under"] is not None:
                vi = value_index(resCL["EV_under"], resCL["Kelly_under"])
                crn_all_under.append((vi, home_name, away_name, line, float(um), resCL["EV_under"], resCL["Kelly_under"]))

        # —— 全线榜单池（AH）
        for sline, info in (ah_lines.items() if isinstance(ah_lines, dict) else []):
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            oround = info.get("overround", 9.9)
            if oh is None or oa is None or not (1.00 <= float(oround) <= 1.25): continue
            probs = ah_probabilities_from_lams(lam_home, lam_away, h=float(line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs, odds_home=float(oh), odds_away=float(oa))
            if isinstance(evk.get("home"), dict) and evk["home"]["EV"] is not None and evk["home"]["Kelly"] is not None:
                vi = value_index(evk["home"]["EV"], evk["home"]["Kelly"])
                ah_all_home.append((vi, home_name, away_name, line, float(oh), evk["home"]["EV"], evk["home"]["Kelly"]))
            if isinstance(evk.get("away"), dict) and evk["away"]["EV"] is not None and evk["away"]["Kelly"] is not None:
                vi = value_index(evk["away"]["EV"], evk["away"]["Kelly"])
                ah_all_away.append((vi, home_name, away_name, line, float(oa), evk["away"]["EV"], evk["away"]["Kelly"]))

        # ===== 盘口矩阵（用 *_lines 导出） =====
        for sline, info in ou_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "OU", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })
        for sline, info in crn_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "CRN", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })
        for sline, info in ah_lines.items():
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            if oh is None or oa is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "AH", "line": float(line),
                "median_home": float(oh), "median_away": float(oa),
                "cnt_home": int(info.get("home_cnt", 0)), "cnt_away": int(info.get("away_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })

        # ===== 综合最佳 =====
        cands = []
        candidate_specs = [
            ("1X2-Home", "ev_1x2_home", ev1_h, k1_h),
            ("1X2-Draw", "ev_1x2_draw", ev1_d, k1_d),
            ("1X2-Away", "ev_1x2_away", ev1_a, k1_a),
            ("OU(main)-Over", "ev_ou_main_over", ev_main_over, k_main_over),
            ("OU(main)-Under", "ev_ou_main_under", ev_main_under, k_main_under),
            ("OU2.5-Over", "ev_ou_over2.5", ev25_over, k25_over),
            ("OU2.5-Under", "ev_ou_under2.5", ev25_under, k25_under),
            (f"AH({ah_line:+})-Home" if ah_line is not None else None, "ev_ah_home", ev_ah_h, k_ah_h),
            (f"AH({ah_line:+})-Away" if ah_line is not None else None, "ev_ah_away", ev_ah_a, k_ah_a),
            (f"CRN({crn_main_line})-Over" if crn_main_line is not None else None, "ev_crn_main_over", ev_crn_over, k_crn_over),
            (f"CRN({crn_main_line})-Under" if crn_main_line is not None else None, "ev_crn_main_under", ev_crn_under, k_crn_under),
        ]
        for label, key, ev, k in candidate_specs:
            if not label or ev is None or k is None:
                continue
            if flag_map.get(key) not in ("keep", "review"):
                continue
            cands.append((value_index(ev,k), label, ev, k))
        cands.sort(key=lambda x: x[0], reverse=True)
        best_label = cands[0][1] if cands else None
        best_ev    = cands[0][2] if cands else None
        best_kelly = cands[0][3] if cands else None

        # ===== 写行 =====
        weight_fields = {
            f"lam_weight_{name}": round(lam_weights.get(name, 0.0), 3)
            for name, data in lambda_models.items()
            if data.get("lam_home") is not None and data.get("lam_away") is not None
        }

        row = {
            "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
            "league_tier": league_tier,
            "home": home_name, "away": away_name,
            "lam_home": round(lam_home,3), "lam_away": round(lam_away,3),
            "p_home": round(sim["p_home"],4), "p_draw": round(sim["p_draw"],4), "p_away": round(sim["p_away"],4),
            "p_over2.5": round(sim["p_over"],4), "p_under2.5": round(sim["p_under"],4),

            # Goals OU 主盘（含诊断 + EV）
            "ou_main_line": ou_main_line,
            "odds_ou_main_over": ou_main_over, "odds_ou_main_under": ou_main_under,
            "ou_main_over_cnt": ou_cnt_o, "ou_main_under_cnt": ou_cnt_u, "ou_main_overround": ou_overround,
            "ev_ou_main_over": ev_main_over, "kelly_ou_main_over": k_main_over,
            "ev_ou_main_under": ev_main_under, "kelly_ou_main_under": k_main_under,

            # OU@2.5 参考
            "odds_ou_over2.5": odds.get("ou_over_2_5"), "odds_ou_under2.5": odds.get("ou_under_2_5"),
            "ev_ou_over2.5": ev25_over, "kelly_ou_over2.5": k25_over, "ev_ou_under2.5": ev25_under, "kelly_ou_under2.5": k25_under,

            # 1X2
            "odds_1x2_home": o1_h, "odds_1x2_draw": o1_d, "odds_1x2_away": o1_a,
            "1x2_home_cnt": cnt_1x2_h, "1x2_draw_cnt": cnt_1x2_d, "1x2_away_cnt": cnt_1x2_a,
            "1x2_overround": overround_1x2, "1x2_update_age_min": update_age_1x2,
            "ev_1x2_home": ev1_h, "kelly_1x2_home": k1_h,
            "ev_1x2_draw": ev1_d, "kelly_1x2_draw": k1_d,
            "ev_1x2_away": ev1_a, "kelly_1x2_away": k1_a,

            # AH（含诊断 + EV）
            "ah_line": ah_line, "odds_ah_home": ah_oh, "odds_ah_away": ah_oa,
            "ah_home_cnt": odds.get("ah_home_cnt"), "ah_away_cnt": odds.get("ah_away_cnt"),
            "ah_overround": odds.get("ah_overround"),
            "ev_ah_home": ev_ah_h, "kelly_ah_home": k_ah_h,
            "ev_ah_away": ev_ah_a, "kelly_ah_away": k_ah_a,

            # Corners OU 主盘（含诊断 + EV）
            "crn_main_line": crn_main_line,
            "odds_crn_main_over": crn_main_over, "odds_crn_main_under": crn_main_under,
            "crn_main_over_cnt": crn_cnt_o, "crn_main_under_cnt": crn_cnt_u, "crn_main_overround": crn_overround,
            "ev_crn_main_over": ev_crn_over, "kelly_crn_main_over": k_crn_over,
            "ev_crn_main_under": ev_crn_under, "kelly_crn_main_under": k_crn_under,

            "best_market": best_label, "best_ev": best_ev, "best_kelly": best_kelly,
            "value_index": value_index(best_ev, best_kelly) if (best_ev is not None and best_kelly is not None) else None
        }

        for key, tag in flag_map.items():
            row[f"flag_{key}"] = tag
        for key, reason in flag_reason_map.items():
            row[f"flag_reason_{key}"] = reason
        diagnostics_src = ev_meta_map.get("diagnostics")
        if isinstance(diagnostics_src, dict):
            diagnostics_items = diagnostics_src.items()
        else:
            diagnostics_items = ((k, v) for k, v in ev_meta_map.items() if k != "diagnostics")

        for key, meta in diagnostics_items:
            if not isinstance(meta, dict):
                continue
            quality_f: float | None = None
            ev_input_f: float | None = None
            ev_cal_f: float | None = None
            quality_val = meta.get("quality")
            if quality_val is not None:
                try:
                    quality_f = float(quality_val)
                    row[f"quality_{key}"] = round(quality_f, 4)
                except (TypeError, ValueError):
                    quality_f = None
            ev_input_val = meta.get("ev_input")
            if ev_input_val is not None:
                try:
                    ev_input_f = float(ev_input_val)
                    row[f"ev_input_{key}"] = round(ev_input_f, 6)
                except (TypeError, ValueError):
                    ev_input_f = None
            ev_cal_val = meta.get("ev_calibrated")
            if ev_cal_val is not None:
                try:
                    ev_cal_f = float(ev_cal_val)
                    row[f"ev_calibrated_{key}"] = round(ev_cal_f, 6)
                except (TypeError, ValueError):
                    ev_cal_f = None
            thresholds = meta.get("thresholds")
            if isinstance(thresholds, dict):
                keep_min_val = thresholds.get("keep_min")
                keep_max_val = thresholds.get("keep_max")
                drop_val = thresholds.get("drop")
                if keep_min_val is not None:
                    try:
                        row[f"threshold_keep_min_{key}"] = round(float(keep_min_val), 4)
                    except (TypeError, ValueError):
                        pass
                if keep_max_val is not None:
                    try:
                        row[f"threshold_keep_max_{key}"] = round(float(keep_max_val), 4)
                    except (TypeError, ValueError):
                        pass
                if drop_val is not None:
                    try:
                        row[f"threshold_drop_{key}"] = round(float(drop_val), 4)
                    except (TypeError, ValueError):
                        pass
            if quality_f is not None and ev_input_f is not None:
                row[f"score_{key}"] = round(quality_f * ev_input_f, 6)

        if lam_detail:
            row["lam_blend_detail"] = lam_detail
        for k, v in weight_fields.items():
            row[k] = v

        rows_all.append(row)

        done += 1
        if done % 30 == 0 or done == len(fixtures):
            print(f"……已处理 {done}/{len(fixtures)} 场")

    # ===== 导出全量 CSV =====
    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"daily_brief_{date_str}.csv")
    base_order = [
        "date_utc","kickoff_utc","league","home","away",
        "lam_home","lam_away","lam_weight_season","lam_weight_recent","lam_blend_detail",
        "p_home","p_draw","p_away","p_over2.5","p_under2.5",
        "ou_main_line","odds_ou_main_over","odds_ou_main_under",
        "ou_main_over_cnt","ou_main_under_cnt","ou_main_overround",
        "ev_ou_main_over","kelly_ou_main_over","ev_ou_main_under","kelly_ou_main_under",
        "odds_ou_over2.5","odds_ou_under2.5","ev_ou_over2.5","kelly_ou_over2.5","ev_ou_under2.5","kelly_ou_under2.5",
        "odds_1x2_home","odds_1x2_draw","odds_1x2_away","ev_1x2_home","kelly_1x2_home","ev_1x2_draw","kelly_1x2_draw","ev_1x2_away","kelly_1x2_away",
        "ah_line","odds_ah_home","odds_ah_away","ev_ah_home","kelly_ah_home","ev_ah_away","kelly_ah_away",
        "crn_main_line","odds_crn_main_over","odds_crn_main_under","crn_main_over_cnt","crn_main_under_cnt","crn_main_overround",
        "ev_crn_main_over","kelly_crn_main_over","ev_crn_main_under","kelly_crn_main_under",
        "best_market","best_ev","best_kelly","value_index"
    ]
    all_keys=set(); [all_keys.update(r.keys()) for r in rows_all]
    fieldnames = [c for c in base_order if c in all_keys] + [c for c in all_keys if c not in base_order]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
        w.writeheader(); [w.writerow(r) for r in rows_all]
    print(f"\n已导出全量数据到: {out_file}")

    # ===== 导出盘口矩阵（来自 *_lines） =====
    out_mat = os.path.join(out_dir, f"daily_brief_matrix_{date_str}.csv")
    if matrix_rows:
        mat_fields = [
            "date_utc","kickoff_utc","league","home","away","market","line",
            "median_over","median_under","median_home","median_away",
            "cnt_over","cnt_under","cnt_home","cnt_away","overround"
        ]
        with open(out_mat, "w", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=mat_fields, extrasaction="ignore")
            w.writeheader(); [w.writerow(r) for r in matrix_rows]
        print(f"已导出盘口矩阵到: {out_mat}")
    else:
        print("未获取到盘口矩阵（ou_lines/crn_lines/ah_lines），跳过导出。")

    # ===== 榜单打印 =====
    def top_list(rows: List[Dict], key_ev: str, key_k: str, label: str, suffix_fn=None):
        items = []
        for r in rows:
            ev,k = r.get(key_ev), r.get(key_k)
            if ev is None or k is None or ev < MIN_EV: continue
            flag = r.get(f"flag_{key_ev}")
            if flag not in ("keep", "review"): continue
            items.append((value_index(ev,k), r, ev, k, flag))
        items.sort(key=lambda x: x[0], reverse=True)
        print(f"\n=== Top {min(TOP_K, len(items))}（{label}，EV≥{MIN_EV:.2f}） ===")
        for i,(_,r,ev,k,flag) in enumerate(items[:TOP_K], 1):
            extra = suffix_fn(r) if suffix_fn else ""
            tag = " [Review]" if flag == "review" else ""
            print(f"[{i:02d}] {r['home']} vs {r['away']} | EV={ev:.3f} Kelly≈{k:.3f} | {label}{(' ' + extra) if extra else ''}{tag}")

    # Suffix 生成（去掉多余空格）
    suf_ou_over  = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False)
    suf_ou_under = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False)
    suf_1x2_home = lambda r: f"@{float(r['odds_1x2_home']):.2f}" if r.get("odds_1x2_home") else ""
    suf_1x2_draw = lambda r: f"@{float(r['odds_1x2_draw']):.2f}" if r.get("odds_1x2_draw") else ""
    suf_1x2_away = lambda r: f"@{float(r['odds_1x2_away']):.2f}" if r.get("odds_1x2_away") else ""
    suf_ah_home  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_home"), "home")
    suf_ah_away  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_away"), "away")
    suf_cr_over  = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True)
    suf_cr_under = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True)

    top_list(rows_all, "ev_ou_main_over",  "kelly_ou_main_over",  "OU主盘-Over",  suf_ou_over)
    top_list(rows_all, "ev_ou_main_under", "kelly_ou_main_under", "OU主盘-Under", suf_ou_under)
    top_list(rows_all, "ev_1x2_home", "kelly_1x2_home", "1X2-主胜", suf_1x2_home)
    top_list(rows_all, "ev_1x2_draw", "kelly_1x2_draw", "1X2-平局", suf_1x2_draw)
    top_list(rows_all, "ev_1x2_away", "kelly_1x2_away", "1X2-客胜", suf_1x2_away)
    top_list(rows_all, "ev_ah_home", "kelly_ah_home", "AH-主方向", suf_ah_home)
    top_list(rows_all, "ev_ah_away", "kelly_ah_away", "AH-客方向", suf_ah_away)
    top_list(rows_all, "ev_crn_main_over",  "kelly_crn_main_over",  "角球主盘-Over",  suf_cr_over)
    top_list(rows_all, "ev_crn_main_under", "kelly_crn_main_under", "角球主盘-Under", suf_cr_under)

    # ===== 全线 Top（按 VI 排序）=====
    def print_ou_crn_allline_top(title: str, arr: List[tuple], tag="OU"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [(vi,h,a,line,od,ev,k) for (vi,h,a,line,od,ev,k) in arr if ev is not None and k is not None and ev >= MIN_EV]
        arr2.sort(key=lambda x: x[0], reverse=True)
        for i,(vi,h,a,line,od,ev,k) in enumerate(arr2[:TOP_K],1):
            print(f"[{i:02d}] {h} vs {a} | 线={line:g} | EV={ev:.3f} Kelly≈{k:.3f} | {title} {tag}{line:g}@{od:.2f}")

    def print_ah_allline_top(title: str, arr: List[tuple], side="home"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [(vi,h,a,line,od,ev,k) for (vi,h,a,line,od,ev,k) in arr if ev is not None and k is not None and ev >= MIN_EV]
        arr2.sort(key=lambda x: x[0], reverse=True)
        for i,(vi,h,a,line,od,ev,k) in enumerate(arr2[:TOP_K],1):
            adj = line if side=="home" else -line
            sign = "+" if adj>0 else ""
            print(f"[{i:02d}] {h} vs {a} | 线={adj:g} | EV={ev:.3f} Kelly≈{k:.3f} | {title} AH{sign}{adj:g}@{od:.2f}")

    if ou_all_over:  print_ou_crn_allline_top("进球OU-Over（全线）",  ou_all_over,  "OU")
    if ou_all_under: print_ou_crn_allline_top("进球OU-Under（全线）", ou_all_under, "OU")
    if crn_all_over: print_ou_crn_allline_top("角球OU-Over（全线）",  crn_all_over,  "CRN")
    if crn_all_under:print_ou_crn_allline_top("角球OU-Under（全线）", crn_all_under, "CRN")
    if ah_all_home: print_ah_allline_top("AH-主方向（全线）", ah_all_home, side="home")
    if ah_all_away: print_ah_allline_top("AH-客方向（全线）", ah_all_away, side="away")

    # AH 诊断
    print(f"\n[AH诊断] 有主盘线的比赛: {cnt_ah_has_line} 场；出现正EV(主): {cnt_ah_ev_home} 场；正EV(客): {cnt_ah_ev_away} 场")

    # 导出 picks.csv
    if EXPORT_PICKS:
        export_picks(rows_all, date_str)

if __name__ == "__main__":
    try:
        if os.environ.get("DAILY_BRIEF_SELFTEST") == "1":
            _regression_check_quarter_under()
        main()
    except Exception as e:
        print("程序异常：", e)
        traceback.print_exc()
