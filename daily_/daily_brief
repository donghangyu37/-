# === daily_brief.py · 每日情报站（并发/快速版 + 主盘OU/AH + 角球OU + 全线榜单 + 盘口矩阵 + picks.csv）===
from __future__ import annotations
from datetime import datetime, timezone
from typing import Dict, List, Tuple, Optional, Set
import math, os, csv, traceback, random

from concurrent.futures import ThreadPoolExecutor, as_completed
import numpy as np

# —— 项目内模块
from src.api.football_api import fixtures_by_date, team_statistics, odds_by_fixture, recent_fixtures_by_team
from src.data.transform import league_goal_averages
from src.models.poisson_mc import expected_goals_from_strengths, monte_carlo_simulate, simulate_goals
from src.markets.asian_handicap import ah_probabilities_from_lams, ah_ev_kelly
from src.config import HOME_ADV

# ================== 可调参数 ==================
FAST_MODE = 1
N_SIMS_GOALS   = 12000 if FAST_MODE else 25000
N_SIMS_CORNERS = 12000 if FAST_MODE else 25000
USE_RECENT = 0 if FAST_MODE else 1

CONCURRENCY = 6

# 主盘诊断阈值
STRICT_OU_MAIN  = 1; OU_MIN_CNT  = 3; OU_MAX_OR  = 1.12
STRICT_CRN_MAIN = 1; CRN_MIN_CNT = 3; CRN_MAX_OR = 1.20

# —— 新增：AH 主盘诊断阈值（与 OU/CRN 一致思路）
STRICT_AH_MAIN = 1     # 开启严格筛选：样本数与超盘限制
AH_MIN_CNT     = 3     # home/away 各至少多少条报价
AH_MAX_OR      = 1.20  # 超盘上限（1/oh + 1/oa）

# 异常 EV 拦截
def is_ev_outlier(ev: float) -> bool: return ev > 0.35

# 噪声赛事过滤
EXCLUDE_NOISY = 0
EXCLUDE_KEYS = ["u21","u23","res.","reserve","friendly","club friendlies"]

TOP_K  = 10
MIN_EV = 0.00

# 角球 λ 兜底
CORNER_BASE = 7.5
CORNER_PER_GOAL = 0.9

def _env_float(name: str, default: float) -> float:
    try:
        raw = os.getenv(name)
        if raw is None or raw == "":
            return float(default)
        return float(raw)
    except Exception:
        return float(default)

def _env_int(name: str, default: int) -> int:
    try:
        raw = os.getenv(name)
        if raw is None or raw == "":
            return int(default)
        return int(float(raw))
    except Exception:
        return int(default)

LAMBDA_MODEL_CONFIG = {
    "season": {
        "weight": _env_float("LAM_WEIGHT_SEASON", 0.6),
    },
    "recent": {
        "weight": _env_float("LAM_WEIGHT_RECENT", 0.4 if USE_RECENT else 0.0),
        "recent_games": _env_int("LAM_RECENT_GAMES", 6),
        "min_games": _env_int("LAM_RECENT_MIN_GAMES", 3),
        "decay": _env_float("LAM_RECENT_DECAY", 0.85),
        "fetch_last": _env_int("LAM_RECENT_FETCH_LAST", 12),
        "season_mix": _env_float("LAM_RECENT_SEASON_MIX", 0.3),
    },
}

if LAMBDA_MODEL_CONFIG["recent"]["min_games"] > LAMBDA_MODEL_CONFIG["recent"]["recent_games"]:
    LAMBDA_MODEL_CONFIG["recent"]["min_games"] = LAMBDA_MODEL_CONFIG["recent"]["recent_games"]

if LAMBDA_MODEL_CONFIG["recent"]["fetch_last"] < LAMBDA_MODEL_CONFIG["recent"]["recent_games"]:
    LAMBDA_MODEL_CONFIG["recent"]["fetch_last"] = LAMBDA_MODEL_CONFIG["recent"]["recent_games"]

LOG_LAMBDA_BLEND = _env_int("LAM_LOG_BLEND", 1)

# ===== Picks 导出配置 =====
EXPORT_PICKS = 1
PICKS_TOP_N = 100
PICKS_MIN_EV = 0.05
PICKS_MIN_KELLY = 0.05
PICKS_MIN_VI = 0.00
KELLY_FRACTION = 0.25
STAKE_CAP_PCT = 2.0
STAKE_MIN_PCT = 0.0

# ===== λ 安全带 & 市场融合参数 =====
LAM_MIN_PER_TEAM = _env_float("LAM_MIN_PER_TEAM", 0.2)
LAM_MAX_PER_TEAM = _env_float("LAM_MAX_PER_TEAM", 3.0)
LAM_MIN_TOTAL    = _env_float("LAM_MIN_TOTAL", 1.6)
LAM_MAX_TOTAL    = _env_float("LAM_MAX_TOTAL", 5.4)
LAM_MARKET_BLEND_MIN_ALPHA = _env_float("LAM_MARKET_BLEND_MIN_ALPHA", 0.35)
LAM_MARKET_BLEND_MAX_ALPHA = _env_float("LAM_MARKET_BLEND_MAX_ALPHA", 0.85)
LAM_MARKET_DELTA_CAP       = _env_float("LAM_MARKET_DELTA_CAP", 1.8)

# ===== 盘口质量过滤参数 =====
ALLLINE_MAX_GAP = _env_float("ALLLINE_MAX_GAP", 3.0)
CRN_LOW_LINE_SANITY = _env_float("CRN_LOW_LINE_SANITY", 4.5)
CRN_LOW_LINE_OVER_FLOOR = _env_float("CRN_LOW_LINE_OVER_FLOOR", 0.55)

# ================== 工具函数 ==================
def _today_utc_date() -> str:
    return datetime.now(timezone.utc).date().isoformat()

def sanitize_ou_pair(o_over: float | None, o_under: float | None) -> Tuple[float, float] | None:
    if o_over is None or o_under is None: return None
    try: oo, uu = float(o_over), float(o_under)
    except: return None
    if not (1.10 <= oo <= 50.0 and 1.10 <= uu <= 50.0): return None
    imp = 1/oo + 1/uu
    if not (1.00 <= imp <= 1.25): return None
    return oo, uu

def sanitize_1x2(o_h: float | None, o_d: float | None, o_a: float | None):
    try:
        if None in (o_h, o_d, o_a): return None
        oh, od, oa = float(o_h), float(o_d), float(o_a)
    except: return None
    if not all(1.10 <= v <= 100.0 for v in (oh, od, oa)): return None
    imp = 1/oh + 1/od + 1/oa
    if not (1.00 <= imp <= 1.30): return None
    return oh, od, oa

def ev_kelly_binary(p: float, odds: float) -> Tuple[float, float]:
    b = odds - 1.0
    EV = p*b - (1-p)
    K  = 0.0 if b<=0 else max(0.0, (b*p - (1-p))/b)
    return float(EV), float(K)

def value_index(ev: float | None, kelly: float | None) -> float:
    if ev is None or kelly is None: return -999.0
    return float(ev * math.sqrt(max(0.0, kelly)))


def _clamp_lambdas(lam_home: float, lam_away: float) -> tuple[float, float]:
    """Apply soft bounds to individual and total λ values."""
    lam_home = float(max(LAM_MIN_PER_TEAM, min(LAM_MAX_PER_TEAM, lam_home)))
    lam_away = float(max(LAM_MIN_PER_TEAM, min(LAM_MAX_PER_TEAM, lam_away)))
    total = lam_home + lam_away
    if total <= 0:
        lam_home = lam_away = LAM_MIN_TOTAL / 2.0
        total = lam_home + lam_away
    ratio_home = lam_home / total if total > 0 else 0.5
    total_clamped = float(max(LAM_MIN_TOTAL, min(LAM_MAX_TOTAL, total)))
    lam_home = ratio_home * total_clamped
    lam_away = total_clamped - lam_home
    lam_home = float(max(LAM_MIN_PER_TEAM, min(LAM_MAX_PER_TEAM, lam_home)))
    lam_away = float(max(LAM_MIN_PER_TEAM, min(LAM_MAX_PER_TEAM, lam_away)))
    total = lam_home + lam_away
    if total < LAM_MIN_TOTAL:
        deficit = LAM_MIN_TOTAL - total
        lam_home = float(min(LAM_MAX_PER_TEAM, lam_home + deficit * ratio_home))
        lam_away = float(min(LAM_MAX_PER_TEAM, lam_away + deficit * (1.0 - ratio_home)))
    total = lam_home + lam_away
    if total > LAM_MAX_TOTAL and total > 0:
        scale = LAM_MAX_TOTAL / total
        lam_home = float(max(LAM_MIN_PER_TEAM, min(LAM_MAX_PER_TEAM, lam_home * scale)))
        lam_away = float(max(LAM_MIN_PER_TEAM, min(LAM_MAX_PER_TEAM, lam_away * scale)))
    return float(lam_home), float(lam_away)


def _lambda_model_quality(name: str, data: dict, config: Dict[str, dict]) -> float:
    meta = (data or {}).get("meta") or {}
    if name == "recent":
        cfg = config.get("recent") or {}
        target = max(1, int(cfg.get("recent_games", 6))) * 2
        used = float(meta.get("home_games_used", 0) or 0) + float(meta.get("away_games_used", 0) or 0)
        if target <= 0:
            target = 6.0
        coverage = max(0.0, min(1.0, used / float(target)))
        return 0.2 + 0.8 * coverage
    return 1.0


def lambda_coverage_score(models: Dict[str, dict], weights: Dict[str, float], config: Dict[str, dict]) -> float:
    if not weights:
        return 0.0
    score = 0.0
    total_weight = 0.0
    for name, data in models.items():
        weight = float(weights.get(name, 0.0))
        if weight <= 0:
            continue
        score += weight * _lambda_model_quality(name, data, config)
        total_weight += weight
    if total_weight <= 0:
        return 0.0
    return max(0.0, min(1.0, score / total_weight))


def _implied_prob_over(odds_over: float, odds_under: float) -> Optional[float]:
    try:
        inv_over = 1.0 / float(odds_over)
        inv_under = 1.0 / float(odds_under)
        total = inv_over + inv_under
        if total <= 0:
            return None
        return float(inv_over / total)
    except Exception:
        return None


def _poisson_tail_ge(k: int, lam: float) -> float:
    if k <= 0:
        return 1.0
    pmf = math.exp(-lam)
    s = pmf
    for n in range(1, k):
        pmf *= lam / n
        s += pmf
    return max(0.0, 1.0 - s)


def _poisson_cum_le(k: int, lam: float) -> float:
    if k < 0:
        return 0.0
    pmf = math.exp(-lam)
    s = pmf
    for n in range(1, k + 1):
        pmf *= lam / n
        s += pmf
    return min(1.0, s)


def _poisson_over_under_prob(line: float, lam_total: float) -> tuple[float, float]:
    base = math.floor(float(line) + 1e-9)
    frac = round(float(line) - base, 2)
    if frac == 0.0:
        return _poisson_tail_ge(base + 1, lam_total), _poisson_cum_le(base - 1, lam_total)
    if frac == 0.5:
        return _poisson_tail_ge(base + 1, lam_total), _poisson_cum_le(base, lam_total)
    if frac == 0.25:
        over = 0.5 * _poisson_tail_ge(base + 1, lam_total) + 0.5 * _poisson_tail_ge(base + 1, lam_total)
        under = 0.5 * _poisson_cum_le(base - 1, lam_total) + 0.5 * _poisson_cum_le(base, lam_total)
        return over, under
    if frac == 0.75:
        over = 0.5 * _poisson_tail_ge(base + 1, lam_total) + 0.5 * _poisson_tail_ge(base + 2, lam_total)
        under = 0.5 * _poisson_cum_le(base, lam_total) + 0.5 * _poisson_cum_le(base + 1, lam_total)
        return over, under
    nearest_half = base + (0.5 if frac < 0.5 else 1.5)
    return _poisson_over_under_prob(nearest_half, lam_total)


def _solve_total_lambda(line: float, target_prob: float, initial_total: float) -> Optional[float]:
    if line is None or target_prob is None:
        return None
    try:
        line_f = float(line)
    except Exception:
        return None
    target = float(target_prob)
    if not (0.01 <= target <= 0.99):
        return None
    low, high = 0.2, 8.0
    for _ in range(40):
        mid = 0.5 * (low + high)
        p_over, _ = _poisson_over_under_prob(line_f, mid)
        if p_over is None:
            break
        if p_over > target:
            high = mid
        else:
            low = mid
    cand = 0.5 * (low + high)
    if not math.isfinite(cand):
        return None
    # Limit runaway solutions relative to the initial guess
    if initial_total is not None:
        delta_cap = max(0.5, LAM_MARKET_DELTA_CAP)
        diff = cand - float(initial_total)
        if abs(diff) > delta_cap:
            cand = float(initial_total) + math.copysign(delta_cap, diff)
    return float(max(LAM_MIN_TOTAL / 2.0, min(LAM_MAX_TOTAL * 1.1, cand)))


def adjust_lambdas_with_guards(
    lam_home: float,
    lam_away: float,
    odds: dict,
    coverage: float,
    notes: Optional[List[str]] = None,
) -> tuple[float, float, Optional[float], List[str]]:
    notes_list: List[str] = [] if notes is None else notes
    base_home, base_away = lam_home, lam_away
    lam_home, lam_away = _clamp_lambdas(lam_home, lam_away)
    if abs(lam_home - base_home) > 1e-6 or abs(lam_away - base_away) > 1e-6:
        notes_list.append(
            f"clamp:{base_home:.2f}/{base_away:.2f}->{lam_home:.2f}/{lam_away:.2f}"
        )
    market_total = None
    ou_line = (odds or {}).get("ou_main_line")
    ou_over = (odds or {}).get("ou_main_over")
    ou_under = (odds or {}).get("ou_main_under")
    overround = (odds or {}).get("ou_main_overround")
    pair = sanitize_ou_pair(ou_over, ou_under)
    if pair and ou_line is not None:
        oo, uu = pair
        if overround is None or float(overround) <= 1.22:
            p_market = _implied_prob_over(oo, uu)
            if p_market is not None:
                model_total = lam_home + lam_away
                market_total = _solve_total_lambda(float(ou_line), p_market, model_total)
                if market_total is not None:
                    coverage = max(0.0, min(1.0, float(coverage)))
                    alpha = LAM_MARKET_BLEND_MIN_ALPHA + (
                        (LAM_MARKET_BLEND_MAX_ALPHA - LAM_MARKET_BLEND_MIN_ALPHA) * coverage
                    )
                    alpha = max(0.0, min(1.0, alpha))
                    blended_total = alpha * model_total + (1.0 - alpha) * market_total
                    if model_total > 0:
                        ratio = lam_home / model_total
                    else:
                        ratio = 0.5
                    lam_home = ratio * blended_total
                    lam_away = blended_total - lam_home
                    notes_list.append(
                        f"market_blend:{model_total:.2f}->{blended_total:.2f}(α={alpha:.2f})"
                    )
    lam_home, lam_away = _clamp_lambdas(lam_home, lam_away)
    return float(lam_home), float(lam_away), market_total, notes_list


def blend_probabilities_with_market(
    model_probs: Dict[str, float], market_probs: Dict[str, float], alpha: float
) -> Dict[str, float]:
    keys = ["p_home", "p_draw", "p_away"]
    out = {}
    alpha = max(0.0, min(1.0, float(alpha)))
    for k in keys:
        out[k] = alpha * float(model_probs.get(k, 0.0)) + (1.0 - alpha) * float(market_probs.get(k, 0.0))
    total = sum(out.values())
    if total <= 0:
        return {k: (1.0 / 3.0) for k in keys}
    return {k: out[k] / total for k in keys}


def apply_draw_inflation(probs: Dict[str, float], boost: float) -> Dict[str, float]:
    boost = max(0.0, float(boost))
    p_draw = float(probs.get("p_draw", 0.0))
    p_home = float(probs.get("p_home", 0.0))
    p_away = float(probs.get("p_away", 0.0))
    if p_draw <= 0 or (p_home + p_away) <= 0:
        return {"p_home": p_home, "p_draw": p_draw, "p_away": p_away}
    new_draw = min(0.62, p_draw * (1.0 + boost))
    scale = (1.0 - new_draw) / max(1e-9, (1.0 - p_draw))
    p_home *= scale
    p_away *= scale
    total = p_home + new_draw + p_away
    if total <= 0:
        return {"p_home": 0.34, "p_draw": 0.32, "p_away": 0.34}
    return {
        "p_home": p_home / total,
        "p_draw": new_draw / total,
        "p_away": p_away / total,
    }


def _assess_ou_main(cnt_over: int, cnt_under: int, overround: Optional[float], strict: int) -> tuple[bool, str, Optional[float]]:
    if not strict:
        return True, "ok", None
    cnt_over = int(cnt_over or 0)
    cnt_under = int(cnt_under or 0)
    min_cnt = min(cnt_over, cnt_under)
    if min_cnt < 2:
        return False, "cnt_low", None
    if min_cnt >= 4:
        max_or = 1.12
    elif min_cnt >= 3:
        max_or = 1.15
    else:
        max_or = 1.18
    if overround is not None and overround > max_or:
        return False, "overround_high", max_or
    return True, "ok", max_or


def _adjust_corner_line_for_sanity(line: float, over: float, under: float) -> tuple[Optional[float], Optional[float], bool]:
    try:
        line_f = float(line)
        over_f = float(over)
        under_f = float(under)
    except (TypeError, ValueError):
        return None, None, False
    direction_ok = True
    if line_f <= CRN_LOW_LINE_SANITY and over_f > 1.0 and under_f > 1.0:
        inv_over = 1.0 / over_f
        inv_under = 1.0 / under_f
        total = inv_over + inv_under
        if total > 0:
            prob_over = inv_over / total
            prob_under = inv_under / total
            if prob_over < CRN_LOW_LINE_OVER_FLOOR and prob_under > CRN_LOW_LINE_OVER_FLOOR:
                over_f, under_f = under_f, over_f
                prob_over, prob_under = prob_under, prob_over
            direction_ok = prob_over >= CRN_LOW_LINE_OVER_FLOOR
    return over_f, under_f, direction_ok

# ===== 四分之一盘精结算（基于 totals 样本）=====
def ou_ev_kelly_from_totals_quarter(line: float, over_odds: float, under_odds: float, totals) -> dict:
    if totals is None:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}
    try:
        totals_list = list(totals)
    except TypeError:
        totals_list = [totals]
    if len(totals_list) == 0:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}

    a = int(line // 1)
    frac = round(line - a, 2)
    n = len(totals_list)

    def counts_over(a, frac):
        if frac == 0.0:
            fw = sum(t > a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t > a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t >= a + 1 for t in totals_list) / n
            hl = sum(t == a for t in totals_list) / n
            fl = sum(t <= a - 1 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, 0.0, hl, fl + max(0.0, remain)
        elif frac == 0.75:
            fw = sum(t >= a + 2 for t in totals_list) / n
            hw = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t <= a for t in totals_list) / n
            remain = 1.0 - fw - hw - fl
            return fw, hw, remain, 0.0, fl
        else:
            fw = sum(t > line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    def counts_under(a, frac):
        if frac == 0.0:
            fw = sum(t < a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t < a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t < a for t in totals_list) / n
            hw = sum(t == a for t in totals_list) / n
            fl = sum(t >= a + 1 for t in totals_list) / n
            remain = max(0.0, 1.0 - fw - hw - fl)
            return fw, hw, remain, 0.0, fl
        elif frac == 0.75:
            fw = sum(t <= a for t in totals_list) / n
            hl = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t >= a + 2 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, remain, hl, fl
        else:
            fw = sum(t < line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    fw_o, hw_o, pu_o, hl_o, fl_o = counts_over(a, frac)
    fw_u, hw_u, pu_u, hl_u, fl_u = counts_under(a, frac)

    b_over  = max(0.0, over_odds - 1.0)
    b_under = max(0.0, under_odds - 1.0)

    EV_over  = fw_o*b_over + hw_o*(0.5*b_over) - hl_o*0.5 - fl_o*1.0
    EV_under = fw_u*b_under + hw_u*(0.5*b_under) - hl_u*0.5 - fl_u*1.0

    pwin_o, plose_o = fw_o + 0.5*hw_o, fl_o + 0.5*hl_o
    pwin_u, plose_u = fw_u + 0.5*hw_u, fl_u + 0.5*hl_u

    K_over  = 0.0 if b_over  <= 0 else max(0.0, (b_over*pwin_o  - plose_o)/b_over)
    K_under = 0.0 if b_under <= 0 else max(0.0, (b_under*pwin_u - plose_u)/b_under)

    return {"EV_over": float(EV_over), "Kelly_over": float(K_over),
            "EV_under": float(EV_under), "Kelly_under": float(K_under)}

def _regression_check_quarter_under() -> None:
    """Verify under-quarter lines treat integer totals as half wins."""
    totals = [1, 2, 3, 4]
    res = ou_ev_kelly_from_totals_quarter(2.25, 2.0, 2.0, totals)
    expected_ev_under = -0.125
    if not math.isclose(res["EV_under"], expected_ev_under, rel_tol=1e-12, abs_tol=1e-12):
        raise AssertionError(
            f"Quarter-line under regression failed: expected EV_under {expected_ev_under}, got {res['EV_under']}"
        )

# ================== 预取与缓存 ==================
TEAM_STATS_CACHE: dict[tuple[int,int,int], dict] = {}

def prefetch_team_stats(fixtures: List[Dict]):
    tasks: Set[tuple[int,int,int]] = set()
    for fx in fixtures:
        try:
            lg = fx["league"]["id"]; ss = fx["league"]["season"]
            hid = fx["teams"]["home"]["id"]; aid = fx["teams"]["away"]["id"]
            tasks.add((lg, ss, hid)); tasks.add((lg, ss, aid))
        except: pass

    def _job(key):
        if key in TEAM_STATS_CACHE: return key, TEAM_STATS_CACHE[key]
        lg, ss, tid = key
        try:
            st = team_statistics(lg, ss, tid)
            TEAM_STATS_CACHE[key] = st or {}
            return key, TEAM_STATS_CACHE[key]
        except Exception:
            return key, {}

    if not tasks: return
    with ThreadPoolExecutor(max_workers=CONCURRENCY) as ex:
        futures = {ex.submit(_job, k): k for k in tasks}
        done = 0
        for _ in as_completed(futures):
            done += 1
            if done % 20 == 0 or done == len(tasks):
                print(f"……已预取球队统计 {done}/{len(tasks)}")

def compute_league_avg_from_cache(league_id: int, season: int) -> float:
    stats_list = []
    for (lg, ss, _tid), st in TEAM_STATS_CACHE.items():
        if lg == league_id and ss == season and st:
            stats_list.append(st)
    if not stats_list:
        return 2.6
    league_avg, _ = league_goal_averages(stats_list)
    return float(league_avg or 2.6)

def estimate_corners_lambda_total(h_stats: dict, a_stats: dict, lam_home: float, lam_away: float) -> float:
    def _safe(path, d):
        cur = d
        for k in path:
            if not isinstance(cur, dict): return None
            cur = cur.get(k)
            if cur is None: return None
        try: return float(cur)
        except: return None
    h_c_home = _safe(["corners","for","average","home"], h_stats)
    a_c_away = _safe(["corners","for","average","away"], a_stats)
    if h_c_home and a_c_away and h_c_home > 0 and a_c_away > 0:
        return float(h_c_home + a_c_away)
    return float(CORNER_BASE + CORNER_PER_GOAL * (lam_home + lam_away))

# ================== λ 多模型融合 ==================
RECENT_FORM_CACHE: dict[tuple[int, int, int, int], List[Dict]] = {}

def _safe_stat(path: List[str], data: dict, default: float) -> float:
    cur = data or {}
    for key in path:
        if not isinstance(cur, dict):
            return float(default)
        cur = cur.get(key)
        if cur is None:
            return float(default)
    try:
        return float(cur)
    except Exception:
        return float(default)

def _fixture_timestamp(fixture: Dict) -> float:
    info = (fixture or {}).get("fixture") or {}
    ts = info.get("timestamp")
    if isinstance(ts, (int, float)):
        return float(ts)
    date_str = info.get("date")
    if isinstance(date_str, str):
        try:
            if date_str.endswith("Z"):
                date_str = date_str[:-1] + "+00:00"
            return datetime.fromisoformat(date_str).timestamp()
        except Exception:
            pass
    return 0.0

def _recent_weighted_avg(fixtures: List[Dict], team_id: int, want_home: bool, max_games: int, decay: float) -> tuple[Optional[float], Optional[float], int]:
    if max_games <= 0:
        return None, None, 0
    entries: List[tuple[float, float, float]] = []
    for fx in fixtures or []:
        teams = fx.get("teams") or {}
        home = (teams.get("home") or {}).get("id")
        away = (teams.get("away") or {}).get("id")
        if want_home:
            if home != team_id:
                continue
            g_for = (fx.get("goals") or {}).get("home")
            g_against = (fx.get("goals") or {}).get("away")
        else:
            if away != team_id:
                continue
            g_for = (fx.get("goals") or {}).get("away")
            g_against = (fx.get("goals") or {}).get("home")
        if g_for is None or g_against is None:
            score_ft = ((fx.get("score") or {}).get("fulltime") or {})
            if g_for is None:
                g_for = score_ft.get("home" if want_home else "away")
            if g_against is None:
                g_against = score_ft.get("away" if want_home else "home")
        try:
            gf_val = float(g_for)
            ga_val = float(g_against)
        except (TypeError, ValueError):
            continue
        entries.append((_fixture_timestamp(fx), gf_val, ga_val))

    if not entries:
        return None, None, 0

    entries.sort(key=lambda x: x[0], reverse=True)
    try:
        decay_val = float(decay)
    except Exception:
        decay_val = 0.85
    if decay_val <= 0:
        decay_val = 0.85
    if decay_val > 1:
        decay_val = 1.0

    weight_sum = 0.0
    gf_sum = 0.0
    ga_sum = 0.0
    used = 0
    for _, gf_val, ga_val in entries:
        weight = decay_val ** used
        gf_sum += weight * gf_val
        ga_sum += weight * ga_val
        weight_sum += weight
        used += 1
        if used >= max_games:
            break

    if weight_sum <= 0:
        return None, None, used

    return gf_sum / weight_sum, ga_sum / weight_sum, used

def fetch_recent_form(team_id: int, league_id: int, season: int, fetch_last: int) -> List[Dict]:
    key = (league_id, season, team_id, fetch_last)
    if key in RECENT_FORM_CACHE:
        return RECENT_FORM_CACHE[key]
    try:
        fixtures = recent_fixtures_by_team(team_id=team_id, season=season, last=fetch_last, league_id=league_id)
    except Exception as e:
        fixtures = []
        if LOG_LAMBDA_BLEND:
            print(f"[λ模型] 获取近况赛程失败 team={team_id}: {e}")
    RECENT_FORM_CACHE[key] = fixtures or []
    return RECENT_FORM_CACHE[key]

def _blend_recent_value(recent_val: Optional[float], fallback_val: float, mix: float) -> float:
    if fallback_val is None and recent_val is None:
        return 0.0
    if recent_val is None:
        return float(fallback_val)
    if fallback_val is None:
        return float(recent_val)
    mix_clamped = max(0.0, min(1.0, float(mix)))
    return float(mix_clamped * float(fallback_val) + (1.0 - mix_clamped) * float(recent_val))

def lambda_from_season_stats(h_stats: dict, a_stats: dict, league_avg: float, home_adv: float) -> tuple[tuple[float, float], dict]:
    denom = max(float(league_avg or 0.0), 1e-6)
    h_gf_home = _safe_stat(["goals","for","average","home"], h_stats, 1.3)
    h_ga_home = _safe_stat(["goals","against","average","home"], h_stats, 1.3)
    a_gf_away = _safe_stat(["goals","for","average","away"], a_stats, 1.3)
    a_ga_away = _safe_stat(["goals","against","average","away"], a_stats, 1.3)

    h_att = max(0.05, h_gf_home) / denom
    h_def = max(0.05, h_ga_home) / denom
    a_att = max(0.05, a_gf_away) / denom
    a_def = max(0.05, a_ga_away) / denom

    lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, home_adv)
    meta = {
        "h_att": float(h_att),
        "h_def": float(h_def),
        "a_att": float(a_att),
        "a_def": float(a_def),
        "h_for_avg": float(h_gf_home),
        "h_against_avg": float(h_ga_home),
        "a_for_avg": float(a_gf_away),
        "a_against_avg": float(a_ga_away),
    }
    return (float(lam_home), float(lam_away)), meta

def lambda_from_recent_form(
    home_id: int,
    away_id: int,
    league_id: int,
    season: int,
    league_avg: float,
    home_adv: float,
    season_meta: dict,
    config: dict,
) -> tuple[tuple[float, float], dict]:
    recent_games = max(1, int(config.get("recent_games", 6)))
    min_games = max(1, int(config.get("min_games", 3)))
    if min_games > recent_games:
        min_games = recent_games
    try:
        decay = float(config.get("decay", 0.85))
    except Exception:
        decay = 0.85
    fetch_last = int(config.get("fetch_last", recent_games))
    fetch_last = max(fetch_last, recent_games * 2)

    home_fixtures = fetch_recent_form(home_id, league_id, season, fetch_last)
    away_fixtures = fetch_recent_form(away_id, league_id, season, fetch_last)

    h_recent_for, h_recent_against, cnt_home = _recent_weighted_avg(home_fixtures, home_id, True, recent_games, decay)
    a_recent_for, a_recent_against, cnt_away = _recent_weighted_avg(away_fixtures, away_id, False, recent_games, decay)

    coverage_home = min(1.0, cnt_home / recent_games) if recent_games else 0.0
    coverage_away = min(1.0, cnt_away / recent_games) if recent_games else 0.0

    try:
        base_mix = float(config.get("season_mix", 0.3))
    except Exception:
        base_mix = 0.3
    base_mix = max(0.0, min(1.0, base_mix))

    def _effective_mix(base: float, coverage: float, enough_games: bool) -> float:
        if not enough_games:
            return 1.0
        return base + (1.0 - coverage) * (1.0 - base)

    eff_mix_home = _effective_mix(base_mix, coverage_home, cnt_home >= min_games)
    eff_mix_away = _effective_mix(base_mix, coverage_away, cnt_away >= min_games)

    fallback_h_for = max(0.05, float(season_meta.get("h_for_avg", league_avg)))
    fallback_h_against = max(0.05, float(season_meta.get("h_against_avg", league_avg)))
    fallback_a_for = max(0.05, float(season_meta.get("a_for_avg", league_avg)))
    fallback_a_against = max(0.05, float(season_meta.get("a_against_avg", league_avg)))

    h_for_blend = max(0.05, _blend_recent_value(h_recent_for, fallback_h_for, eff_mix_home))
    h_against_blend = max(0.05, _blend_recent_value(h_recent_against, fallback_h_against, eff_mix_home))
    a_for_blend = max(0.05, _blend_recent_value(a_recent_for, fallback_a_for, eff_mix_away))
    a_against_blend = max(0.05, _blend_recent_value(a_recent_against, fallback_a_against, eff_mix_away))

    denom = max(float(league_avg or 0.0), 1e-6)
    h_att = h_for_blend / denom
    h_def = h_against_blend / denom
    a_att = a_for_blend / denom
    a_def = a_against_blend / denom

    lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, home_adv)
    meta = {
        "home_games_used": int(cnt_home),
        "away_games_used": int(cnt_away),
        "home_recent_for": None if h_recent_for is None else float(h_recent_for),
        "home_recent_against": None if h_recent_against is None else float(h_recent_against),
        "away_recent_for": None if a_recent_for is None else float(a_recent_for),
        "away_recent_against": None if a_recent_against is None else float(a_recent_against),
        "home_eff_mix": float(eff_mix_home),
        "away_eff_mix": float(eff_mix_away),
    }
    return (float(lam_home), float(lam_away)), meta

def compute_lambda_models(
    league_id: int,
    season: int,
    home_id: int,
    away_id: int,
    h_stats: dict,
    a_stats: dict,
    league_avg: float,
) -> Dict[str, dict]:
    models: Dict[str, dict] = {}
    (lam_season, lam_season_away), season_meta = lambda_from_season_stats(h_stats, a_stats, league_avg, HOME_ADV)
    models["season"] = {
        "lam_home": lam_season,
        "lam_away": lam_season_away,
        "meta": season_meta,
    }

    recent_cfg = LAMBDA_MODEL_CONFIG.get("recent") or {}
    if float(recent_cfg.get("weight", 0.0)) > 0:
        try:
            (lam_recent, lam_recent_away), recent_meta = lambda_from_recent_form(
                home_id, away_id, league_id, season, league_avg, HOME_ADV, season_meta, recent_cfg
            )
            models["recent"] = {
                "lam_home": lam_recent,
                "lam_away": lam_recent_away,
                "meta": recent_meta,
            }
        except Exception as e:
            if LOG_LAMBDA_BLEND:
                print(f"[λ模型] 近况模型计算失败 {home_id}-{away_id}: {e}")
    return models

def blend_lambda_models(models: Dict[str, dict], config: Dict[str, dict]) -> tuple[float, float, Dict[str, float]]:
    valid = {
        name: data
        for name, data in models.items()
        if isinstance(data, dict) and data.get("lam_home") is not None and data.get("lam_away") is not None
    }
    if not valid:
        raise RuntimeError("无可用 λ 模型")

    weights_used: Dict[str, float] = {}
    weighted_home = 0.0
    weighted_away = 0.0
    for name, data in valid.items():
        weight_cfg = float((config.get(name) or {}).get("weight", 0.0))
        if weight_cfg <= 0:
            continue
        quality = _lambda_model_quality(name, data, config)
        effective_weight = weight_cfg * quality
        if effective_weight <= 0:
            continue
        lam_h = float(data.get("lam_home", 0.0))
        lam_a = float(data.get("lam_away", 0.0))
        weights_used[name] = effective_weight
        meta = data.setdefault("meta", {}) if isinstance(data, dict) else {}
        if isinstance(meta, dict):
            meta.setdefault("weight_cfg", weight_cfg)
            meta.setdefault("quality", quality)
        weighted_home += effective_weight * lam_h
        weighted_away += effective_weight * lam_a

    if not weights_used:
        first_name, data = next(iter(valid.items()))
        fallback_weights = {name: (1.0 if name == first_name else 0.0) for name in valid}
        return float(data.get("lam_home", 1.4)), float(data.get("lam_away", 1.1)), fallback_weights

    total_weight = sum(weights_used.values()) or 1.0
    lam_home = weighted_home / total_weight
    lam_away = weighted_away / total_weight
    normalized = {name: (weights_used.get(name, 0.0) / total_weight) for name in valid}
    return float(lam_home), float(lam_away), normalized

def format_lambda_detail(models: Dict[str, dict], weights: Dict[str, float]) -> str:
    parts: List[str] = []
    for name, data in models.items():
        lam_h = data.get("lam_home")
        lam_a = data.get("lam_away")
        if lam_h is None or lam_a is None:
            continue
        weight = weights.get(name, 0.0)
        parts.append(f"{name}:{float(lam_h):.3f}/{float(lam_a):.3f} (w={weight:.2f})")
    return " | ".join(parts)

def log_lambda_blend(home_name: str, away_name: str, models: Dict[str, dict], weights: Dict[str, float], lam_home: float, lam_away: float) -> None:
    entries = []
    for name, data in models.items():
        lam_h = data.get("lam_home")
        lam_a = data.get("lam_away")
        if lam_h is None or lam_a is None:
            continue
        cfg = LAMBDA_MODEL_CONFIG.get(name) or {}
        raw_weight = float(cfg.get("weight", 0.0))
        norm_weight = weights.get(name, 0.0)
        meta = data.get("meta") or {}
        quality = float(meta.get("quality", 1.0)) if meta else 1.0
        extra = ""
        if name == "recent":
            extra = (
                f" cntH={meta.get('home_games_used', 0)} cntA={meta.get('away_games_used', 0)}"
                f" mixH={meta.get('home_eff_mix', 0):.2f} mixA={meta.get('away_eff_mix', 0):.2f}"
            )
        entries.append(
            f"{name}:λ=({float(lam_h):.2f},{float(lam_a):.2f}) w_cfg={raw_weight:.2f} q={quality:.2f} w_norm={norm_weight:.2f}{extra}"
        )
    detail = " | ".join(entries)
    print(f"[λ模型] {home_name} vs {away_name} -> {detail} => blend=({lam_home:.2f},{lam_away:.2f})")

# ================== 打印 & 导出工具 ==================
def _fmt_ou_book(line, odds, is_corner=False):
    if line is None or odds is None: return ""
    tag = "CRN" if is_corner else "OU"
    try: return f"{tag}{float(line):g}@{float(odds):.2f}"
    except: return ""

def _fmt_ah_book(home_line, odds, side: str):
    if home_line is None or odds is None: return ""
    try:
        ln = float(home_line)
        ln_side = ln if side.lower()=="home" else -ln
        sign = "+" if ln_side > 0 else ""
        return f"AH{sign}{ln_side:g}@{float(odds):.2f}"
    except: return ""

def _stake_pct_from_kelly(k: Optional[float], quality: float = 1.0) -> float:
    try:
        if k is None: return 0.0
        pct = 100.0 * float(k) * float(KELLY_FRACTION) * max(0.0, float(quality))
        return float(min(STAKE_CAP_PCT, max(STAKE_MIN_PCT, round(pct, 2))))
    except: return 0.0

def export_picks(rows_all: List[Dict], date_str: str):
    picks: List[Dict] = []
    def _pick_quality(row: Dict, market: str) -> float:
        coverage = float(row.get("lam_coverage") or 0.0)
        quality = max(0.3, min(1.0, coverage if coverage > 0 else 0.3))
        tag = (market or "").lower()
        if tag.startswith("ou"):
            if row.get("ou_main_reason") != "ok":
                quality *= 0.5
            depth = min(int(row.get("ou_main_over_cnt") or 0), int(row.get("ou_main_under_cnt") or 0))
            if depth > 0:
                quality *= min(1.0, max(0.5, depth / 4.0))
            try:
                or_val = float(row.get("ou_main_overround"))
                quality *= max(0.5, min(1.0, 1.3 - or_val))
            except (TypeError, ValueError):
                pass
        elif tag.startswith("ah"):
            reason = str(row.get("ah_main_reason") or "").lower()
            if not reason.startswith("ok"):
                quality *= 0.5
        elif tag.startswith("crn"):
            depth = min(int(row.get("crn_main_over_cnt") or 0), int(row.get("crn_main_under_cnt") or 0))
            if depth > 0:
                quality *= min(1.0, max(0.5, depth / 4.0))
            try:
                or_val = float(row.get("crn_main_overround"))
                quality *= max(0.5, min(1.0, 1.28 - or_val))
            except (TypeError, ValueError):
                pass
        return max(0.2, min(1.0, quality))

    for r in rows_all:
        base = {"date_utc": r.get("date_utc"), "kickoff_utc": r.get("kickoff_utc"),
                "league": r.get("league"), "home": r.get("home"), "away": r.get("away")}
        # Goals OU 主盘
        ev, k = r.get("ev_ou_main_over"), r.get("kelly_ou_main_over")
        if ev is not None and k is not None:
            vi = value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base, "market":"OU-Over", "book":_fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),
                              "stake_pct":_stake_pct_from_kelly(k, _pick_quality(r, "ou"))})
        ev, k = r.get("ev_ou_main_under"), r.get("kelly_ou_main_under")
        if ev is not None and k is not None:
            vi = value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base, "market":"OU-Under", "book":_fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),
                              "stake_pct":_stake_pct_from_kelly(k, _pick_quality(r, "ou"))})
        # 1X2
        for mk, evk, kel, odd in [
            ("1X2-Home", r.get("ev_1x2_home"), r.get("kelly_1x2_home"), r.get("odds_1x2_home")),
            ("1X2-Draw", r.get("ev_1x2_draw"), r.get("kelly_1x2_draw"), r.get("odds_1x2_draw")),
            ("1X2-Away", r.get("ev_1x2_away"), r.get("kelly_1x2_away"), r.get("odds_1x2_away")),
        ]:
            if evk is not None and kel is not None and odd is not None:
                vi = value_index(evk, kel)
                if evk>=PICKS_MIN_EV and kel>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                    picks.append({**base, "market":mk, "book":f"{mk}@{float(odd):.2f}",
                                  "ev":float(evk),"kelly":float(kel),"value_index":float(vi),
                                  "stake_pct":_stake_pct_from_kelly(kel, _pick_quality(r, mk))})
        # AH 主盘
        ah_line = r.get("ah_line")
        if ah_line is not None:
            for side, evk, kel, odd in [
                ("home", r.get("ev_ah_home"), r.get("kelly_ah_home"), r.get("odds_ah_home")),
                ("away", r.get("ev_ah_away"), r.get("kelly_ah_away"), r.get("odds_ah_away")),
            ]:
                if evk is not None and kel is not None and odd is not None:
                    vi = value_index(evk, kel)
                    if evk>=PICKS_MIN_EV and kel>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                        market_tag = f"AH-{'Home' if side=='home' else 'Away'}"
                        picks.append({**base, "market":market_tag,
                                      "book":_fmt_ah_book(ah_line, odd, side),
                                      "ev":float(evk),"kelly":float(kel),"value_index":float(vi),
                                      "stake_pct":_stake_pct_from_kelly(kel, _pick_quality(r, market_tag))})
        # 角球 OU 主盘
        ev, k = r.get("ev_crn_main_over"), r.get("kelly_crn_main_over")
        if ev is not None and k is not None:
            vi = value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base,"market":"CRN-Over","book":_fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),
                              "stake_pct":_stake_pct_from_kelly(k, _pick_quality(r, "crn"))})
        ev, k = r.get("ev_crn_main_under"), r.get("kelly_crn_main_under")
        if ev is not None and k is not None:
            vi = value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base,"market":"CRN-Under","book":_fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),
                              "stake_pct":_stake_pct_from_kelly(k, _pick_quality(r, "crn"))})

    picks.sort(key=lambda x: x.get("value_index", -999), reverse=True)
    if PICKS_TOP_N is not None:
        picks = picks[:int(PICKS_TOP_N)]

    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"picks_{date_str}.csv")
    fieldnames = ["date_utc","kickoff_utc","league","home","away","market","book","ev","kelly","value_index","stake_pct"]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames); w.writeheader(); [w.writerow(p) for p in picks]
    print(f"\n已导出下注清单到: {out_file}  （{len(picks)} 条，阈值：EV≥{PICKS_MIN_EV}, Kelly≥{PICKS_MIN_KELLY}, VI≥{PICKS_MIN_VI}）")

def _median(arr: List[float]) -> Optional[float]:
    arr = [float(x) for x in arr if x];
    if not arr: return None
    arr.sort(); n=len(arr)
    return arr[n//2] if n%2==1 else 0.5*(arr[n//2-1]+arr[n//2])

def _ou_overround(oo: float, uu: float) -> float:
    try: return 1.0/float(oo) + 1.0/float(uu)
    except: return 9.9

# —— 新增：通用小工具 & AH 全线归一 & 主盘选择 —— #
def _to_float(x, default=None):
    try:
        if isinstance(x, str):
            x = x.replace("+", "")
        return float(x)
    except:
        return default

def build_ah_lines(odds: dict) -> dict:
    """
    统一把 AH 全线提取/归一（支持多个可能的键名和数据形态）：
    输出:
      { "0.25": {"home_median":..., "away_median":..., "home_cnt":..., "away_cnt":..., "overround":...}, ... }
    """
    if not isinstance(odds, dict):
        return {}

    # 1) 已有标准结构
    if isinstance(odds.get("ah_lines"), dict) and odds["ah_lines"]:
        return odds["ah_lines"]

    # 2) 多候选键名（容错）
    cand_keys = ["_raw_ah_map", "ah_raw_map", "asian_handicap_map", "asian_map", "AH", "ah"]
    raw = None
    for k in cand_keys:
        if isinstance(odds.get(k), dict) and odds[k]:
            raw = odds[k]; break
    if raw is None:
        return {}

    out = {}
    for line_key, sides in raw.items():
        ln = _to_float(line_key, default=None)
        if ln is None or not isinstance(sides, dict):
            continue

        hs = sides.get("home")
        as_ = sides.get("away")

        # 支持“列表/单值”
        if isinstance(hs, (list, tuple)):
            hs = [_to_float(v) for v in hs if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oh = _median(hs)
            cnt_h = len(hs)
        else:
            oh = _to_float(hs)
            cnt_h = 1 if oh is not None else 0

        if isinstance(as_, (list, tuple)):
            as_ = [_to_float(v) for v in as_ if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oa = _median(as_)
            cnt_a = len(as_)
        else:
            oa = _to_float(as_)
            cnt_a = 1 if oa is not None else 0

        if oh is None or oa is None:
            continue

        oround = _ou_overround(oh, oa)
        out[str(float(ln))] = {
            "home_median": float(oh), "away_median": float(oa),
            "home_cnt": int(cnt_h), "away_cnt": int(cnt_a),
            "overround": float(oround)
        }
    return out

def select_best_ah_main(ah_lines: dict, strict: int = 1) -> tuple[float, float, float] | None:
    """
    从 ah_lines 中挑“主盘”：优先低超盘、样本多、|line|小。
    返回 (line, home_odds, away_odds) 或 None
    """
    if not isinstance(ah_lines, dict) or not ah_lines:
        return None

    cands = []
    for sline, info in ah_lines.items():
        ln = _to_float(sline, default=None)
        oh = _to_float((info or {}).get("home_median"), default=None)
        oa = _to_float((info or {}).get("away_median"), default=None)
        if ln is None or oh is None or oa is None:
            continue
        cnt_h = int((info or {}).get("home_cnt", 0) or 0)
        cnt_a = int((info or {}).get("away_cnt", 0) or 0)
        oround = _to_float((info or {}).get("overround"), default=9.9)

        if strict:
            if min(cnt_h, cnt_a) < AH_MIN_CNT:
                continue
            if not (1.00 <= oround <= AH_MAX_OR):
                continue

        cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        # 放宽再挑一次
        for sline, info in ah_lines.items():
            ln = _to_float(sline, default=None)
            oh = _to_float((info or {}).get("home_median"), default=None)
            oa = _to_float((info or {}).get("away_median"), default=None)
            if ln is None or oh is None or oa is None:
                continue
            cnt_h = int((info or {}).get("home_cnt", 0) or 0)
            cnt_a = int((info or {}).get("away_cnt", 0) or 0)
            oround = _to_float((info or {}).get("overround"), default=9.9)
            cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        return None

    cands.sort()
    _, _, _, ln, oh, oa = cands[0]
    return (float(ln), float(oh), float(oa))

# ================== 主流程 ==================
def main():
    random.seed(42); np.random.seed(42)
    date_str = _today_utc_date()
    print(f"=== 37号 · 每日情报站（并发/快速版）@ {date_str} ===")

    fixtures = fixtures_by_date(date_str)
    if not fixtures:
        print("该日期无赛程或 API 无返回。"); return

    if EXCLUDE_NOISY:
        kept = []
        for fx in fixtures:
            lgname = ((fx.get("league") or {}).get("name") or "").lower()
            if not any(k in lgname for k in EXCLUDE_KEYS):
                kept.append(fx)
        fixtures = kept
    print(f"拉取赛程：{len(fixtures)} 场。正在预取球队统计…")

    prefetch_team_stats(fixtures)

    rows_all: List[Dict] = []
    matrix_rows: List[Dict] = []

    # 全线榜单池
    ou_all_over, ou_all_under = [], []
    crn_all_over, crn_all_under = [], []
    ah_all_home, ah_all_away = [], []

    # AH 诊断计数
    cnt_ah_has_line = cnt_ah_ev_home = cnt_ah_ev_away = 0

    done = 0
    for fx in fixtures:
        try:
            league = fx["league"]; league_id = league["id"]; season = league["season"]
            league_name = league.get("name")
            fixture_info = fx.get("fixture", {}); kickoff_utc = fixture_info.get("date"); fx_id = fixture_info.get("id")
            home = fx["teams"]["home"]; away = fx["teams"]["away"]
            home_id, away_id = home["id"], away["id"]
            home_name, away_name = home["name"], away["name"]
        except Exception as e:
            print(f"跳过一场（解析失败）：{e}"); continue

        league_avg = compute_league_avg_from_cache(league_id, season)

        h_st = TEAM_STATS_CACHE.get((league_id, season, home_id), {}) or {}
        a_st = TEAM_STATS_CACHE.get((league_id, season, away_id), {}) or {}

        lambda_models = compute_lambda_models(
            league_id=league_id,
            season=season,
            home_id=home_id,
            away_id=away_id,
            h_stats=h_st,
            a_stats=a_st,
            league_avg=league_avg,
        )
        lam_home_raw, lam_away_raw, lam_weights = blend_lambda_models(lambda_models, LAMBDA_MODEL_CONFIG)
        coverage = lambda_coverage_score(lambda_models, lam_weights, LAMBDA_MODEL_CONFIG)
        lam_detail = format_lambda_detail(lambda_models, lam_weights)

        odds = odds_by_fixture(fx_id) if fx_id else {}

        lam_home, lam_away, lam_market_total, lam_notes = adjust_lambdas_with_guards(
            lam_home_raw, lam_away_raw, odds, coverage, notes=[]
        )
        lam_guard_note = ";".join(lam_notes)
        if lam_guard_note:
            lam_detail = f"{lam_detail} | guards:{lam_guard_note}"
        if LOG_LAMBDA_BLEND:
            log_lambda_blend(home_name, away_name, lambda_models, lam_weights, lam_home, lam_away)
            extra = [f"coverage={coverage:.2f}"]
            if lam_market_total is not None:
                extra.append(f"market_tot≈{lam_market_total:.2f}")
            if lam_guard_note:
                extra.append(f"guards={lam_guard_note}")
            print("    ↳ " + " | ".join(extra))

        sim = monte_carlo_simulate(lam_home, lam_away, n_sims=N_SIMS_GOALS, over_line=2.5)
        _, _, totals = simulate_goals(lam_home, lam_away, n_sims=N_SIMS_GOALS)
        try:
            totals = [int(x) for x in totals]
        except Exception:
            totals = [int(totals)]

        # ===== 1X2 =====
        o1_h, o1_d, o1_a = odds.get("1x2_home"), odds.get("1x2_draw"), odds.get("1x2_away")
        ev1_h = ev1_d = ev1_a = k1_h = k1_d = k1_a = None
        model_probs_1x2 = {
            "p_home": float(sim.get("p_home", 0.0)),
            "p_draw": float(sim.get("p_draw", 0.0)),
            "p_away": float(sim.get("p_away", 0.0)),
        }
        market_probs_1x2: Optional[Dict[str, float]] = None
        ok1 = sanitize_1x2(o1_h, o1_d, o1_a)
        if ok1:
            o1_h, o1_d, o1_a = ok1
            inv_h = 1.0 / o1_h
            inv_d = 1.0 / o1_d
            inv_a = 1.0 / o1_a
            denom = inv_h + inv_d + inv_a
            if denom > 0:
                market_probs_1x2 = {
                    "p_home": inv_h / denom,
                    "p_draw": inv_d / denom,
                    "p_away": inv_a / denom,
                }
        else:
            o1_h = o1_d = o1_a = None

        blend_alpha = max(0.35, min(0.90, 0.55 + 0.30 * coverage))
        draw_boost = 0.05 + 0.05 * (1.0 - coverage)
        prob_1x2 = dict(model_probs_1x2)
        if market_probs_1x2:
            prob_1x2 = blend_probabilities_with_market(model_probs_1x2, market_probs_1x2, blend_alpha)
        prob_1x2 = apply_draw_inflation(prob_1x2, draw_boost)
        sim.update(prob_1x2)

        if ok1:
            ev1_h, k1_h = ev_kelly_binary(prob_1x2["p_home"], o1_h)
            ev1_d, k1_d = ev_kelly_binary(prob_1x2["p_draw"], o1_d)
            ev1_a, k1_a = ev_kelly_binary(prob_1x2["p_away"], o1_a)
            if is_ev_outlier(max([x for x in (ev1_h, ev1_d, ev1_a) if x is not None], default=0)):
                ev1_h = ev1_d = ev1_a = k1_h = k1_d = k1_a = None

        # ===== Goals OU 主盘 =====
        ou_main_line = odds.get("ou_main_line")
        ou_main_over = odds.get("ou_main_over")
        ou_main_under = odds.get("ou_main_under")
        ou_cnt_o = int(odds.get("ou_main_over_cnt") or 0)
        ou_cnt_u = int(odds.get("ou_main_under_cnt") or 0)
        try:
            ou_overround_val = float(odds.get("ou_main_overround"))
        except (TypeError, ValueError):
            ou_overround_val = None
        ou_overround = ou_overround_val if ou_overround_val is not None else 9.9

        ou_main_reason = "no_line" if ou_main_line is None else "no_odds"
        ev_main_over = ev_main_under = k_main_over = k_main_under = None
        pair = sanitize_ou_pair(ou_main_over, ou_main_under)
        if pair and ou_main_line is not None:
            ou_main_over, ou_main_under = pair
            allowed, reason, _ = _assess_ou_main(ou_cnt_o, ou_cnt_u, ou_overround_val, STRICT_OU_MAIN)
            if allowed:
                res = ou_ev_kelly_from_totals_quarter(float(ou_main_line), float(ou_main_over), float(ou_main_under), totals)
                ev_main_over, k_main_over = res["EV_over"], res["Kelly_over"]
                ev_main_under, k_main_under = res["EV_under"], res["Kelly_under"]
                if is_ev_outlier(max([x for x in (ev_main_over, ev_main_under) if x is not None], default=0)):
                    ev_main_over = ev_main_under = k_main_over = k_main_under = None
                    ou_main_reason = "ev_outlier"
                else:
                    ou_main_reason = "ok"
            else:
                ou_main_reason = reason
        elif ou_main_line is not None and not pair:
            ou_main_reason = "pair_invalid"

        # ===== OU@2.5 参考 =====
        o25_over,o25_under = odds.get("ou_over_2_5"),odds.get("ou_under_2_5")
        ev25_over=ev25_under=k25_over=k25_under=None
        ok25 = sanitize_ou_pair(o25_over,o25_under)
        if ok25:
            o25_over,o25_under = ok25
            res25 = ou_ev_kelly_from_totals_quarter(2.5, float(o25_over), float(o25_under), totals)
            ev25_over, k25_over = res25["EV_over"],  res25["Kelly_over"]
            ev25_under, k25_under = res25["EV_under"], res25["Kelly_under"]
            if is_ev_outlier(max([x for x in (ev25_over,ev25_under) if x is not None], default=0)):
                ev25_over=ev25_under=k25_over=k25_under=None

        # ===== AH 全线（统一归一）
        ah_lines = build_ah_lines(odds)

        # ===== AH 主盘（缺就从全线里自选）
        ah_line = odds.get("ah_line")
        ah_oh = odds.get("ah_home_odds")
        ah_oa = odds.get("ah_away_odds")
        ah_main_reason = "no_market"
        ah_source = None
        if ah_line is None or ah_oh is None or ah_oa is None:
            pick = select_best_ah_main(ah_lines, strict=STRICT_AH_MAIN)
            if pick:
                ah_line, ah_oh, ah_oa = pick
                ah_source = "matrix"
            else:
                ah_main_reason = "no_main_candidate" if ah_lines else "no_lines"
        else:
            ah_source = "api"

        ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None
        if ah_line is not None and ah_oh is not None and ah_oa is not None:
            cnt_ah_has_line += 1
            probs_ah = ah_probabilities_from_lams(lam_home, lam_away, h=float(ah_line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs_ah, odds_home=float(ah_oh), odds_away=float(ah_oa))
            if isinstance(evk.get("home"), dict):
                ev_ah_h, k_ah_h = evk["home"].get("EV"), evk["home"].get("Kelly")
            if isinstance(evk.get("away"), dict):
                ev_ah_a, k_ah_a = evk["away"].get("EV"), evk["away"].get("Kelly")
            if is_ev_outlier(max([x for x in (ev_ah_h, ev_ah_a) if x is not None], default=0)):
                ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None
                ah_main_reason = "ev_outlier"
            else:
                if ev_ah_h is not None: cnt_ah_ev_home += 1
                if ev_ah_a is not None: cnt_ah_ev_away += 1
                ah_main_reason = f"ok_{ah_source or 'api'}"

        # ===== 角球 OU 主盘 =====
        crn_main_line  = odds.get("crn_main_line")
        crn_main_over  = odds.get("crn_main_over")
        crn_main_under = odds.get("crn_main_under")
        crn_cnt_o      = odds.get("crn_main_over_cnt") or 0
        crn_cnt_u      = odds.get("crn_main_under_cnt") or 0
        crn_overround  = odds.get("crn_main_overround") or 9.9

        ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None
        crn_totals_list: List[int] | None = None

        if crn_main_line is not None and crn_main_over is not None and crn_main_under is not None:
            pair = sanitize_ou_pair(crn_main_over, crn_main_under)
            if pair and (not STRICT_CRN_MAIN or (crn_cnt_o >= CRN_MIN_CNT and crn_cnt_u >= CRN_MIN_CNT and crn_overround <= CRN_MAX_OR)):
                crn_main_over, crn_main_under = pair
                lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
                crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
                crn_totals_list = [int(x) for x in crn_totals]
                resC = ou_ev_kelly_from_totals_quarter(float(crn_main_line), float(crn_main_over), float(crn_main_under), crn_totals_list)
                ev_crn_over, k_crn_over = resC["EV_over"],  resC["Kelly_over"]
                ev_crn_under, k_crn_under = resC["EV_under"], resC["Kelly_under"]
                if is_ev_outlier(max([x for x in (ev_crn_over,ev_crn_under) if x is not None], default=0)):
                    ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None

        # ===== 全线榜单池 & 盘口矩阵（优先使用 *_lines；无则回退 _raw_*） =====
        ou_lines = odds.get("ou_lines") or {}
        crn_lines = odds.get("crn_lines") or {}
        # —— AH 用统一归一后的
        #   ah_lines 已在上面 build_ah_lines(odds) 生成

        # 回退：当 *_lines 缺失时，从 _raw_* 现算（OU/CRN 保持原逻辑）
        if not ou_lines and odds.get("_raw_ou_map"):
            for line, sides in odds["_raw_ou_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                ou_lines[str(float(line))] = {
                    "over_median": om, "under_median": um,
                    "over_cnt": len(ov), "under_cnt": len(un), "overround": oround,
                    "direction_ok": True, "swapped": False
                }
        if not crn_lines and odds.get("_raw_crn_map"):
            for line, sides in odds["_raw_crn_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un)
                adj_over, adj_under, direction_ok = _adjust_corner_line_for_sanity(line, om, um)
                if adj_over is None or adj_under is None or not direction_ok:
                    continue
                oround = _ou_overround(adj_over, adj_under)
                crn_lines[str(float(line))] = {
                    "over_median": adj_over, "under_median": adj_under,
                    "over_cnt": len(ov), "under_cnt": len(un), "overround": oround,
                    "direction_ok": bool(direction_ok), "swapped": adj_over != om or adj_under != um
                }

        # —— 全线榜单池（OU）
        for sline, info in (ou_lines.items() if isinstance(ou_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            over_cnt = int(info.get("over_cnt", 0) or 0)
            under_cnt = int(info.get("under_cnt", 0) or 0)
            if om is None or um is None:
                continue
            if over_cnt < 2 or under_cnt < 2:
                continue
            if ou_main_line is not None:
                try:
                    if abs(line - float(ou_main_line)) > ALLLINE_MAX_GAP:
                        continue
                except Exception:
                    pass
            try:
                or_val = float(oround)
            except Exception:
                or_val = 9.9
            if not (1.00 <= or_val <= 1.20):
                continue
            resL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), totals)
            if resL["EV_over"] is not None and resL["Kelly_over"] is not None:
                vi = value_index(resL["EV_over"], resL["Kelly_over"])
                ou_all_over.append((vi, home_name, away_name, line, float(om), resL["EV_over"], resL["Kelly_over"]))
            if resL["EV_under"] is not None and resL["Kelly_under"] is not None:
                vi = value_index(resL["EV_under"], resL["Kelly_under"])
                ou_all_under.append((vi, home_name, away_name, line, float(um), resL["EV_under"], resL["Kelly_under"]))

        # —— 全线榜单池（CRN）
        if crn_totals_list is None:
            lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
            crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
            crn_totals_list = [int(x) for x in crn_totals]
        for sline, info in (crn_lines.items() if isinstance(crn_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            over_cnt = int(info.get("over_cnt", 0) or 0)
            under_cnt = int(info.get("under_cnt", 0) or 0)
            if om is None or um is None:
                continue
            if info.get("direction_ok") is False:
                continue
            if over_cnt < 2 or under_cnt < 2:
                continue
            if crn_main_line is not None:
                try:
                    if abs(line - float(crn_main_line)) > ALLLINE_MAX_GAP:
                        continue
                except Exception:
                    pass
            try:
                or_val = float(oround)
            except Exception:
                or_val = 9.9
            if not (1.00 <= or_val <= 1.25):
                continue
            resCL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), crn_totals_list)
            if resCL["EV_over"] is not None and resCL["Kelly_over"] is not None:
                vi = value_index(resCL["EV_over"], resCL["Kelly_over"])
                crn_all_over.append((vi, home_name, away_name, line, float(om), resCL["EV_over"], resCL["Kelly_over"]))
            if resCL["EV_under"] is not None and resCL["Kelly_under"] is not None:
                vi = value_index(resCL["EV_under"], resCL["Kelly_under"])
                crn_all_under.append((vi, home_name, away_name, line, float(um), resCL["EV_under"], resCL["Kelly_under"]))

        # —— 全线榜单池（AH）
        for sline, info in (ah_lines.items() if isinstance(ah_lines, dict) else []):
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            oround = info.get("overround", 9.9)
            if oh is None or oa is None or not (1.00 <= float(oround) <= 1.25): continue
            probs = ah_probabilities_from_lams(lam_home, lam_away, h=float(line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs, odds_home=float(oh), odds_away=float(oa))
            if isinstance(evk.get("home"), dict) and evk["home"]["EV"] is not None and evk["home"]["Kelly"] is not None:
                vi = value_index(evk["home"]["EV"], evk["home"]["Kelly"])
                ah_all_home.append((vi, home_name, away_name, line, float(oh), evk["home"]["EV"], evk["home"]["Kelly"]))
            if isinstance(evk.get("away"), dict) and evk["away"]["EV"] is not None and evk["away"]["Kelly"] is not None:
                vi = value_index(evk["away"]["EV"], evk["away"]["Kelly"])
                ah_all_away.append((vi, home_name, away_name, line, float(oa), evk["away"]["EV"], evk["away"]["Kelly"]))

        # ===== 盘口矩阵（用 *_lines 导出） =====
        for sline, info in ou_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "OU", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })
        for sline, info in crn_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "CRN", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })
        for sline, info in ah_lines.items():
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            if oh is None or oa is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "AH", "line": float(line),
                "median_home": float(oh), "median_away": float(oa),
                "cnt_home": int(info.get("home_cnt", 0)), "cnt_away": int(info.get("away_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })

        # ===== 综合最佳 =====
        cands = []
        for label,ev,k in [
            ("1X2-Home", ev1_h, k1_h), ("1X2-Draw", ev1_d, k1_d), ("1X2-Away", ev1_a, k1_a),
            ("OU(main)-Over", ev_main_over, k_main_over), ("OU(main)-Under", ev_main_under, k_main_under),
            ("OU2.5-Over", ev25_over, k25_over), ("OU2.5-Under", ev25_under, k25_under),
            (f"AH({ah_line:+})-Home" if ah_line is not None else None, ev_ah_h, k_ah_h),
            (f"AH({ah_line:+})-Away" if ah_line is not None else None, ev_ah_a, k_ah_a),
            (f"CRN({crn_main_line})-Over" if crn_main_line is not None else None, ev_crn_over, k_crn_over),
            (f"CRN({crn_main_line})-Under" if crn_main_line is not None else None, ev_crn_under, k_crn_under),
        ]:
            if label and ev is not None and k is not None:
                cands.append((value_index(ev,k), label, ev, k))
        cands.sort(key=lambda x: x[0], reverse=True)
        best_label = cands[0][1] if cands else None
        best_ev    = cands[0][2] if cands else None
        best_kelly = cands[0][3] if cands else None

        # ===== 写行 =====
        weight_fields = {
            f"lam_weight_{name}": round(lam_weights.get(name, 0.0), 3)
            for name, data in lambda_models.items()
            if data.get("lam_home") is not None and data.get("lam_away") is not None
        }

        row = {
            "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
            "home": home_name, "away": away_name,
            "lam_home": round(lam_home,3), "lam_away": round(lam_away,3),
            "lam_market_total": round(lam_market_total,3) if lam_market_total is not None else None,
            "lam_coverage": round(coverage,3),
            "lam_guard_notes": lam_guard_note or None,
            "p_home": round(sim["p_home"],4), "p_draw": round(sim["p_draw"],4), "p_away": round(sim["p_away"],4),
            "p_over2.5": round(sim["p_over"],4), "p_under2.5": round(sim["p_under"],4),

            # Goals OU 主盘（含诊断 + EV）
            "ou_main_line": ou_main_line,
            "odds_ou_main_over": ou_main_over, "odds_ou_main_under": ou_main_under,
            "ou_main_over_cnt": ou_cnt_o, "ou_main_under_cnt": ou_cnt_u, "ou_main_overround": ou_overround,
            "ev_ou_main_over": ev_main_over, "kelly_ou_main_over": k_main_over,
            "ev_ou_main_under": ev_main_under, "kelly_ou_main_under": k_main_under,
            "ou_main_reason": ou_main_reason,

            # OU@2.5 参考
            "odds_ou_over2.5": odds.get("ou_over_2_5"), "odds_ou_under2.5": odds.get("ou_under_2_5"),
            "ev_ou_over2.5": ev25_over, "kelly_ou_over2.5": k25_over, "ev_ou_under2.5": ev25_under, "kelly_ou_under2.5": k25_under,

            # 1X2
            "odds_1x2_home": o1_h, "odds_1x2_draw": o1_d, "odds_1x2_away": o1_a,
            "ev_1x2_home": ev1_h, "kelly_1x2_home": k1_h,
            "ev_1x2_draw": ev1_d, "kelly_1x2_draw": k1_d,
            "ev_1x2_away": ev1_a, "kelly_1x2_away": k1_a,

            # AH（含诊断 + EV）
            "ah_line": ah_line, "odds_ah_home": ah_oh, "odds_ah_away": ah_oa,
            "ev_ah_home": ev_ah_h, "kelly_ah_home": k_ah_h,
            "ev_ah_away": ev_ah_a, "kelly_ah_away": k_ah_a,
            "ah_main_reason": ah_main_reason,

            # Corners OU 主盘（含诊断 + EV）
            "crn_main_line": crn_main_line,
            "odds_crn_main_over": crn_main_over, "odds_crn_main_under": crn_main_under,
            "crn_main_over_cnt": crn_cnt_o, "crn_main_under_cnt": crn_cnt_u, "crn_main_overround": crn_overround,
            "ev_crn_main_over": ev_crn_over, "kelly_crn_main_over": k_crn_over,
            "ev_crn_main_under": ev_crn_under, "kelly_crn_main_under": k_crn_under,

            "best_market": best_label, "best_ev": best_ev, "best_kelly": best_kelly,
            "value_index": value_index(best_ev, best_kelly) if (best_ev is not None and best_kelly is not None) else None
        }

        if lam_detail:
            row["lam_blend_detail"] = lam_detail
        for k, v in weight_fields.items():
            row[k] = v

        rows_all.append(row)

        done += 1
        if done % 30 == 0 or done == len(fixtures):
            print(f"……已处理 {done}/{len(fixtures)} 场")

    # ===== 导出全量 CSV =====
    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"daily_brief_{date_str}.csv")
    base_order = [
        "date_utc","kickoff_utc","league","home","away",
        "lam_home","lam_away","lam_market_total","lam_coverage","lam_guard_notes",
        "lam_weight_season","lam_weight_recent","lam_blend_detail",
        "p_home","p_draw","p_away","p_over2.5","p_under2.5",
        "ou_main_line","odds_ou_main_over","odds_ou_main_under",
        "ou_main_over_cnt","ou_main_under_cnt","ou_main_overround","ou_main_reason",
        "ev_ou_main_over","kelly_ou_main_over","ev_ou_main_under","kelly_ou_main_under",
        "odds_ou_over2.5","odds_ou_under2.5","ev_ou_over2.5","kelly_ou_over2.5","ev_ou_under2.5","kelly_ou_under2.5",
        "odds_1x2_home","odds_1x2_draw","odds_1x2_away","ev_1x2_home","kelly_1x2_home","ev_1x2_draw","kelly_1x2_draw","ev_1x2_away","kelly_1x2_away",
        "ah_line","odds_ah_home","odds_ah_away","ev_ah_home","kelly_ah_home","ev_ah_away","kelly_ah_away","ah_main_reason",
        "crn_main_line","odds_crn_main_over","odds_crn_main_under","crn_main_over_cnt","crn_main_under_cnt","crn_main_overround",
        "ev_crn_main_over","kelly_crn_main_over","ev_crn_main_under","kelly_crn_main_under",
        "best_market","best_ev","best_kelly","value_index"
    ]
    all_keys=set(); [all_keys.update(r.keys()) for r in rows_all]
    fieldnames = [c for c in base_order if c in all_keys] + [c for c in all_keys if c not in base_order]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
        w.writeheader(); [w.writerow(r) for r in rows_all]
    print(f"\n已导出全量数据到: {out_file}")

    # ===== 导出盘口矩阵（来自 *_lines） =====
    out_mat = os.path.join(out_dir, f"daily_brief_matrix_{date_str}.csv")
    if matrix_rows:
        mat_fields = [
            "date_utc","kickoff_utc","league","home","away","market","line",
            "median_over","median_under","median_home","median_away",
            "cnt_over","cnt_under","cnt_home","cnt_away","overround"
        ]
        with open(out_mat, "w", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=mat_fields, extrasaction="ignore")
            w.writeheader(); [w.writerow(r) for r in matrix_rows]
        print(f"已导出盘口矩阵到: {out_mat}")
    else:
        print("未获取到盘口矩阵（ou_lines/crn_lines/ah_lines），跳过导出。")

    # ===== 榜单打印 =====
    def top_list(rows: List[Dict], key_ev: str, key_k: str, label: str, suffix_fn=None):
        items = []
        for r in rows:
            ev,k = r.get(key_ev), r.get(key_k)
            if ev is None or k is None or ev < MIN_EV: continue
            items.append((value_index(ev,k), r, ev, k))
        items.sort(key=lambda x: x[0], reverse=True)
        print(f"\n=== Top {min(TOP_K, len(items))}（{label}，EV≥{MIN_EV:.2f}） ===")
        for i,(_,r,ev,k) in enumerate(items[:TOP_K], 1):
            extra = suffix_fn(r) if suffix_fn else ""
            print(f"[{i:02d}] {r['home']} vs {r['away']} | EV={ev:.3f} Kelly≈{k:.3f} | {label}{(' ' + extra) if extra else ''}")

    # Suffix 生成（去掉多余空格）
    suf_ou_over  = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False)
    suf_ou_under = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False)
    suf_1x2_home = lambda r: f"@{float(r['odds_1x2_home']):.2f}" if r.get("odds_1x2_home") else ""
    suf_1x2_draw = lambda r: f"@{float(r['odds_1x2_draw']):.2f}" if r.get("odds_1x2_draw") else ""
    suf_1x2_away = lambda r: f"@{float(r['odds_1x2_away']):.2f}" if r.get("odds_1x2_away") else ""
    suf_ah_home  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_home"), "home")
    suf_ah_away  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_away"), "away")
    suf_cr_over  = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True)
    suf_cr_under = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True)

    top_list(rows_all, "ev_ou_main_over",  "kelly_ou_main_over",  "OU主盘-Over",  suf_ou_over)
    top_list(rows_all, "ev_ou_main_under", "kelly_ou_main_under", "OU主盘-Under", suf_ou_under)
    top_list(rows_all, "ev_1x2_home", "kelly_1x2_home", "1X2-主胜", suf_1x2_home)
    top_list(rows_all, "ev_1x2_draw", "kelly_1x2_draw", "1X2-平局", suf_1x2_draw)
    top_list(rows_all, "ev_1x2_away", "kelly_1x2_away", "1X2-客胜", suf_1x2_away)
    top_list(rows_all, "ev_ah_home", "kelly_ah_home", "AH-主方向", suf_ah_home)
    top_list(rows_all, "ev_ah_away", "kelly_ah_away", "AH-客方向", suf_ah_away)
    top_list(rows_all, "ev_crn_main_over",  "kelly_crn_main_over",  "角球主盘-Over",  suf_cr_over)
    top_list(rows_all, "ev_crn_main_under", "kelly_crn_main_under", "角球主盘-Under", suf_cr_under)

    # ===== 全线 Top（按 VI 排序）=====
    def print_ou_crn_allline_top(title: str, arr: List[tuple], tag="OU"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [(vi,h,a,line,od,ev,k) for (vi,h,a,line,od,ev,k) in arr if ev is not None and k is not None and ev >= MIN_EV]
        arr2.sort(key=lambda x: x[0], reverse=True)
        for i,(vi,h,a,line,od,ev,k) in enumerate(arr2[:TOP_K],1):
            print(f"[{i:02d}] {h} vs {a} | 线={line:g} | EV={ev:.3f} Kelly≈{k:.3f} | {title} {tag}{line:g}@{od:.2f}")

    def print_ah_allline_top(title: str, arr: List[tuple], side="home"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [(vi,h,a,line,od,ev,k) for (vi,h,a,line,od,ev,k) in arr if ev is not None and k is not None and ev >= MIN_EV]
        arr2.sort(key=lambda x: x[0], reverse=True)
        for i,(vi,h,a,line,od,ev,k) in enumerate(arr2[:TOP_K],1):
            adj = line if side=="home" else -line
            sign = "+" if adj>0 else ""
            print(f"[{i:02d}] {h} vs {a} | 线={adj:g} | EV={ev:.3f} Kelly≈{k:.3f} | {title} AH{sign}{adj:g}@{od:.2f}")

    if ou_all_over:  print_ou_crn_allline_top("进球OU-Over（全线）",  ou_all_over,  "OU")
    if ou_all_under: print_ou_crn_allline_top("进球OU-Under（全线）", ou_all_under, "OU")
    if crn_all_over: print_ou_crn_allline_top("角球OU-Over（全线）",  crn_all_over,  "CRN")
    if crn_all_under:print_ou_crn_allline_top("角球OU-Under（全线）", crn_all_under, "CRN")
    if ah_all_home: print_ah_allline_top("AH-主方向（全线）", ah_all_home, side="home")
    if ah_all_away: print_ah_allline_top("AH-客方向（全线）", ah_all_away, side="away")

    # AH 诊断
    print(f"\n[AH诊断] 有主盘线的比赛: {cnt_ah_has_line} 场；出现正EV(主): {cnt_ah_ev_home} 场；正EV(客): {cnt_ah_ev_away} 场")

    # 导出 picks.csv
    if EXPORT_PICKS:
        export_picks(rows_all, date_str)

if __name__ == "__main__":
    try:
        if os.environ.get("DAILY_BRIEF_SELFTEST") == "1":
            _regression_check_quarter_under()
        main()
    except Exception as e:
        print("程序异常：", e)
        traceback.print_exc()
