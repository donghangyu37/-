# === daily_brief.py · 每日情报站（并发/快速版 + 主盘OU/AH + 角球OU + 全线榜单 + 盘口矩阵 + picks.csv）===
from __future__ import annotations
from datetime import datetime, timezone
from typing import Dict, List, Tuple, Optional, Set
import math, os, csv, traceback, random

from concurrent.futures import ThreadPoolExecutor, as_completed
import numpy as np

# —— 项目内模块
from src.api.football_api import fixtures_by_date, team_statistics, odds_by_fixture
from src.data.transform import league_goal_averages
from src.models.poisson_mc import expected_goals_from_strengths, monte_carlo_simulate, simulate_goals
from src.markets.asian_handicap import ah_probabilities_from_lams, ah_ev_kelly
from src.config import HOME_ADV

# ================== 可调参数 ==================
FAST_MODE = 1
N_SIMS_GOALS   = 12000 if FAST_MODE else 25000
N_SIMS_CORNERS = 12000 if FAST_MODE else 25000
USE_RECENT = 0 if FAST_MODE else 1

CONCURRENCY = 6

# 主盘诊断阈值
STRICT_OU_MAIN  = 1; OU_MIN_CNT  = 3; OU_MAX_OR  = 1.12
STRICT_CRN_MAIN = 1; CRN_MIN_CNT = 3; CRN_MAX_OR = 1.20

# —— 新增：AH 主盘诊断阈值（与 OU/CRN 一致思路）
STRICT_AH_MAIN = 1     # 开启严格筛选：样本数与超盘限制
AH_MIN_CNT     = 3     # home/away 各至少多少条报价
AH_MAX_OR      = 1.20  # 超盘上限（1/oh + 1/oa）

# 异常 EV 拦截
def is_ev_outlier(ev: float) -> bool: return ev > 0.35

# 噪声赛事过滤
EXCLUDE_NOISY = 0
EXCLUDE_KEYS = ["u21","u23","res.","reserve","friendly","club friendlies"]

TOP_K  = 10
MIN_EV = 0.00

# 角球 λ 兜底
CORNER_BASE = 7.5
CORNER_PER_GOAL = 0.9

# ===== Picks 导出配置 =====
EXPORT_PICKS = 1
PICKS_TOP_N = 100
PICKS_MIN_EV = 0.05
PICKS_MIN_KELLY = 0.05
PICKS_MIN_VI = 0.00
KELLY_FRACTION = 0.25
STAKE_CAP_PCT = 2.0
STAKE_MIN_PCT = 0.0

# ================== 工具函数 ==================
def _today_utc_date() -> str:
    return datetime.now(timezone.utc).date().isoformat()

def sanitize_ou_pair(o_over: float | None, o_under: float | None) -> Tuple[float, float] | None:
    if o_over is None or o_under is None: return None
    try: oo, uu = float(o_over), float(o_under)
    except: return None
    if not (1.10 <= oo <= 50.0 and 1.10 <= uu <= 50.0): return None
    imp = 1/oo + 1/uu
    if not (1.00 <= imp <= 1.25): return None
    return oo, uu

def sanitize_1x2(o_h: float | None, o_d: float | None, o_a: float | None):
    try:
        if None in (o_h, o_d, o_a): return None
        oh, od, oa = float(o_h), float(o_d), float(o_a)
    except: return None
    if not all(1.10 <= v <= 100.0 for v in (oh, od, oa)): return None
    imp = 1/oh + 1/od + 1/oa
    if not (1.00 <= imp <= 1.30): return None
    return oh, od, oa

def ev_kelly_binary(p: float, odds: float) -> Tuple[float, float]:
    b = odds - 1.0
    EV = p*b - (1-p)
    K  = 0.0 if b<=0 else max(0.0, (b*p - (1-p))/b)
    return float(EV), float(K)

def value_index(ev: float | None, kelly: float | None) -> float:
    if ev is None or kelly is None: return -999.0
    return float(ev * math.sqrt(max(0.0, kelly)))

# ===== 四分之一盘精结算（基于 totals 样本）=====
def ou_ev_kelly_from_totals_quarter(line: float, over_odds: float, under_odds: float, totals) -> dict:
    if totals is None:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}
    try:
        totals_list = list(totals)
    except TypeError:
        totals_list = [totals]
    if len(totals_list) == 0:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}

    a = int(line // 1)
    frac = round(line - a, 2)
    n = len(totals_list)

    def counts_over(a, frac):
        if frac == 0.0:
            fw = sum(t > a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t > a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t >= a + 1 for t in totals_list) / n
            hl = sum(t == a for t in totals_list) / n
            fl = sum(t <= a - 1 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, 0.0, hl, fl + max(0.0, remain)
        elif frac == 0.75:
            fw = sum(t >= a + 2 for t in totals_list) / n
            hw = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t <= a for t in totals_list) / n
            remain = 1.0 - fw - hw - fl
            return fw, hw, remain, 0.0, fl
        else:
            fw = sum(t > line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    def counts_under(a, frac):
        if frac == 0.0:
            fw = sum(t < a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t < a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t <= a for t in totals_list) / n
            hw = sum(t == a for t in totals_list) / n
            fl = sum(t >= a + 1 for t in totals_list) / n
            remain = 1.0 - fw - hw - fl
            return fw, hw, remain, 0.0, fl
        elif frac == 0.75:
            fw = sum(t <= a for t in totals_list) / n
            hl = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t >= a + 2 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, remain, hl, fl
        else:
            fw = sum(t < line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    fw_o, hw_o, pu_o, hl_o, fl_o = counts_over(a, frac)
    fw_u, hw_u, pu_u, hl_u, fl_u = counts_under(a, frac)

    b_over  = max(0.0, over_odds - 1.0)
    b_under = max(0.0, under_odds - 1.0)

    EV_over  = fw_o*b_over + hw_o*(0.5*b_over) - hl_o*0.5 - fl_o*1.0
    EV_under = fw_u*b_under + hw_u*(0.5*b_under) - hl_u*0.5 - fl_u*1.0

    pwin_o, plose_o = fw_o + 0.5*hw_o, fl_o + 0.5*hl_o
    pwin_u, plose_u = fw_u + 0.5*hw_u, fl_u + 0.5*hl_u

    K_over  = 0.0 if b_over  <= 0 else max(0.0, (b_over*pwin_o  - plose_o)/b_over)
    K_under = 0.0 if b_under <= 0 else max(0.0, (b_under*pwin_u - plose_u)/b_under)

    return {"EV_over": float(EV_over), "Kelly_over": float(K_over),
            "EV_under": float(EV_under), "Kelly_under": float(K_under)}

# ================== 预取与缓存 ==================
TEAM_STATS_CACHE: dict[tuple[int,int,int], dict] = {}

def prefetch_team_stats(fixtures: List[Dict]):
    tasks: Set[tuple[int,int,int]] = set()
    for fx in fixtures:
        try:
            lg = fx["league"]["id"]; ss = fx["league"]["season"]
            hid = fx["teams"]["home"]["id"]; aid = fx["teams"]["away"]["id"]
            tasks.add((lg, ss, hid)); tasks.add((lg, ss, aid))
        except: pass

    def _job(key):
        if key in TEAM_STATS_CACHE: return key, TEAM_STATS_CACHE[key]
        lg, ss, tid = key
        try:
            st = team_statistics(lg, ss, tid)
            TEAM_STATS_CACHE[key] = st or {}
            return key, TEAM_STATS_CACHE[key]
        except Exception:
            return key, {}

    if not tasks: return
    with ThreadPoolExecutor(max_workers=CONCURRENCY) as ex:
        futures = {ex.submit(_job, k): k for k in tasks}
        done = 0
        for _ in as_completed(futures):
            done += 1
            if done % 20 == 0 or done == len(tasks):
                print(f"……已预取球队统计 {done}/{len(tasks)}")

def compute_league_avg_from_cache(league_id: int, season: int) -> float:
    stats_list = []
    for (lg, ss, _tid), st in TEAM_STATS_CACHE.items():
        if lg == league_id and ss == season and st:
            stats_list.append(st)
    if not stats_list:
        return 2.6
    league_avg, _ = league_goal_averages(stats_list)
    return float(league_avg or 2.6)

def estimate_corners_lambda_total(h_stats: dict, a_stats: dict, lam_home: float, lam_away: float) -> float:
    def _safe(path, d):
        cur = d
        for k in path:
            if not isinstance(cur, dict): return None
            cur = cur.get(k)
            if cur is None: return None
        try: return float(cur)
        except: return None
    h_c_home = _safe(["corners","for","average","home"], h_stats)
    a_c_away = _safe(["corners","for","average","away"], a_stats)
    if h_c_home and a_c_away and h_c_home > 0 and a_c_away > 0:
        return float(h_c_home + a_c_away)
    return float(CORNER_BASE + CORNER_PER_GOAL * (lam_home + lam_away))

# ================== 打印 & 导出工具 ==================
def _fmt_ou_book(line, odds, is_corner=False):
    if line is None or odds is None: return ""
    tag = "CRN" if is_corner else "OU"
    try: return f"{tag}{float(line):g}@{float(odds):.2f}"
    except: return ""

def _fmt_ah_book(home_line, odds, side: str):
    if home_line is None or odds is None: return ""
    try:
        ln = float(home_line)
        ln_side = ln if side.lower()=="home" else -ln
        sign = "+" if ln_side > 0 else ""
        return f"AH{sign}{ln_side:g}@{float(odds):.2f}"
    except: return ""

def _stake_pct_from_kelly(k: Optional[float]) -> float:
    try:
        if k is None: return 0.0
        pct = 100.0 * float(k) * float(KELLY_FRACTION)
        return float(min(STAKE_CAP_PCT, max(STAKE_MIN_PCT, round(pct, 2))))
    except: return 0.0

def export_picks(rows_all: List[Dict], date_str: str):
    picks: List[Dict] = []
    for r in rows_all:
        base = {"date_utc": r.get("date_utc"), "kickoff_utc": r.get("kickoff_utc"),
                "league": r.get("league"), "home": r.get("home"), "away": r.get("away")}
        # Goals OU 主盘
        ev, k = r.get("ev_ou_main_over"), r.get("kelly_ou_main_over")
        if ev is not None and k is not None:
            vi = value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base, "market":"OU-Over", "book":_fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(k)})
        ev, k = r.get("ev_ou_main_under"), r.get("kelly_ou_main_under")
        if ev is not None and k is not None:
            vi = value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base, "market":"OU-Under", "book":_fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(k)})
        # 1X2
        for mk, evk, kel, odd in [
            ("1X2-Home", r.get("ev_1x2_home"), r.get("kelly_1x2_home"), r.get("odds_1x2_home")),
            ("1X2-Draw", r.get("ev_1x2_draw"), r.get("kelly_1x2_draw"), r.get("odds_1x2_draw")),
            ("1X2-Away", r.get("ev_1x2_away"), r.get("kelly_1x2_away"), r.get("odds_1x2_away")),
        ]:
            if evk is not None and kel is not None and odd is not None:
                vi = value_index(evk, kel)
                if evk>=PICKS_MIN_EV and kel>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                    picks.append({**base, "market":mk, "book":f"{mk}@{float(odd):.2f}",
                                  "ev":float(evk),"kelly":float(kel),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(kel)})
        # AH 主盘
        ah_line = r.get("ah_line")
        if ah_line is not None:
            for side, evk, kel, odd in [
                ("home", r.get("ev_ah_home"), r.get("kelly_ah_home"), r.get("odds_ah_home")),
                ("away", r.get("ev_ah_away"), r.get("kelly_ah_away"), r.get("odds_ah_away")),
            ]:
                if evk is not None and kel is not None and odd is not None:
                    vi = value_index(evk, kel)
                    if evk>=PICKS_MIN_EV and kel>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                        picks.append({**base, "market":f"AH-{'Home' if side=='home' else 'Away'}",
                                      "book":_fmt_ah_book(ah_line, odd, side),
                                      "ev":float(evk),"kelly":float(kel),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(kel)})
        # 角球 OU 主盘
        ev, k = r.get("ev_crn_main_over"), r.get("kelly_crn_main_over")
        if ev is not None and k is not None:
            vi = value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base,"market":"CRN-Over","book":_fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(k)})
        ev, k = r.get("ev_crn_main_under"), r.get("kelly_crn_main_under")
        if ev is not None and k is not None:
            vi = value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base,"market":"CRN-Under","book":_fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(k)})

    picks.sort(key=lambda x: x.get("value_index", -999), reverse=True)
    if PICKS_TOP_N is not None:
        picks = picks[:int(PICKS_TOP_N)]

    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"picks_{date_str}.csv")
    fieldnames = ["date_utc","kickoff_utc","league","home","away","market","book","ev","kelly","value_index","stake_pct"]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames); w.writeheader(); [w.writerow(p) for p in picks]
    print(f"\n已导出下注清单到: {out_file}  （{len(picks)} 条，阈值：EV≥{PICKS_MIN_EV}, Kelly≥{PICKS_MIN_KELLY}, VI≥{PICKS_MIN_VI}）")

def _median(arr: List[float]) -> Optional[float]:
    arr = [float(x) for x in arr if x];
    if not arr: return None
    arr.sort(); n=len(arr)
    return arr[n//2] if n%2==1 else 0.5*(arr[n//2-1]+arr[n//2])

def _ou_overround(oo: float, uu: float) -> float:
    try: return 1.0/float(oo) + 1.0/float(uu)
    except: return 9.9

# —— 新增：通用小工具 & AH 全线归一 & 主盘选择 —— #
def _to_float(x, default=None):
    try:
        if isinstance(x, str):
            x = x.replace("+", "")
        return float(x)
    except:
        return default

def build_ah_lines(odds: dict) -> dict:
    """
    统一把 AH 全线提取/归一（支持多个可能的键名和数据形态）：
    输出:
      { "0.25": {"home_median":..., "away_median":..., "home_cnt":..., "away_cnt":..., "overround":...}, ... }
    """
    if not isinstance(odds, dict):
        return {}

    # 1) 已有标准结构
    if isinstance(odds.get("ah_lines"), dict) and odds["ah_lines"]:
        return odds["ah_lines"]

    # 2) 多候选键名（容错）
    cand_keys = ["_raw_ah_map", "ah_raw_map", "asian_handicap_map", "asian_map", "AH", "ah"]
    raw = None
    for k in cand_keys:
        if isinstance(odds.get(k), dict) and odds[k]:
            raw = odds[k]; break
    if raw is None:
        return {}

    out = {}
    for line_key, sides in raw.items():
        ln = _to_float(line_key, default=None)
        if ln is None or not isinstance(sides, dict):
            continue

        hs = sides.get("home")
        as_ = sides.get("away")

        # 支持“列表/单值”
        if isinstance(hs, (list, tuple)):
            hs = [_to_float(v) for v in hs if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oh = _median(hs)
            cnt_h = len(hs)
        else:
            oh = _to_float(hs)
            cnt_h = 1 if oh is not None else 0

        if isinstance(as_, (list, tuple)):
            as_ = [_to_float(v) for v in as_ if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oa = _median(as_)
            cnt_a = len(as_)
        else:
            oa = _to_float(as_)
            cnt_a = 1 if oa is not None else 0

        if oh is None or oa is None:
            continue

        oround = _ou_overround(oh, oa)
        out[str(float(ln))] = {
            "home_median": float(oh), "away_median": float(oa),
            "home_cnt": int(cnt_h), "away_cnt": int(cnt_a),
            "overround": float(oround)
        }
    return out

def select_best_ah_main(ah_lines: dict, strict: int = 1) -> tuple[float, float, float] | None:
    """
    从 ah_lines 中挑“主盘”：优先低超盘、样本多、|line|小。
    返回 (line, home_odds, away_odds) 或 None
    """
    if not isinstance(ah_lines, dict) or not ah_lines:
        return None

    cands = []
    for sline, info in ah_lines.items():
        ln = _to_float(sline, default=None)
        oh = _to_float((info or {}).get("home_median"), default=None)
        oa = _to_float((info or {}).get("away_median"), default=None)
        if ln is None or oh is None or oa is None:
            continue
        cnt_h = int((info or {}).get("home_cnt", 0) or 0)
        cnt_a = int((info or {}).get("away_cnt", 0) or 0)
        oround = _to_float((info or {}).get("overround"), default=9.9)

        if strict:
            if min(cnt_h, cnt_a) < AH_MIN_CNT:
                continue
            if not (1.00 <= oround <= AH_MAX_OR):
                continue

        cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        # 放宽再挑一次
        for sline, info in ah_lines.items():
            ln = _to_float(sline, default=None)
            oh = _to_float((info or {}).get("home_median"), default=None)
            oa = _to_float((info or {}).get("away_median"), default=None)
            if ln is None or oh is None or oa is None:
                continue
            cnt_h = int((info or {}).get("home_cnt", 0) or 0)
            cnt_a = int((info or {}).get("away_cnt", 0) or 0)
            oround = _to_float((info or {}).get("overround"), default=9.9)
            cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        return None

    cands.sort()
    _, _, _, ln, oh, oa = cands[0]
    return (float(ln), float(oh), float(oa))

# ================== 主流程 ==================
def main():
    random.seed(42); np.random.seed(42)
    date_str = _today_utc_date()
    print(f"=== 37号 · 每日情报站（并发/快速版）@ {date_str} ===")

    fixtures = fixtures_by_date(date_str)
    if not fixtures:
        print("该日期无赛程或 API 无返回。"); return

    if EXCLUDE_NOISY:
        kept = []
        for fx in fixtures:
            lgname = ((fx.get("league") or {}).get("name") or "").lower()
            if not any(k in lgname for k in EXCLUDE_KEYS):
                kept.append(fx)
        fixtures = kept
    print(f"拉取赛程：{len(fixtures)} 场。正在预取球队统计…")

    prefetch_team_stats(fixtures)

    rows_all: List[Dict] = []
    matrix_rows: List[Dict] = []

    # 全线榜单池
    ou_all_over, ou_all_under = [], []
    crn_all_over, crn_all_under = [], []
    ah_all_home, ah_all_away = [], []

    # AH 诊断计数
    cnt_ah_has_line = cnt_ah_ev_home = cnt_ah_ev_away = 0

    done = 0
    for fx in fixtures:
        try:
            league = fx["league"]; league_id = league["id"]; season = league["season"]
            league_name = league.get("name")
            fixture_info = fx.get("fixture", {}); kickoff_utc = fixture_info.get("date"); fx_id = fixture_info.get("id")
            home = fx["teams"]["home"]; away = fx["teams"]["away"]
            home_id, away_id = home["id"], away["id"]
            home_name, away_name = home["name"], away["name"]
        except Exception as e:
            print(f"跳过一场（解析失败）：{e}"); continue

        league_avg = compute_league_avg_from_cache(league_id, season)

        h_st = TEAM_STATS_CACHE.get((league_id, season, home_id), {}) or {}
        a_st = TEAM_STATS_CACHE.get((league_id, season, away_id), {}) or {}

        def _safe(path, d, default):
            cur = d
            for k in path:
                cur = (cur or {}).get(k)
                if cur is None: return default
            try: return float(cur) if cur else default
            except: return default

        h_gf_home = _safe(["goals","for","average","home"], h_st, 1.3)
        h_ga_home = _safe(["goals","against","average","home"], h_st, 1.3)
        a_gf_away = _safe(["goals","for","average","away"], a_st, 1.3)
        a_ga_away = _safe(["goals","against","average","away"], a_st, 1.3)

        denom = max(league_avg, 1e-6)
        h_att = h_gf_home / denom; h_def = h_ga_home / denom
        a_att = a_gf_away / denom; a_def = a_ga_away / denom

        lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, HOME_ADV)

        sim = monte_carlo_simulate(lam_home, lam_away, n_sims=N_SIMS_GOALS, over_line=2.5)
        _, _, totals = simulate_goals(lam_home, lam_away, n_sims=N_SIMS_GOALS)
        try: totals = [int(x) for x in totals]
        except: totals = [int(totals)]

        odds = odds_by_fixture(fx_id) if fx_id else {}

        # ===== 1X2 =====
        o1_h,o1_d,o1_a = odds.get("1x2_home"),odds.get("1x2_draw"),odds.get("1x2_away")
        ev1_h=ev1_d=ev1_a=k1_h=k1_d=k1_a=None
        ok1 = sanitize_1x2(o1_h,o1_d,o1_a)
        if ok1:
            o1_h,o1_d,o1_a = ok1
            ev1_h,k1_h = ev_kelly_binary(sim["p_home"], o1_h)
            ev1_d,k1_d = ev_kelly_binary(sim["p_draw"], o1_d)
            ev1_a,k1_a = ev_kelly_binary(sim["p_away"], o1_a)
            if is_ev_outlier(max([x for x in (ev1_h,ev1_d,ev1_a) if x is not None], default=0)):
                ev1_h=ev1_d=ev1_a=k1_h=k1_d=k1_a=None

        # ===== Goals OU 主盘 =====
        ou_main_line   = odds.get("ou_main_line")
        ou_main_over   = odds.get("ou_main_over")
        ou_main_under  = odds.get("ou_main_under")
        ou_cnt_o       = odds.get("ou_main_over_cnt") or 0
        ou_cnt_u       = odds.get("ou_main_under_cnt") or 0
        ou_overround   = odds.get("ou_main_overround") or 9.9

        ev_main_over = ev_main_under = k_main_over = k_main_under = None
        if ou_main_line is not None and ou_main_over is not None and ou_main_under is not None:
            pair = sanitize_ou_pair(ou_main_over, ou_main_under)
            if pair and (not STRICT_OU_MAIN or (ou_cnt_o >= OU_MIN_CNT and ou_cnt_u >= OU_MIN_CNT and ou_overround <= OU_MAX_OR)):
                ou_main_over, ou_main_under = pair
                res = ou_ev_kelly_from_totals_quarter(float(ou_main_line), float(ou_main_over), float(ou_main_under), totals)
                ev_main_over, k_main_over = res["EV_over"],  res["Kelly_over"]
                ev_main_under, k_main_under = res["EV_under"], res["Kelly_under"]
                if is_ev_outlier(max([x for x in (ev_main_over, ev_main_under) if x is not None], default=0)):
                    ev_main_over = ev_main_under = k_main_over = k_main_under = None

        # ===== OU@2.5 参考 =====
        o25_over,o25_under = odds.get("ou_over_2_5"),odds.get("ou_under_2_5")
        ev25_over=ev25_under=k25_over=k25_under=None
        ok25 = sanitize_ou_pair(o25_over,o25_under)
        if ok25:
            o25_over,o25_under = ok25
            res25 = ou_ev_kelly_from_totals_quarter(2.5, float(o25_over), float(o25_under), totals)
            ev25_over, k25_over = res25["EV_over"],  res25["Kelly_over"]
            ev25_under, k25_under = res25["EV_under"], res25["Kelly_under"]
            if is_ev_outlier(max([x for x in (ev25_over,ev25_under) if x is not None], default=0)):
                ev25_over=ev25_under=k25_over=k25_under=None

        # ===== AH 全线（统一归一）
        ah_lines = build_ah_lines(odds)

        # ===== AH 主盘（缺就从全线里自选）
        ah_line, ah_oh, ah_oa = odds.get("ah_line"), odds.get("ah_home_odds"), odds.get("ah_away_odds")
        if ah_line is None or ah_oh is None or ah_oa is None:
            pick = select_best_ah_main(ah_lines, strict=STRICT_AH_MAIN)
            if pick:
                ah_line, ah_oh, ah_oa = pick

        ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None
        if ah_line is not None and ah_oh is not None and ah_oa is not None:
            cnt_ah_has_line += 1
            probs_ah = ah_probabilities_from_lams(lam_home, lam_away, h=float(ah_line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs_ah, odds_home=float(ah_oh), odds_away=float(ah_oa))
            if isinstance(evk.get("home"), dict):
                ev_ah_h, k_ah_h = evk["home"].get("EV"), evk["home"].get("Kelly")
            if isinstance(evk.get("away"), dict):
                ev_ah_a, k_ah_a = evk["away"].get("EV"), evk["away"].get("Kelly")
            if is_ev_outlier(max([x for x in (ev_ah_h, ev_ah_a) if x is not None], default=0)):
                ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None
            else:
                if ev_ah_h is not None: cnt_ah_ev_home += 1
                if ev_ah_a is not None: cnt_ah_ev_away += 1

        # ===== 角球 OU 主盘 =====
        crn_main_line  = odds.get("crn_main_line")
        crn_main_over  = odds.get("crn_main_over")
        crn_main_under = odds.get("crn_main_under")
        crn_cnt_o      = odds.get("crn_main_over_cnt") or 0
        crn_cnt_u      = odds.get("crn_main_under_cnt") or 0
        crn_overround  = odds.get("crn_main_overround") or 9.9

        ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None
        crn_totals_list: List[int] | None = None

        if crn_main_line is not None and crn_main_over is not None and crn_main_under is not None:
            pair = sanitize_ou_pair(crn_main_over, crn_main_under)
            if pair and (not STRICT_CRN_MAIN or (crn_cnt_o >= CRN_MIN_CNT and crn_cnt_u >= CRN_MIN_CNT and crn_overround <= CRN_MAX_OR)):
                crn_main_over, crn_main_under = pair
                lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
                crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
                crn_totals_list = [int(x) for x in crn_totals]
                resC = ou_ev_kelly_from_totals_quarter(float(crn_main_line), float(crn_main_over), float(crn_main_under), crn_totals_list)
                ev_crn_over, k_crn_over = resC["EV_over"],  resC["Kelly_over"]
                ev_crn_under, k_crn_under = resC["EV_under"], resC["Kelly_under"]
                if is_ev_outlier(max([x for x in (ev_crn_over,ev_crn_under) if x is not None], default=0)):
                    ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None

        # ===== 全线榜单池 & 盘口矩阵（优先使用 *_lines；无则回退 _raw_*） =====
        ou_lines = odds.get("ou_lines") or {}
        crn_lines = odds.get("crn_lines") or {}
        # —— AH 用统一归一后的
        #   ah_lines 已在上面 build_ah_lines(odds) 生成

        # 回退：当 *_lines 缺失时，从 _raw_* 现算（OU/CRN 保持原逻辑）
        if not ou_lines and odds.get("_raw_ou_map"):
            for line, sides in odds["_raw_ou_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                ou_lines[str(float(line))] = {"over_median": om, "under_median": um,
                                              "over_cnt": len(ov), "under_cnt": len(un), "overround": oround}
        if not crn_lines and odds.get("_raw_crn_map"):
            for line, sides in odds["_raw_crn_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                crn_lines[str(float(line))] = {"over_median": om, "under_median": um,
                                               "over_cnt": len(ov), "under_cnt": len(un), "overround": oround}

        # —— 全线榜单池（OU）
        for sline, info in (ou_lines.items() if isinstance(ou_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            if om is None or um is None or not (1.00 <= float(oround) <= 1.25): continue
            resL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), totals)
            if resL["EV_over"] is not None and resL["Kelly_over"] is not None:
                vi = value_index(resL["EV_over"], resL["Kelly_over"])
                ou_all_over.append((vi, home_name, away_name, line, float(om), resL["EV_over"], resL["Kelly_over"]))
            if resL["EV_under"] is not None and resL["Kelly_under"] is not None:
                vi = value_index(resL["EV_under"], resL["Kelly_under"])
                ou_all_under.append((vi, home_name, away_name, line, float(um), resL["EV_under"], resL["Kelly_under"]))

        # —— 全线榜单池（CRN）
        if crn_totals_list is None:
            lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
            crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
            crn_totals_list = [int(x) for x in crn_totals]
        for sline, info in (crn_lines.items() if isinstance(crn_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            if om is None or um is None or not (1.00 <= float(oround) <= 1.30): continue
            resCL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), crn_totals_list)
            if resCL["EV_over"] is not None and resCL["Kelly_over"] is not None:
                vi = value_index(resCL["EV_over"], resCL["Kelly_over"])
                crn_all_over.append((vi, home_name, away_name, line, float(om), resCL["EV_over"], resCL["Kelly_over"]))
            if resCL["EV_under"] is not None and resCL["Kelly_under"] is not None:
                vi = value_index(resCL["EV_under"], resCL["Kelly_under"])
                crn_all_under.append((vi, home_name, away_name, line, float(um), resCL["EV_under"], resCL["Kelly_under"]))

        # —— 全线榜单池（AH）
        for sline, info in (ah_lines.items() if isinstance(ah_lines, dict) else []):
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            oround = info.get("overround", 9.9)
            if oh is None or oa is None or not (1.00 <= float(oround) <= 1.25): continue
            probs = ah_probabilities_from_lams(lam_home, lam_away, h=float(line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs, odds_home=float(oh), odds_away=float(oa))
            if isinstance(evk.get("home"), dict) and evk["home"]["EV"] is not None and evk["home"]["Kelly"] is not None:
                vi = value_index(evk["home"]["EV"], evk["home"]["Kelly"])
                ah_all_home.append((vi, home_name, away_name, line, float(oh), evk["home"]["EV"], evk["home"]["Kelly"]))
            if isinstance(evk.get("away"), dict) and evk["away"]["EV"] is not None and evk["away"]["Kelly"] is not None:
                vi = value_index(evk["away"]["EV"], evk["away"]["Kelly"])
                ah_all_away.append((vi, home_name, away_name, line, float(oa), evk["away"]["EV"], evk["away"]["Kelly"]))

        # ===== 盘口矩阵（用 *_lines 导出） =====
        for sline, info in ou_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "OU", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })
        for sline, info in crn_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "CRN", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })
        for sline, info in ah_lines.items():
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            if oh is None or oa is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "AH", "line": float(line),
                "median_home": float(oh), "median_away": float(oa),
                "cnt_home": int(info.get("home_cnt", 0)), "cnt_away": int(info.get("away_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })

        # ===== 综合最佳 =====
        cands = []
        for label,ev,k in [
            ("1X2-Home", ev1_h, k1_h), ("1X2-Draw", ev1_d, k1_d), ("1X2-Away", ev1_a, k1_a),
            ("OU(main)-Over", ev_main_over, k_main_over), ("OU(main)-Under", ev_main_under, k_main_under),
            ("OU2.5-Over", ev25_over, k25_over), ("OU2.5-Under", ev25_under, k25_under),
            (f"AH({ah_line:+})-Home" if ah_line is not None else None, ev_ah_h, k_ah_h),
            (f"AH({ah_line:+})-Away" if ah_line is not None else None, ev_ah_a, k_ah_a),
            (f"CRN({crn_main_line})-Over" if crn_main_line is not None else None, ev_crn_over, k_crn_over),
            (f"CRN({crn_main_line})-Under" if crn_main_line is not None else None, ev_crn_under, k_crn_under),
        ]:
            if label and ev is not None and k is not None:
                cands.append((value_index(ev,k), label, ev, k))
        cands.sort(key=lambda x: x[0], reverse=True)
        best_label = cands[0][1] if cands else None
        best_ev    = cands[0][2] if cands else None
        best_kelly = cands[0][3] if cands else None

        # ===== 写行 =====
        rows_all.append({
            "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
            "home": home_name, "away": away_name,
            "lam_home": round(sim["lam_home"],3), "lam_away": round(sim["lam_away"],3),
            "p_home": round(sim["p_home"],4), "p_draw": round(sim["p_draw"],4), "p_away": round(sim["p_away"],4),
            "p_over2.5": round(sim["p_over"],4), "p_under2.5": round(sim["p_under"],4),

            # Goals OU 主盘（含诊断 + EV）
            "ou_main_line": ou_main_line,
            "odds_ou_main_over": ou_main_over, "odds_ou_main_under": ou_main_under,
            "ou_main_over_cnt": ou_cnt_o, "ou_main_under_cnt": ou_cnt_u, "ou_main_overround": ou_overround,
            "ev_ou_main_over": ev_main_over, "kelly_ou_main_over": k_main_over,
            "ev_ou_main_under": ev_main_under, "kelly_ou_main_under": k_main_under,

            # OU@2.5 参考
            "odds_ou_over2.5": odds.get("ou_over_2_5"), "odds_ou_under2.5": odds.get("ou_under_2_5"),
            "ev_ou_over2.5": ev25_over, "kelly_ou_over2.5": k25_over, "ev_ou_under2.5": ev25_under, "kelly_ou_under2.5": k25_under,

            # 1X2
            "odds_1x2_home": o1_h, "odds_1x2_draw": o1_d, "odds_1x2_away": o1_a,
            "ev_1x2_home": ev1_h, "kelly_1x2_home": k1_h,
            "ev_1x2_draw": ev1_d, "kelly_1x2_draw": k1_d,
            "ev_1x2_away": ev1_a, "kelly_1x2_away": k1_a,

            # AH（含诊断 + EV）
            "ah_line": ah_line, "odds_ah_home": ah_oh, "odds_ah_away": ah_oa,
            "ev_ah_home": ev_ah_h, "kelly_ah_home": k_ah_h,
            "ev_ah_away": ev_ah_a, "kelly_ah_away": k_ah_a,

            # Corners OU 主盘（含诊断 + EV）
            "crn_main_line": crn_main_line,
            "odds_crn_main_over": crn_main_over, "odds_crn_main_under": crn_main_under,
            "crn_main_over_cnt": crn_cnt_o, "crn_main_under_cnt": crn_cnt_u, "crn_main_overround": crn_overround,
            "ev_crn_main_over": ev_crn_over, "kelly_crn_main_over": k_crn_over,
            "ev_crn_main_under": ev_crn_under, "kelly_crn_main_under": k_crn_under,

            "best_market": best_label, "best_ev": best_ev, "best_kelly": best_kelly,
            "value_index": value_index(best_ev, best_kelly) if (best_ev is not None and best_kelly is not None) else None
        })

        done += 1
        if done % 30 == 0 or done == len(fixtures):
            print(f"……已处理 {done}/{len(fixtures)} 场")

    # ===== 导出全量 CSV =====
    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"daily_brief_{date_str}.csv")
    base_order = [
        "date_utc","kickoff_utc","league","home","away",
        "lam_home","lam_away","p_home","p_draw","p_away","p_over2.5","p_under2.5",
        "ou_main_line","odds_ou_main_over","odds_ou_main_under",
        "ou_main_over_cnt","ou_main_under_cnt","ou_main_overround",
        "ev_ou_main_over","kelly_ou_main_over","ev_ou_main_under","kelly_ou_main_under",
        "odds_ou_over2.5","odds_ou_under2.5","ev_ou_over2.5","kelly_ou_over2.5","ev_ou_under2.5","kelly_ou_under2.5",
        "odds_1x2_home","odds_1x2_draw","odds_1x2_away","ev_1x2_home","kelly_1x2_home","ev_1x2_draw","kelly_1x2_draw","ev_1x2_away","kelly_1x2_away",
        "ah_line","odds_ah_home","odds_ah_away","ev_ah_home","kelly_ah_home","ev_ah_away","kelly_ah_away",
        "crn_main_line","odds_crn_main_over","odds_crn_main_under","crn_main_over_cnt","crn_main_under_cnt","crn_main_overround",
        "ev_crn_main_over","kelly_crn_main_over","ev_crn_main_under","kelly_crn_main_under",
        "best_market","best_ev","best_kelly","value_index"
    ]
    all_keys=set(); [all_keys.update(r.keys()) for r in rows_all]
    fieldnames = [c for c in base_order if c in all_keys] + [c for c in all_keys if c not in base_order]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
        w.writeheader(); [w.writerow(r) for r in rows_all]
    print(f"\n已导出全量数据到: {out_file}")

    # ===== 导出盘口矩阵（来自 *_lines） =====
    out_mat = os.path.join(out_dir, f"daily_brief_matrix_{date_str}.csv")
    if matrix_rows:
        mat_fields = [
            "date_utc","kickoff_utc","league","home","away","market","line",
            "median_over","median_under","median_home","median_away",
            "cnt_over","cnt_under","cnt_home","cnt_away","overround"
        ]
        with open(out_mat, "w", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=mat_fields, extrasaction="ignore")
            w.writeheader(); [w.writerow(r) for r in matrix_rows]
        print(f"已导出盘口矩阵到: {out_mat}")
    else:
        print("未获取到盘口矩阵（ou_lines/crn_lines/ah_lines），跳过导出。")

    # ===== 榜单打印 =====
    def top_list(rows: List[Dict], key_ev: str, key_k: str, label: str, suffix_fn=None):
        items = []
        for r in rows:
            ev,k = r.get(key_ev), r.get(key_k)
            if ev is None or k is None or ev < MIN_EV: continue
            items.append((value_index(ev,k), r, ev, k))
        items.sort(key=lambda x: x[0], reverse=True)
        print(f"\n=== Top {min(TOP_K, len(items))}（{label}，EV≥{MIN_EV:.2f}） ===")
        for i,(_,r,ev,k) in enumerate(items[:TOP_K], 1):
            extra = suffix_fn(r) if suffix_fn else ""
            print(f"[{i:02d}] {r['home']} vs {r['away']} | EV={ev:.3f} Kelly≈{k:.3f} | {label}{(' ' + extra) if extra else ''}")

    # Suffix 生成（去掉多余空格）
    suf_ou_over  = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False)
    suf_ou_under = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False)
    suf_1x2_home = lambda r: f"@{float(r['odds_1x2_home']):.2f}" if r.get("odds_1x2_home") else ""
    suf_1x2_draw = lambda r: f"@{float(r['odds_1x2_draw']):.2f}" if r.get("odds_1x2_draw") else ""
    suf_1x2_away = lambda r: f"@{float(r['odds_1x2_away']):.2f}" if r.get("odds_1x2_away") else ""
    suf_ah_home  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_home"), "home")
    suf_ah_away  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_away"), "away")
    suf_cr_over  = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True)
    suf_cr_under = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True)

    top_list(rows_all, "ev_ou_main_over",  "kelly_ou_main_over",  "OU主盘-Over",  suf_ou_over)
    top_list(rows_all, "ev_ou_main_under", "kelly_ou_main_under", "OU主盘-Under", suf_ou_under)
    top_list(rows_all, "ev_1x2_home", "kelly_1x2_home", "1X2-主胜", suf_1x2_home)
    top_list(rows_all, "ev_1x2_draw", "kelly_1x2_draw", "1X2-平局", suf_1x2_draw)
    top_list(rows_all, "ev_1x2_away", "kelly_1x2_away", "1X2-客胜", suf_1x2_away)
    top_list(rows_all, "ev_ah_home", "kelly_ah_home", "AH-主方向", suf_ah_home)
    top_list(rows_all, "ev_ah_away", "kelly_ah_away", "AH-客方向", suf_ah_away)
    top_list(rows_all, "ev_crn_main_over",  "kelly_crn_main_over",  "角球主盘-Over",  suf_cr_over)
    top_list(rows_all, "ev_crn_main_under", "kelly_crn_main_under", "角球主盘-Under", suf_cr_under)

    # ===== 全线 Top（按 VI 排序）=====
    def print_ou_crn_allline_top(title: str, arr: List[tuple], tag="OU"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [(vi,h,a,line,od,ev,k) for (vi,h,a,line,od,ev,k) in arr if ev is not None and k is not None and ev >= MIN_EV]
        arr2.sort(key=lambda x: x[0], reverse=True)
        for i,(vi,h,a,line,od,ev,k) in enumerate(arr2[:TOP_K],1):
            print(f"[{i:02d}] {h} vs {a} | 线={line:g} | EV={ev:.3f} Kelly≈{k:.3f} | {title} {tag}{line:g}@{od:.2f}")

    def print_ah_allline_top(title: str, arr: List[tuple], side="home"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [(vi,h,a,line,od,ev,k) for (vi,h,a,line,od,ev,k) in arr if ev is not None and k is not None and ev >= MIN_EV]
        arr2.sort(key=lambda x: x[0], reverse=True)
        for i,(vi,h,a,line,od,ev,k) in enumerate(arr2[:TOP_K],1):
            adj = line if side=="home" else -line
            sign = "+" if adj>0 else ""
            print(f"[{i:02d}] {h} vs {a} | 线={adj:g} | EV={ev:.3f} Kelly≈{k:.3f} | {title} AH{sign}{adj:g}@{od:.2f}")

    if ou_all_over:  print_ou_crn_allline_top("进球OU-Over（全线）",  ou_all_over,  "OU")
    if ou_all_under: print_ou_crn_allline_top("进球OU-Under（全线）", ou_all_under, "OU")
    if crn_all_over: print_ou_crn_allline_top("角球OU-Over（全线）",  crn_all_over,  "CRN")
    if crn_all_under:print_ou_crn_allline_top("角球OU-Under（全线）", crn_all_under, "CRN")
    if ah_all_home: print_ah_allline_top("AH-主方向（全线）", ah_all_home, side="home")
    if ah_all_away: print_ah_allline_top("AH-客方向（全线）", ah_all_away, side="away")

    # AH 诊断
    print(f"\n[AH诊断] 有主盘线的比赛: {cnt_ah_has_line} 场；出现正EV(主): {cnt_ah_ev_home} 场；正EV(客): {cnt_ah_ev_away} 场")

    # 导出 picks.csv
    if EXPORT_PICKS:
        export_picks(rows_all, date_str)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print("程序异常：", e)
        traceback.print_exc()
