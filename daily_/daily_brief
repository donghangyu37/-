# === daily_brief.py · 每日情报站（并发/快速版 + 主盘OU/AH + 角球OU + 全线榜单 + 盘口矩阵 + picks.csv）===
from __future__ import annotations
from datetime import datetime, timezone
from typing import Dict, List, Tuple, Optional, Set
import math, os, csv, traceback, random

from concurrent.futures import ThreadPoolExecutor, as_completed
import numpy as np

# —— 项目内模块
from src.api.football_api import fixtures_by_date, team_statistics, odds_by_fixture, recent_fixtures_by_team
from src.data.transform import league_goal_averages
from src.models.poisson_mc import expected_goals_from_strengths, monte_carlo_simulate, simulate_goals
from src.markets.asian_handicap import ah_probabilities_from_lams, ah_ev_kelly
from src.config import HOME_ADV

# ================== 可调参数 ==================
FAST_MODE = 1
N_SIMS_GOALS   = 12000 if FAST_MODE else 25000
N_SIMS_CORNERS = 12000 if FAST_MODE else 25000
USE_RECENT = 0 if FAST_MODE else 1

CONCURRENCY = 6

# 主盘诊断阈值
STRICT_OU_MAIN  = 1; OU_MIN_CNT  = 3; OU_MAX_OR  = 1.12
STRICT_CRN_MAIN = 1; CRN_MIN_CNT = 3; CRN_MAX_OR = 1.20

# —— 新增：AH 主盘诊断阈值（与 OU/CRN 一致思路）
STRICT_AH_MAIN = 1     # 开启严格筛选：样本数与超盘限制
AH_MIN_CNT     = 3     # home/away 各至少多少条报价
AH_MAX_OR      = 1.20  # 超盘上限（1/oh + 1/oa）

# 联赛分层（用于 EV 阈值、共识要求）
ELITE_LEAGUE_KEYWORDS = {
    "premier league",
    "laliga",
    "la liga",
    "bundesliga",
    "serie a",
    "ligue 1",
    "champions league",
    "uefa champions",
    "europa league",
    "uefa europa",
    "conference league",
    "uefa conference",
}

BOOKMAKER_MIN = {"elite": 6, "secondary": 8}
BOOKMAKER_MIN_DERIV = 8

EV_POLICY = {
    "elite": {"keep_min": 0.02, "keep_max": 0.06, "review_max": 0.12, "discard_min": 0.12},
    "secondary": {"keep_min": 0.04, "keep_max": 0.10, "review_max": 0.15, "discard_min": 0.18},
}

EV_POLICY_DERIV = {"keep_min": 0.05, "keep_max": 0.12, "review_max": 0.18, "discard_min": 0.25}

VI_MIN_FOR_HIGH_EV = 0.05

# 异常 EV 拦截
def is_ev_outlier(ev: float) -> bool: return ev > 0.35

# 噪声赛事过滤
EXCLUDE_NOISY = 0
EXCLUDE_KEYS = ["u21","u23","res.","reserve","friendly","club friendlies"]

TOP_K  = 10
MIN_EV = 0.00

# 角球 λ 兜底
CORNER_BASE = 7.5
CORNER_PER_GOAL = 0.9

def _env_float(name: str, default: float) -> float:
    try:
        raw = os.getenv(name)
        if raw is None or raw == "":
            return float(default)
        return float(raw)
    except Exception:
        return float(default)

def _env_int(name: str, default: int) -> int:
    try:
        raw = os.getenv(name)
        if raw is None or raw == "":
            return int(default)
        return int(float(raw))
    except Exception:
        return int(default)

LAMBDA_MODEL_CONFIG = {
    "season": {
        "weight": _env_float("LAM_WEIGHT_SEASON", 0.6),
    },
    "recent": {
        "weight": _env_float("LAM_WEIGHT_RECENT", 0.4 if USE_RECENT else 0.0),
        "recent_games": _env_int("LAM_RECENT_GAMES", 6),
        "min_games": _env_int("LAM_RECENT_MIN_GAMES", 3),
        "decay": _env_float("LAM_RECENT_DECAY", 0.85),
        "fetch_last": _env_int("LAM_RECENT_FETCH_LAST", 12),
        "season_mix": _env_float("LAM_RECENT_SEASON_MIX", 0.3),
    },
}

if LAMBDA_MODEL_CONFIG["recent"]["min_games"] > LAMBDA_MODEL_CONFIG["recent"]["recent_games"]:
    LAMBDA_MODEL_CONFIG["recent"]["min_games"] = LAMBDA_MODEL_CONFIG["recent"]["recent_games"]

if LAMBDA_MODEL_CONFIG["recent"]["fetch_last"] < LAMBDA_MODEL_CONFIG["recent"]["recent_games"]:
    LAMBDA_MODEL_CONFIG["recent"]["fetch_last"] = LAMBDA_MODEL_CONFIG["recent"]["recent_games"]

LOG_LAMBDA_BLEND = _env_int("LAM_LOG_BLEND", 1)

# ================== 联赛分层 & EV 筛选 ==================
def classify_league(league_name: str) -> str:
    name_norm = str(league_name or "").lower()
    for token in ELITE_LEAGUE_KEYWORDS:
        if token in name_norm:
            return "elite"
    return "secondary"


def assess_market_ev(
    ev: Optional[float],
    market_type: str,
    league_tier: str,
    *,
    min_cnt: Optional[int] = None,
    overround: Optional[float] = None,
    vi: Optional[float] = None,
) -> tuple[str, Optional[str]]:
    if ev is None:
        return "skip", None
    try:
        ev_val = float(ev)
    except Exception:
        return "skip", None
    if not math.isfinite(ev_val) or ev_val <= 0:
        return "skip", None

    tier = league_tier if league_tier in EV_POLICY else "secondary"
    policy = EV_POLICY_DERIV if market_type == "crn" else EV_POLICY.get(tier, EV_POLICY["secondary"])
    needed_cnt = (
        BOOKMAKER_MIN_DERIV
        if market_type == "crn"
        else BOOKMAKER_MIN.get(tier, BOOKMAKER_MIN["secondary"])
    )
    if market_type == "1x2":
        needed_cnt = None  # 当前 API 不提供 1X2 的庄家数量

    cnt_val: Optional[int] = None
    if min_cnt is not None:
        try:
            cnt_val = int(min_cnt)
        except Exception:
            cnt_val = None

    if needed_cnt is not None and cnt_val is not None and cnt_val < needed_cnt:
        return "discard", f"样本不足({cnt_val}/{needed_cnt})"

    oround_val: Optional[float] = None
    if overround is not None:
        try:
            oround_val = float(overround)
        except Exception:
            oround_val = None
    if oround_val is not None:
        if not (1.02 <= oround_val <= 1.12):
            return "discard", f"超盘 {oround_val:.3f}"

    if ev_val > 0.20:
        return "discard", f"EV异常({ev_val:.3f})"

    if ev_val > 0.15:
        cnt_for_check = cnt_val if cnt_val is not None else 0
        vi_val = None
        if vi is not None:
            try:
                vi_val = float(vi)
            except Exception:
                vi_val = None
        if cnt_for_check < 8 or (vi_val is None or vi_val < VI_MIN_FOR_HIGH_EV):
            return "discard", f"高EV缺共识(EV={ev_val:.3f})"

    keep_min = float(policy.get("keep_min", 0.0))
    keep_max = float(policy.get("keep_max", keep_min))
    review_max = float(policy.get("review_max", keep_max))
    discard_min = float(policy.get("discard_min", float("inf")))

    if ev_val < keep_min:
        return "low", None

    if ev_val <= keep_max:
        return "keep", None

    if ev_val >= discard_min:
        return "discard", f"EV超限({ev_val:.3f})"

    if ev_val > review_max:
        return "review", f"EV高于人工复核区间({ev_val:.3f})"

    return "review", f"EV高于常态({ev_val:.3f})"

# ===== Picks 导出配置 =====
EXPORT_PICKS = 1
PICKS_TOP_N = 100
PICKS_MIN_EV = 0.05
PICKS_MIN_KELLY = 0.05
PICKS_MIN_VI = 0.00
KELLY_FRACTION = 0.25
STAKE_CAP_PCT = 2.0
STAKE_MIN_PCT = 0.0

# ================== 工具函数 ==================
def _today_utc_date() -> str:
    return datetime.now(timezone.utc).date().isoformat()

def sanitize_ou_pair(o_over: float | None, o_under: float | None) -> Tuple[float, float] | None:
    if o_over is None or o_under is None: return None
    try: oo, uu = float(o_over), float(o_under)
    except: return None
    if not (1.10 <= oo <= 50.0 and 1.10 <= uu <= 50.0): return None
    imp = 1/oo + 1/uu
    if not (1.00 <= imp <= 1.25): return None
    return oo, uu

def sanitize_1x2(o_h: float | None, o_d: float | None, o_a: float | None):
    try:
        if None in (o_h, o_d, o_a): return None
        oh, od, oa = float(o_h), float(o_d), float(o_a)
    except: return None
    if not all(1.10 <= v <= 100.0 for v in (oh, od, oa)): return None
    imp = 1/oh + 1/od + 1/oa
    if not (1.00 <= imp <= 1.30): return None
    return oh, od, oa

def ev_kelly_binary(p: float, odds: float) -> Tuple[float, float]:
    b = odds - 1.0
    EV = p*b - (1-p)
    K  = 0.0 if b<=0 else max(0.0, (b*p - (1-p))/b)
    return float(EV), float(K)

def value_index(ev: float | None, kelly: float | None) -> float:
    if ev is None or kelly is None: return -999.0
    return float(ev * math.sqrt(max(0.0, kelly)))

# ===== 四分之一盘精结算（基于 totals 样本）=====
def ou_ev_kelly_from_totals_quarter(line: float, over_odds: float, under_odds: float, totals) -> dict:
    if totals is None:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}
    try:
        totals_list = list(totals)
    except TypeError:
        totals_list = [totals]
    if len(totals_list) == 0:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}

    a = int(line // 1)
    frac = round(line - a, 2)
    n = len(totals_list)

    def counts_over(a, frac):
        if frac == 0.0:
            fw = sum(t > a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t > a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t >= a + 1 for t in totals_list) / n
            hl = sum(t == a for t in totals_list) / n
            fl = sum(t <= a - 1 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, 0.0, hl, fl + max(0.0, remain)
        elif frac == 0.75:
            fw = sum(t >= a + 2 for t in totals_list) / n
            hw = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t <= a for t in totals_list) / n
            remain = 1.0 - fw - hw - fl
            return fw, hw, remain, 0.0, fl
        else:
            fw = sum(t > line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    def counts_under(a, frac):
        if frac == 0.0:
            fw = sum(t < a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t < a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t < a for t in totals_list) / n
            hw = sum(t == a for t in totals_list) / n
            fl = sum(t >= a + 1 for t in totals_list) / n
            remain = max(0.0, 1.0 - fw - hw - fl)
            return fw, hw, remain, 0.0, fl
        elif frac == 0.75:
            fw = sum(t <= a for t in totals_list) / n
            hl = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t >= a + 2 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, remain, hl, fl
        else:
            fw = sum(t < line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    fw_o, hw_o, pu_o, hl_o, fl_o = counts_over(a, frac)
    fw_u, hw_u, pu_u, hl_u, fl_u = counts_under(a, frac)

    b_over  = max(0.0, over_odds - 1.0)
    b_under = max(0.0, under_odds - 1.0)

    EV_over  = fw_o*b_over + hw_o*(0.5*b_over) - hl_o*0.5 - fl_o*1.0
    EV_under = fw_u*b_under + hw_u*(0.5*b_under) - hl_u*0.5 - fl_u*1.0

    pwin_o, plose_o = fw_o + 0.5*hw_o, fl_o + 0.5*hl_o
    pwin_u, plose_u = fw_u + 0.5*hw_u, fl_u + 0.5*hl_u

    K_over  = 0.0 if b_over  <= 0 else max(0.0, (b_over*pwin_o  - plose_o)/b_over)
    K_under = 0.0 if b_under <= 0 else max(0.0, (b_under*pwin_u - plose_u)/b_under)

    return {"EV_over": float(EV_over), "Kelly_over": float(K_over),
            "EV_under": float(EV_under), "Kelly_under": float(K_under)}

def _regression_check_quarter_under() -> None:
    """Verify under-quarter lines treat integer totals as half wins."""
    totals = [1, 2, 3, 4]
    res = ou_ev_kelly_from_totals_quarter(2.25, 2.0, 2.0, totals)
    expected_ev_under = -0.125
    if not math.isclose(res["EV_under"], expected_ev_under, rel_tol=1e-12, abs_tol=1e-12):
        raise AssertionError(
            f"Quarter-line under regression failed: expected EV_under {expected_ev_under}, got {res['EV_under']}"
        )

# ================== 预取与缓存 ==================
TEAM_STATS_CACHE: dict[tuple[int,int,int], dict] = {}


def _has_goal_stats(stats: dict, side: str) -> bool:
    def _exists(path: List[str]) -> bool:
        cur = stats or {}
        for key in path:
            if not isinstance(cur, dict):
                return False
            cur = cur.get(key)
            if cur is None:
                return False
        try:
            float(cur)
        except Exception:
            return False
        return True

    target_side = "home" if str(side).lower().startswith("home") else "away"
    return _exists(["goals", "for", "average", target_side]) and _exists(["goals", "against", "average", target_side])

def prefetch_team_stats(fixtures: List[Dict]):
    tasks: Set[tuple[int,int,int]] = set()
    for fx in fixtures:
        try:
            lg = fx["league"]["id"]; ss = fx["league"]["season"]
            hid = fx["teams"]["home"]["id"]; aid = fx["teams"]["away"]["id"]
            tasks.add((lg, ss, hid)); tasks.add((lg, ss, aid))
        except: pass

    def _job(key):
        if key in TEAM_STATS_CACHE: return key, TEAM_STATS_CACHE[key]
        lg, ss, tid = key
        try:
            st = team_statistics(lg, ss, tid)
            TEAM_STATS_CACHE[key] = st or {}
            return key, TEAM_STATS_CACHE[key]
        except Exception:
            return key, {}

    if not tasks: return
    with ThreadPoolExecutor(max_workers=CONCURRENCY) as ex:
        futures = {ex.submit(_job, k): k for k in tasks}
        done = 0
        for _ in as_completed(futures):
            done += 1
            if done % 20 == 0 or done == len(tasks):
                print(f"……已预取球队统计 {done}/{len(tasks)}")

def compute_league_avg_from_cache(league_id: int, season: int) -> tuple[float, bool]:
    stats_list = []
    for (lg, ss, _tid), st in TEAM_STATS_CACHE.items():
        if lg == league_id and ss == season and st:
            stats_list.append(st)
    if not stats_list:
        return 2.6, True
    league_avg, _ = league_goal_averages(stats_list)
    if league_avg is None:
        return 2.6, True
    return float(league_avg), False

def estimate_corners_lambda_total(h_stats: dict, a_stats: dict, lam_home: float, lam_away: float) -> float:
    def _safe(path, d):
        cur = d
        for k in path:
            if not isinstance(cur, dict): return None
            cur = cur.get(k)
            if cur is None: return None
        try: return float(cur)
        except: return None
    h_c_home = _safe(["corners","for","average","home"], h_stats)
    a_c_away = _safe(["corners","for","average","away"], a_stats)
    if h_c_home and a_c_away and h_c_home > 0 and a_c_away > 0:
        return float(h_c_home + a_c_away)
    return float(CORNER_BASE + CORNER_PER_GOAL * (lam_home + lam_away))

# ================== λ 多模型融合 ==================
RECENT_FORM_CACHE: dict[tuple[int, int, int, int], List[Dict]] = {}

def _safe_stat(path: List[str], data: dict, default: float) -> float:
    cur = data or {}
    for key in path:
        if not isinstance(cur, dict):
            return float(default)
        cur = cur.get(key)
        if cur is None:
            return float(default)
    try:
        return float(cur)
    except Exception:
        return float(default)

def _fixture_timestamp(fixture: Dict) -> float:
    info = (fixture or {}).get("fixture") or {}
    ts = info.get("timestamp")
    if isinstance(ts, (int, float)):
        return float(ts)
    date_str = info.get("date")
    if isinstance(date_str, str):
        try:
            if date_str.endswith("Z"):
                date_str = date_str[:-1] + "+00:00"
            return datetime.fromisoformat(date_str).timestamp()
        except Exception:
            pass
    return 0.0

def _recent_weighted_avg(fixtures: List[Dict], team_id: int, want_home: bool, max_games: int, decay: float) -> tuple[Optional[float], Optional[float], int]:
    if max_games <= 0:
        return None, None, 0
    entries: List[tuple[float, float, float]] = []
    for fx in fixtures or []:
        teams = fx.get("teams") or {}
        home = (teams.get("home") or {}).get("id")
        away = (teams.get("away") or {}).get("id")
        if want_home:
            if home != team_id:
                continue
            g_for = (fx.get("goals") or {}).get("home")
            g_against = (fx.get("goals") or {}).get("away")
        else:
            if away != team_id:
                continue
            g_for = (fx.get("goals") or {}).get("away")
            g_against = (fx.get("goals") or {}).get("home")
        if g_for is None or g_against is None:
            score_ft = ((fx.get("score") or {}).get("fulltime") or {})
            if g_for is None:
                g_for = score_ft.get("home" if want_home else "away")
            if g_against is None:
                g_against = score_ft.get("away" if want_home else "home")
        try:
            gf_val = float(g_for)
            ga_val = float(g_against)
        except (TypeError, ValueError):
            continue
        entries.append((_fixture_timestamp(fx), gf_val, ga_val))

    if not entries:
        return None, None, 0

    entries.sort(key=lambda x: x[0], reverse=True)
    try:
        decay_val = float(decay)
    except Exception:
        decay_val = 0.85
    if decay_val <= 0:
        decay_val = 0.85
    if decay_val > 1:
        decay_val = 1.0

    weight_sum = 0.0
    gf_sum = 0.0
    ga_sum = 0.0
    used = 0
    for _, gf_val, ga_val in entries:
        weight = decay_val ** used
        gf_sum += weight * gf_val
        ga_sum += weight * ga_val
        weight_sum += weight
        used += 1
        if used >= max_games:
            break

    if weight_sum <= 0:
        return None, None, used

    return gf_sum / weight_sum, ga_sum / weight_sum, used

def fetch_recent_form(team_id: int, league_id: int, season: int, fetch_last: int) -> List[Dict]:
    key = (league_id, season, team_id, fetch_last)
    if key in RECENT_FORM_CACHE:
        return RECENT_FORM_CACHE[key]
    try:
        fixtures = recent_fixtures_by_team(team_id=team_id, season=season, last=fetch_last, league_id=league_id)
    except Exception as e:
        fixtures = []
        if LOG_LAMBDA_BLEND:
            print(f"[λ模型] 获取近况赛程失败 team={team_id}: {e}")
    RECENT_FORM_CACHE[key] = fixtures or []
    return RECENT_FORM_CACHE[key]

def _blend_recent_value(recent_val: Optional[float], fallback_val: float, mix: float) -> float:
    if fallback_val is None and recent_val is None:
        return 0.0
    if recent_val is None:
        return float(fallback_val)
    if fallback_val is None:
        return float(recent_val)
    mix_clamped = max(0.0, min(1.0, float(mix)))
    return float(mix_clamped * float(fallback_val) + (1.0 - mix_clamped) * float(recent_val))

def lambda_from_season_stats(h_stats: dict, a_stats: dict, league_avg: float, home_adv: float) -> tuple[tuple[float, float], dict]:
    denom = max(float(league_avg or 0.0), 1e-6)
    h_gf_home = _safe_stat(["goals","for","average","home"], h_stats, 1.3)
    h_ga_home = _safe_stat(["goals","against","average","home"], h_stats, 1.3)
    a_gf_away = _safe_stat(["goals","for","average","away"], a_stats, 1.3)
    a_ga_away = _safe_stat(["goals","against","average","away"], a_stats, 1.3)

    h_att = max(0.05, h_gf_home) / denom
    h_def = max(0.05, h_ga_home) / denom
    a_att = max(0.05, a_gf_away) / denom
    a_def = max(0.05, a_ga_away) / denom

    lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, home_adv)
    meta = {
        "h_att": float(h_att),
        "h_def": float(h_def),
        "a_att": float(a_att),
        "a_def": float(a_def),
        "h_for_avg": float(h_gf_home),
        "h_against_avg": float(h_ga_home),
        "a_for_avg": float(a_gf_away),
        "a_against_avg": float(a_ga_away),
    }
    return (float(lam_home), float(lam_away)), meta

def lambda_from_recent_form(
    home_id: int,
    away_id: int,
    league_id: int,
    season: int,
    league_avg: float,
    home_adv: float,
    season_meta: dict,
    config: dict,
) -> tuple[tuple[float, float], dict]:
    recent_games = max(1, int(config.get("recent_games", 6)))
    min_games = max(1, int(config.get("min_games", 3)))
    if min_games > recent_games:
        min_games = recent_games
    try:
        decay = float(config.get("decay", 0.85))
    except Exception:
        decay = 0.85
    fetch_last = int(config.get("fetch_last", recent_games))
    fetch_last = max(fetch_last, recent_games * 2)

    home_fixtures = fetch_recent_form(home_id, league_id, season, fetch_last)
    away_fixtures = fetch_recent_form(away_id, league_id, season, fetch_last)

    h_recent_for, h_recent_against, cnt_home = _recent_weighted_avg(home_fixtures, home_id, True, recent_games, decay)
    a_recent_for, a_recent_against, cnt_away = _recent_weighted_avg(away_fixtures, away_id, False, recent_games, decay)

    coverage_home = min(1.0, cnt_home / recent_games) if recent_games else 0.0
    coverage_away = min(1.0, cnt_away / recent_games) if recent_games else 0.0

    try:
        base_mix = float(config.get("season_mix", 0.3))
    except Exception:
        base_mix = 0.3
    base_mix = max(0.0, min(1.0, base_mix))

    def _effective_mix(base: float, coverage: float, enough_games: bool) -> float:
        if not enough_games:
            return 1.0
        return base + (1.0 - coverage) * (1.0 - base)

    eff_mix_home = _effective_mix(base_mix, coverage_home, cnt_home >= min_games)
    eff_mix_away = _effective_mix(base_mix, coverage_away, cnt_away >= min_games)

    fallback_h_for = max(0.05, float(season_meta.get("h_for_avg", league_avg)))
    fallback_h_against = max(0.05, float(season_meta.get("h_against_avg", league_avg)))
    fallback_a_for = max(0.05, float(season_meta.get("a_for_avg", league_avg)))
    fallback_a_against = max(0.05, float(season_meta.get("a_against_avg", league_avg)))

    h_for_blend = max(0.05, _blend_recent_value(h_recent_for, fallback_h_for, eff_mix_home))
    h_against_blend = max(0.05, _blend_recent_value(h_recent_against, fallback_h_against, eff_mix_home))
    a_for_blend = max(0.05, _blend_recent_value(a_recent_for, fallback_a_for, eff_mix_away))
    a_against_blend = max(0.05, _blend_recent_value(a_recent_against, fallback_a_against, eff_mix_away))

    denom = max(float(league_avg or 0.0), 1e-6)
    h_att = h_for_blend / denom
    h_def = h_against_blend / denom
    a_att = a_for_blend / denom
    a_def = a_against_blend / denom

    lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, home_adv)
    meta = {
        "home_games_used": int(cnt_home),
        "away_games_used": int(cnt_away),
        "home_recent_for": None if h_recent_for is None else float(h_recent_for),
        "home_recent_against": None if h_recent_against is None else float(h_recent_against),
        "away_recent_for": None if a_recent_for is None else float(a_recent_for),
        "away_recent_against": None if a_recent_against is None else float(a_recent_against),
        "home_eff_mix": float(eff_mix_home),
        "away_eff_mix": float(eff_mix_away),
    }
    return (float(lam_home), float(lam_away)), meta

def compute_lambda_models(
    league_id: int,
    season: int,
    home_id: int,
    away_id: int,
    h_stats: dict,
    a_stats: dict,
    league_avg: float,
) -> Dict[str, dict]:
    models: Dict[str, dict] = {}
    (lam_season, lam_season_away), season_meta = lambda_from_season_stats(h_stats, a_stats, league_avg, HOME_ADV)
    models["season"] = {
        "lam_home": lam_season,
        "lam_away": lam_season_away,
        "meta": season_meta,
    }

    recent_cfg = LAMBDA_MODEL_CONFIG.get("recent") or {}
    if float(recent_cfg.get("weight", 0.0)) > 0:
        try:
            (lam_recent, lam_recent_away), recent_meta = lambda_from_recent_form(
                home_id, away_id, league_id, season, league_avg, HOME_ADV, season_meta, recent_cfg
            )
            models["recent"] = {
                "lam_home": lam_recent,
                "lam_away": lam_recent_away,
                "meta": recent_meta,
            }
        except Exception as e:
            if LOG_LAMBDA_BLEND:
                print(f"[λ模型] 近况模型计算失败 {home_id}-{away_id}: {e}")
    return models

def blend_lambda_models(models: Dict[str, dict], config: Dict[str, dict]) -> tuple[float, float, Dict[str, float]]:
    valid = {
        name: data
        for name, data in models.items()
        if isinstance(data, dict) and data.get("lam_home") is not None and data.get("lam_away") is not None
    }
    if not valid:
        raise RuntimeError("无可用 λ 模型")

    weights_used: Dict[str, float] = {}
    weighted_home = 0.0
    weighted_away = 0.0
    for name, data in valid.items():
        weight = float((config.get(name) or {}).get("weight", 0.0))
        if weight <= 0:
            continue
        lam_h = float(data.get("lam_home", 0.0))
        lam_a = float(data.get("lam_away", 0.0))
        weights_used[name] = weight
        weighted_home += weight * lam_h
        weighted_away += weight * lam_a

    if not weights_used:
        first_name, data = next(iter(valid.items()))
        fallback_weights = {name: (1.0 if name == first_name else 0.0) for name in valid}
        return float(data.get("lam_home", 1.4)), float(data.get("lam_away", 1.1)), fallback_weights

    total_weight = sum(weights_used.values()) or 1.0
    lam_home = weighted_home / total_weight
    lam_away = weighted_away / total_weight
    normalized = {name: (weights_used.get(name, 0.0) / total_weight) for name in valid}
    return float(lam_home), float(lam_away), normalized

def format_lambda_detail(models: Dict[str, dict], weights: Dict[str, float]) -> str:
    parts: List[str] = []
    for name, data in models.items():
        lam_h = data.get("lam_home")
        lam_a = data.get("lam_away")
        if lam_h is None or lam_a is None:
            continue
        weight = weights.get(name, 0.0)
        parts.append(f"{name}:{float(lam_h):.3f}/{float(lam_a):.3f} (w={weight:.2f})")
    return " | ".join(parts)

def log_lambda_blend(home_name: str, away_name: str, models: Dict[str, dict], weights: Dict[str, float], lam_home: float, lam_away: float) -> None:
    entries = []
    for name, data in models.items():
        lam_h = data.get("lam_home")
        lam_a = data.get("lam_away")
        if lam_h is None or lam_a is None:
            continue
        raw_weight = float((LAMBDA_MODEL_CONFIG.get(name) or {}).get("weight", 0.0))
        norm_weight = weights.get(name, 0.0)
        meta = data.get("meta") or {}
        extra = ""
        if name == "recent":
            extra = (
                f" cntH={meta.get('home_games_used', 0)} cntA={meta.get('away_games_used', 0)}"
                f" mixH={meta.get('home_eff_mix', 0):.2f} mixA={meta.get('away_eff_mix', 0):.2f}"
            )
        entries.append(
            f"{name}:λ=({float(lam_h):.2f},{float(lam_a):.2f}) w_cfg={raw_weight:.2f} w_norm={norm_weight:.2f}{extra}"
        )
    detail = " | ".join(entries)
    print(f"[λ模型] {home_name} vs {away_name} -> {detail} => blend=({lam_home:.2f},{lam_away:.2f})")

# ================== 打印 & 导出工具 ==================
def _fmt_ou_book(line, odds, is_corner=False):
    if line is None or odds is None: return ""
    tag = "CRN" if is_corner else "OU"
    try: return f"{tag}{float(line):g}@{float(odds):.2f}"
    except: return ""

def _fmt_ah_book(home_line, odds, side: str):
    if home_line is None or odds is None: return ""
    try:
        ln = float(home_line)
        ln_side = ln if side.lower()=="home" else -ln
        sign = "+" if ln_side > 0 else ""
        return f"AH{sign}{ln_side:g}@{float(odds):.2f}"
    except: return ""

def _stake_pct_from_kelly(k: Optional[float]) -> float:
    try:
        if k is None: return 0.0
        pct = 100.0 * float(k) * float(KELLY_FRACTION)
        return float(min(STAKE_CAP_PCT, max(STAKE_MIN_PCT, round(pct, 2))))
    except: return 0.0

def export_picks(rows_all: List[Dict], date_str: str):
    picks: List[Dict] = []
    for r in rows_all:
        league_tier = r.get("league_tier") or classify_league(r.get("league"))
        kelly_cap = 0.08 if league_tier == "elite" else 0.05

        base = {
            "date_utc": r.get("date_utc"),
            "kickoff_utc": r.get("kickoff_utc"),
            "league": r.get("league"),
            "league_tier": league_tier,
            "home": r.get("home"),
            "away": r.get("away"),
        }

        def _add_pick(market: str, ev_val, k_val, book: Optional[str], status_key: Optional[str]) -> None:
            if ev_val is None or k_val is None or not book:
                return
            if status_key and r.get(status_key) != "keep":
                return
            try:
                ev_f = float(ev_val)
                k_f = max(0.0, float(k_val))
            except Exception:
                return
            k_eff = min(k_f, kelly_cap)
            if ev_f < PICKS_MIN_EV or k_eff < PICKS_MIN_KELLY:
                return
            vi_eff = value_index(ev_f, k_eff)
            if vi_eff < PICKS_MIN_VI:
                return
            picks.append({
                **base,
                "market": market,
                "book": book,
                "ev": float(ev_f),
                "kelly": float(k_eff),
                "value_index": float(vi_eff),
                "stake_pct": _stake_pct_from_kelly(k_eff),
            })

        # Goals OU 主盘
        _add_pick(
            "OU-Over",
            r.get("ev_ou_main_over"),
            r.get("kelly_ou_main_over"),
            _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False),
            "status_ou_main_over",
        )
        _add_pick(
            "OU-Under",
            r.get("ev_ou_main_under"),
            r.get("kelly_ou_main_under"),
            _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False),
            "status_ou_main_under",
        )

        # 1X2
        for mk, evk, kel, odd, status_key in [
            ("1X2-Home", r.get("ev_1x2_home"), r.get("kelly_1x2_home"), r.get("odds_1x2_home"), "status_1x2_home"),
            ("1X2-Draw", r.get("ev_1x2_draw"), r.get("kelly_1x2_draw"), r.get("odds_1x2_draw"), "status_1x2_draw"),
            ("1X2-Away", r.get("ev_1x2_away"), r.get("kelly_1x2_away"), r.get("odds_1x2_away"), "status_1x2_away"),
        ]:
            book = None
            if odd is not None:
                try:
                    book = f"{mk}@{float(odd):.2f}"
                except Exception:
                    book = None
            _add_pick(mk, evk, kel, book, status_key)

        # AH 主盘
        ah_line = r.get("ah_line")
        if ah_line is not None:
            _add_pick(
                "AH-Home",
                r.get("ev_ah_home"),
                r.get("kelly_ah_home"),
                _fmt_ah_book(ah_line, r.get("odds_ah_home"), "home"),
                "status_ah_home",
            )
            _add_pick(
                "AH-Away",
                r.get("ev_ah_away"),
                r.get("kelly_ah_away"),
                _fmt_ah_book(ah_line, r.get("odds_ah_away"), "away"),
                "status_ah_away",
            )

        # 角球 OU 主盘
        _add_pick(
            "CRN-Over",
            r.get("ev_crn_main_over"),
            r.get("kelly_crn_main_over"),
            _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True),
            "status_crn_main_over",
        )
        _add_pick(
            "CRN-Under",
            r.get("ev_crn_main_under"),
            r.get("kelly_crn_main_under"),
            _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True),
            "status_crn_main_under",
        )

    picks.sort(key=lambda x: x.get("value_index", -999), reverse=True)
    if PICKS_TOP_N is not None:
        picks = picks[:int(PICKS_TOP_N)]

    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"picks_{date_str}.csv")
    fieldnames = ["date_utc","kickoff_utc","league","home","away","market","book","ev","kelly","value_index","stake_pct"]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames); w.writeheader(); [w.writerow(p) for p in picks]
    print(f"\n已导出下注清单到: {out_file}  （{len(picks)} 条，阈值：EV≥{PICKS_MIN_EV}, Kelly≥{PICKS_MIN_KELLY}, VI≥{PICKS_MIN_VI}）")

def _median(arr: List[float]) -> Optional[float]:
    arr = [float(x) for x in arr if x];
    if not arr: return None
    arr.sort(); n=len(arr)
    return arr[n//2] if n%2==1 else 0.5*(arr[n//2-1]+arr[n//2])

def _ou_overround(oo: float, uu: float) -> float:
    try: return 1.0/float(oo) + 1.0/float(uu)
    except: return 9.9

# —— 新增：通用小工具 & AH 全线归一 & 主盘选择 —— #
def _to_float(x, default=None):
    try:
        if isinstance(x, str):
            x = x.replace("+", "")
        return float(x)
    except:
        return default

def build_ah_lines(odds: dict) -> dict:
    """
    统一把 AH 全线提取/归一（支持多个可能的键名和数据形态）：
    输出:
      { "0.25": {"home_median":..., "away_median":..., "home_cnt":..., "away_cnt":..., "overround":...}, ... }
    """
    if not isinstance(odds, dict):
        return {}

    # 1) 已有标准结构
    if isinstance(odds.get("ah_lines"), dict) and odds["ah_lines"]:
        return odds["ah_lines"]

    # 2) 多候选键名（容错）
    cand_keys = ["_raw_ah_map", "ah_raw_map", "asian_handicap_map", "asian_map", "AH", "ah"]
    raw = None
    for k in cand_keys:
        if isinstance(odds.get(k), dict) and odds[k]:
            raw = odds[k]; break
    if raw is None:
        return {}

    out = {}
    for line_key, sides in raw.items():
        ln = _to_float(line_key, default=None)
        if ln is None or not isinstance(sides, dict):
            continue

        hs = sides.get("home")
        as_ = sides.get("away")

        # 支持“列表/单值”
        if isinstance(hs, (list, tuple)):
            hs = [_to_float(v) for v in hs if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oh = _median(hs)
            cnt_h = len(hs)
        else:
            oh = _to_float(hs)
            cnt_h = 1 if oh is not None else 0

        if isinstance(as_, (list, tuple)):
            as_ = [_to_float(v) for v in as_ if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oa = _median(as_)
            cnt_a = len(as_)
        else:
            oa = _to_float(as_)
            cnt_a = 1 if oa is not None else 0

        if oh is None or oa is None:
            continue

        oround = _ou_overround(oh, oa)
        out[str(float(ln))] = {
            "home_median": float(oh), "away_median": float(oa),
            "home_cnt": int(cnt_h), "away_cnt": int(cnt_a),
            "overround": float(oround)
        }
    return out


def _lookup_line_info(lines: dict, target: float) -> dict:
    if not isinstance(lines, dict) or target is None:
        return {}
    try:
        target_val = float(target)
    except Exception:
        return {}
    for key, info in lines.items():
        try:
            if abs(float(key) - target_val) < 1e-6:
                return info or {}
        except Exception:
            continue
    return {}

def select_best_ah_main(ah_lines: dict, strict: int = 1) -> tuple[float, float, float] | None:
    """
    从 ah_lines 中挑“主盘”：优先低超盘、样本多、|line|小。
    返回 (line, home_odds, away_odds) 或 None
    """
    if not isinstance(ah_lines, dict) or not ah_lines:
        return None

    cands = []
    for sline, info in ah_lines.items():
        ln = _to_float(sline, default=None)
        oh = _to_float((info or {}).get("home_median"), default=None)
        oa = _to_float((info or {}).get("away_median"), default=None)
        if ln is None or oh is None or oa is None:
            continue
        cnt_h = int((info or {}).get("home_cnt", 0) or 0)
        cnt_a = int((info or {}).get("away_cnt", 0) or 0)
        oround = _to_float((info or {}).get("overround"), default=9.9)

        if strict:
            if min(cnt_h, cnt_a) < AH_MIN_CNT:
                continue
            if not (1.00 <= oround <= AH_MAX_OR):
                continue

        cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        # 放宽再挑一次
        for sline, info in ah_lines.items():
            ln = _to_float(sline, default=None)
            oh = _to_float((info or {}).get("home_median"), default=None)
            oa = _to_float((info or {}).get("away_median"), default=None)
            if ln is None or oh is None or oa is None:
                continue
            cnt_h = int((info or {}).get("home_cnt", 0) or 0)
            cnt_a = int((info or {}).get("away_cnt", 0) or 0)
            oround = _to_float((info or {}).get("overround"), default=9.9)
            cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        return None

    cands.sort()
    _, _, _, ln, oh, oa = cands[0]
    return (float(ln), float(oh), float(oa))

# ================== 主流程 ==================
def main():
    random.seed(42); np.random.seed(42)
    date_str = _today_utc_date()
    print(f"=== 37号 · 每日情报站（并发/快速版）@ {date_str} ===")

    fixtures = fixtures_by_date(date_str)
    if not fixtures:
        print("该日期无赛程或 API 无返回。"); return

    if EXCLUDE_NOISY:
        kept = []
        for fx in fixtures:
            lgname = ((fx.get("league") or {}).get("name") or "").lower()
            if not any(k in lgname for k in EXCLUDE_KEYS):
                kept.append(fx)
        fixtures = kept
    print(f"拉取赛程：{len(fixtures)} 场。正在预取球队统计…")

    prefetch_team_stats(fixtures)

    rows_all: List[Dict] = []
    matrix_rows: List[Dict] = []

    # 全线榜单池
    ou_all_over, ou_all_under = [], []
    crn_all_over, crn_all_under = [], []
    ah_all_home, ah_all_away = [], []

    # 诊断计数
    cnt_ah_has_line = cnt_ah_ev_home = cnt_ah_ev_away = 0
    cnt_skipped_stats = 0
    cnt_ev_review = cnt_ev_discard = 0

    done = 0
    for fx in fixtures:
        try:
            league = fx["league"]; league_id = league["id"]; season = league["season"]
            league_name = league.get("name")
            fixture_info = fx.get("fixture", {}); kickoff_utc = fixture_info.get("date"); fx_id = fixture_info.get("id")
            home = fx["teams"]["home"]; away = fx["teams"]["away"]
            home_id, away_id = home["id"], away["id"]
            home_name, away_name = home["name"], away["name"]
        except Exception as e:
            print(f"跳过一场（解析失败）：{e}"); continue

        league_tier = classify_league(league_name)

        league_avg, league_avg_fallback = compute_league_avg_from_cache(league_id, season)

        h_st = TEAM_STATS_CACHE.get((league_id, season, home_id), {}) or {}
        a_st = TEAM_STATS_CACHE.get((league_id, season, away_id), {}) or {}

        missing_bits = []
        if league_avg_fallback:
            missing_bits.append("联赛均值缺失")
        if not h_st or not _has_goal_stats(h_st, "home"):
            missing_bits.append("主队赛季场均进球数据缺失")
        if not a_st or not _has_goal_stats(a_st, "away"):
            missing_bits.append("客队赛季场均进球数据缺失")
        if missing_bits:
            cnt_skipped_stats += 1
            print(f"[数据缺失] {home_name} vs {away_name}：{'，'.join(missing_bits)} —— 跳过")
            continue

        lambda_models = compute_lambda_models(
            league_id=league_id,
            season=season,
            home_id=home_id,
            away_id=away_id,
            h_stats=h_st,
            a_stats=a_st,
            league_avg=league_avg,
        )
        lam_home, lam_away, lam_weights = blend_lambda_models(lambda_models, LAMBDA_MODEL_CONFIG)
        lam_detail = format_lambda_detail(lambda_models, lam_weights)
        if LOG_LAMBDA_BLEND:
            log_lambda_blend(home_name, away_name, lambda_models, lam_weights, lam_home, lam_away)

        sim = monte_carlo_simulate(lam_home, lam_away, n_sims=N_SIMS_GOALS, over_line=2.5)
        _, _, totals = simulate_goals(lam_home, lam_away, n_sims=N_SIMS_GOALS)
        try: totals = [int(x) for x in totals]
        except: totals = [int(totals)]

        odds = odds_by_fixture(fx_id) if fx_id else {}

        # ===== 1X2 =====
        o1_h,o1_d,o1_a = odds.get("1x2_home"),odds.get("1x2_draw"),odds.get("1x2_away")
        ev1_h=ev1_d=ev1_a=k1_h=k1_d=k1_a=None
        ok1 = sanitize_1x2(o1_h,o1_d,o1_a)
        if ok1:
            o1_h,o1_d,o1_a = ok1
            ev1_h,k1_h = ev_kelly_binary(sim["p_home"], o1_h)
            ev1_d,k1_d = ev_kelly_binary(sim["p_draw"], o1_d)
            ev1_a,k1_a = ev_kelly_binary(sim["p_away"], o1_a)
            if is_ev_outlier(max([x for x in (ev1_h,ev1_d,ev1_a) if x is not None], default=0)):
                ev1_h=ev1_d=ev1_a=k1_h=k1_d=k1_a=None

        # ===== Goals OU 主盘 =====
        ou_main_line   = odds.get("ou_main_line")
        ou_main_over   = odds.get("ou_main_over")
        ou_main_under  = odds.get("ou_main_under")
        ou_cnt_o       = odds.get("ou_main_over_cnt") or 0
        ou_cnt_u       = odds.get("ou_main_under_cnt") or 0
        ou_overround   = odds.get("ou_main_overround") or 9.9

        ev_main_over = ev_main_under = k_main_over = k_main_under = None
        if ou_main_line is not None and ou_main_over is not None and ou_main_under is not None:
            pair = sanitize_ou_pair(ou_main_over, ou_main_under)
            if pair and (not STRICT_OU_MAIN or (ou_cnt_o >= OU_MIN_CNT and ou_cnt_u >= OU_MIN_CNT and ou_overround <= OU_MAX_OR)):
                ou_main_over, ou_main_under = pair
                res = ou_ev_kelly_from_totals_quarter(float(ou_main_line), float(ou_main_over), float(ou_main_under), totals)
                ev_main_over, k_main_over = res["EV_over"],  res["Kelly_over"]
                ev_main_under, k_main_under = res["EV_under"], res["Kelly_under"]
                if is_ev_outlier(max([x for x in (ev_main_over, ev_main_under) if x is not None], default=0)):
                    ev_main_over = ev_main_under = k_main_over = k_main_under = None

        # ===== OU@2.5 参考 =====
        o25_over,o25_under = odds.get("ou_over_2_5"),odds.get("ou_under_2_5")
        ev25_over=ev25_under=k25_over=k25_under=None
        ok25 = sanitize_ou_pair(o25_over,o25_under)
        if ok25:
            o25_over,o25_under = ok25
            res25 = ou_ev_kelly_from_totals_quarter(2.5, float(o25_over), float(o25_under), totals)
            ev25_over, k25_over = res25["EV_over"],  res25["Kelly_over"]
            ev25_under, k25_under = res25["EV_under"], res25["Kelly_under"]
            if is_ev_outlier(max([x for x in (ev25_over,ev25_under) if x is not None], default=0)):
                ev25_over=ev25_under=k25_over=k25_under=None

        # ===== AH 全线（统一归一）
        ah_lines = build_ah_lines(odds)

        # ===== AH 主盘（缺就从全线里自选）
        ah_line, ah_oh, ah_oa = odds.get("ah_line"), odds.get("ah_home_odds"), odds.get("ah_away_odds")
        if ah_line is None or ah_oh is None or ah_oa is None:
            pick = select_best_ah_main(ah_lines, strict=STRICT_AH_MAIN)
            if pick:
                ah_line, ah_oh, ah_oa = pick

        ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None
        if ah_line is not None and ah_oh is not None and ah_oa is not None:
            cnt_ah_has_line += 1
            probs_ah = ah_probabilities_from_lams(lam_home, lam_away, h=float(ah_line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs_ah, odds_home=float(ah_oh), odds_away=float(ah_oa))
            if isinstance(evk.get("home"), dict):
                ev_ah_h, k_ah_h = evk["home"].get("EV"), evk["home"].get("Kelly")
            if isinstance(evk.get("away"), dict):
                ev_ah_a, k_ah_a = evk["away"].get("EV"), evk["away"].get("Kelly")
            if is_ev_outlier(max([x for x in (ev_ah_h, ev_ah_a) if x is not None], default=0)):
                ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None

        # ===== 角球 OU 主盘 =====
        crn_main_line  = odds.get("crn_main_line")
        crn_main_over  = odds.get("crn_main_over")
        crn_main_under = odds.get("crn_main_under")
        crn_cnt_o      = odds.get("crn_main_over_cnt") or 0
        crn_cnt_u      = odds.get("crn_main_under_cnt") or 0
        crn_overround  = odds.get("crn_main_overround") or 9.9

        ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None
        crn_totals_list: List[int] | None = None

        if crn_main_line is not None and crn_main_over is not None and crn_main_under is not None:
            pair = sanitize_ou_pair(crn_main_over, crn_main_under)
            if pair and (not STRICT_CRN_MAIN or (crn_cnt_o >= CRN_MIN_CNT and crn_cnt_u >= CRN_MIN_CNT and crn_overround <= CRN_MAX_OR)):
                crn_main_over, crn_main_under = pair
                lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
                crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
                crn_totals_list = [int(x) for x in crn_totals]
                resC = ou_ev_kelly_from_totals_quarter(float(crn_main_line), float(crn_main_over), float(crn_main_under), crn_totals_list)
                ev_crn_over, k_crn_over = resC["EV_over"],  resC["Kelly_over"]
                ev_crn_under, k_crn_under = resC["EV_under"], resC["Kelly_under"]
                if is_ev_outlier(max([x for x in (ev_crn_over,ev_crn_under) if x is not None], default=0)):
                    ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None

        # ===== EV 筛选与诊断 =====
        def _calc_vi(ev_val, k_val):
            if ev_val is None or k_val is None:
                return None
            try:
                return value_index(ev_val, k_val)
            except Exception:
                return None

        vi_main_over = _calc_vi(ev_main_over, k_main_over)
        vi_main_under = _calc_vi(ev_main_under, k_main_under)
        vi_25_over = _calc_vi(ev25_over, k25_over)
        vi_25_under = _calc_vi(ev25_under, k25_under)
        vi_1x2_home = _calc_vi(ev1_h, k1_h)
        vi_1x2_draw = _calc_vi(ev1_d, k1_d)
        vi_1x2_away = _calc_vi(ev1_a, k1_a)
        vi_ah_home = _calc_vi(ev_ah_h, k_ah_h)
        vi_ah_away = _calc_vi(ev_ah_a, k_ah_a)
        vi_crn_over = _calc_vi(ev_crn_over, k_crn_over)
        vi_crn_under = _calc_vi(ev_crn_under, k_crn_under)

        overround_1x2 = None
        if o1_h and o1_d and o1_a:
            try:
                overround_1x2 = 1.0 / float(o1_h) + 1.0 / float(o1_d) + 1.0 / float(o1_a)
            except Exception:
                overround_1x2 = None

        ah_cnt_h = odds.get("ah_home_cnt")
        ah_cnt_a = odds.get("ah_away_cnt")
        ah_overround = odds.get("ah_overround")
        if (ah_cnt_h is None or ah_cnt_a is None or ah_overround is None) and ah_line is not None:
            info = _lookup_line_info(ah_lines, ah_line)
            if ah_cnt_h is None:
                ah_cnt_h = info.get("home_cnt")
            if ah_cnt_a is None:
                ah_cnt_a = info.get("away_cnt")
            if ah_overround is None:
                ah_overround = info.get("overround")

        status_map: Dict[str, str] = {}
        ev_notes: List[str] = []

        def _record_status(key: str, label: str, status: str, note: Optional[str]):
            nonlocal cnt_ev_review, cnt_ev_discard
            if status:
                status_map[key] = status
                if status == "review":
                    cnt_ev_review += 1
                elif status == "discard":
                    cnt_ev_discard += 1
            if note:
                ev_notes.append(f"{label}{note}")

        ou_min_cnt = min(int(ou_cnt_o or 0), int(ou_cnt_u or 0)) if (ou_cnt_o is not None and ou_cnt_u is not None) else None
        status, note = assess_market_ev(ev_main_over, "ou", league_tier, min_cnt=ou_min_cnt, overround=ou_overround, vi=vi_main_over)
        _record_status("ou_main_over", "OU主盘Over：", status, note)
        status, note = assess_market_ev(ev_main_under, "ou", league_tier, min_cnt=ou_min_cnt, overround=ou_overround, vi=vi_main_under)
        _record_status("ou_main_under", "OU主盘Under：", status, note)

        status, note = assess_market_ev(ev25_over, "ou", league_tier, min_cnt=ou_min_cnt, overround=ou_overround, vi=vi_25_over)
        _record_status("ou_2_5_over", "OU@2.5 Over：", status, note)
        status, note = assess_market_ev(ev25_under, "ou", league_tier, min_cnt=ou_min_cnt, overround=ou_overround, vi=vi_25_under)
        _record_status("ou_2_5_under", "OU@2.5 Under：", status, note)

        status, note = assess_market_ev(ev1_h, "1x2", league_tier, overround=overround_1x2, vi=vi_1x2_home)
        _record_status("1x2_home", "1X2-主胜：", status, note)
        status, note = assess_market_ev(ev1_d, "1x2", league_tier, overround=overround_1x2, vi=vi_1x2_draw)
        _record_status("1x2_draw", "1X2-平局：", status, note)
        status, note = assess_market_ev(ev1_a, "1x2", league_tier, overround=overround_1x2, vi=vi_1x2_away)
        _record_status("1x2_away", "1X2-客胜：", status, note)

        ah_min_cnt = min(int(ah_cnt_h or 0), int(ah_cnt_a or 0)) if (ah_cnt_h is not None and ah_cnt_a is not None) else None
        status, note = assess_market_ev(ev_ah_h, "ah", league_tier, min_cnt=ah_min_cnt, overround=ah_overround, vi=vi_ah_home)
        _record_status("ah_home", "AH-主：", status, note)
        status, note = assess_market_ev(ev_ah_a, "ah", league_tier, min_cnt=ah_min_cnt, overround=ah_overround, vi=vi_ah_away)
        _record_status("ah_away", "AH-客：", status, note)

        crn_min_cnt = min(int(crn_cnt_o or 0), int(crn_cnt_u or 0)) if (crn_cnt_o is not None and crn_cnt_u is not None) else None
        status, note = assess_market_ev(ev_crn_over, "crn", league_tier, min_cnt=crn_min_cnt, overround=crn_overround, vi=vi_crn_over)
        _record_status("crn_main_over", "角球Over：", status, note)
        status, note = assess_market_ev(ev_crn_under, "crn", league_tier, min_cnt=crn_min_cnt, overround=crn_overround, vi=vi_crn_under)
        _record_status("crn_main_under", "角球Under：", status, note)

        if status_map.get("ah_home") == "keep":
            cnt_ah_ev_home += 1
        if status_map.get("ah_away") == "keep":
            cnt_ah_ev_away += 1

        # ===== 全线榜单池 & 盘口矩阵（优先使用 *_lines；无则回退 _raw_*） =====
        ou_lines = odds.get("ou_lines") or {}
        crn_lines = odds.get("crn_lines") or {}
        # —— AH 用统一归一后的
        #   ah_lines 已在上面 build_ah_lines(odds) 生成

        # 回退：当 *_lines 缺失时，从 _raw_* 现算（OU/CRN 保持原逻辑）
        if not ou_lines and odds.get("_raw_ou_map"):
            for line, sides in odds["_raw_ou_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                ou_lines[str(float(line))] = {"over_median": om, "under_median": um,
                                              "over_cnt": len(ov), "under_cnt": len(un), "overround": oround}
        if not crn_lines and odds.get("_raw_crn_map"):
            for line, sides in odds["_raw_crn_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                crn_lines[str(float(line))] = {"over_median": om, "under_median": um,
                                               "over_cnt": len(ov), "under_cnt": len(un), "overround": oround}

        # —— 全线榜单池（OU）
        for sline, info in (ou_lines.items() if isinstance(ou_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            if om is None or um is None or not (1.00 <= float(oround) <= 1.25): continue
            resL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), totals)
            if resL["EV_over"] is not None and resL["Kelly_over"] is not None:
                vi = value_index(resL["EV_over"], resL["Kelly_over"])
                ou_all_over.append((vi, home_name, away_name, line, float(om), resL["EV_over"], resL["Kelly_over"]))
            if resL["EV_under"] is not None and resL["Kelly_under"] is not None:
                vi = value_index(resL["EV_under"], resL["Kelly_under"])
                ou_all_under.append((vi, home_name, away_name, line, float(um), resL["EV_under"], resL["Kelly_under"]))

        # —— 全线榜单池（CRN）
        if crn_totals_list is None:
            lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
            crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
            crn_totals_list = [int(x) for x in crn_totals]
        for sline, info in (crn_lines.items() if isinstance(crn_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            if om is None or um is None or not (1.00 <= float(oround) <= 1.30): continue
            resCL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), crn_totals_list)
            if resCL["EV_over"] is not None and resCL["Kelly_over"] is not None:
                vi = value_index(resCL["EV_over"], resCL["Kelly_over"])
                crn_all_over.append((vi, home_name, away_name, line, float(om), resCL["EV_over"], resCL["Kelly_over"]))
            if resCL["EV_under"] is not None and resCL["Kelly_under"] is not None:
                vi = value_index(resCL["EV_under"], resCL["Kelly_under"])
                crn_all_under.append((vi, home_name, away_name, line, float(um), resCL["EV_under"], resCL["Kelly_under"]))

        # —— 全线榜单池（AH）
        for sline, info in (ah_lines.items() if isinstance(ah_lines, dict) else []):
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            oround = info.get("overround", 9.9)
            if oh is None or oa is None or not (1.00 <= float(oround) <= 1.25): continue
            probs = ah_probabilities_from_lams(lam_home, lam_away, h=float(line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs, odds_home=float(oh), odds_away=float(oa))
            if isinstance(evk.get("home"), dict) and evk["home"]["EV"] is not None and evk["home"]["Kelly"] is not None:
                vi = value_index(evk["home"]["EV"], evk["home"]["Kelly"])
                ah_all_home.append((vi, home_name, away_name, line, float(oh), evk["home"]["EV"], evk["home"]["Kelly"]))
            if isinstance(evk.get("away"), dict) and evk["away"]["EV"] is not None and evk["away"]["Kelly"] is not None:
                vi = value_index(evk["away"]["EV"], evk["away"]["Kelly"])
                ah_all_away.append((vi, home_name, away_name, line, float(oa), evk["away"]["EV"], evk["away"]["Kelly"]))

        # ===== 盘口矩阵（用 *_lines 导出） =====
        for sline, info in ou_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "OU", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })
        for sline, info in crn_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "CRN", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })
        for sline, info in ah_lines.items():
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            if oh is None or oa is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "AH", "line": float(line),
                "median_home": float(oh), "median_away": float(oa),
                "cnt_home": int(info.get("home_cnt", 0)), "cnt_away": int(info.get("away_cnt", 0)),
                "overround": float(info.get("overround", 9.9))
            })

        # ===== 综合最佳 =====
        cands = []

        def _maybe_add(label: Optional[str], ev_val, k_val, vi_val, status_key: str):
            if not label or ev_val is None or k_val is None:
                return
            if status_map.get(status_key) != "keep":
                return
            score = vi_val if vi_val is not None else value_index(ev_val, k_val)
            cands.append((score, label, ev_val, k_val))

        _maybe_add("1X2-Home", ev1_h, k1_h, vi_1x2_home, "1x2_home")
        _maybe_add("1X2-Draw", ev1_d, k1_d, vi_1x2_draw, "1x2_draw")
        _maybe_add("1X2-Away", ev1_a, k1_a, vi_1x2_away, "1x2_away")
        _maybe_add("OU(main)-Over", ev_main_over, k_main_over, vi_main_over, "ou_main_over")
        _maybe_add("OU(main)-Under", ev_main_under, k_main_under, vi_main_under, "ou_main_under")
        _maybe_add("OU2.5-Over", ev25_over, k25_over, vi_25_over, "ou_2_5_over")
        _maybe_add("OU2.5-Under", ev25_under, k25_under, vi_25_under, "ou_2_5_under")
        _maybe_add(f"AH({ah_line:+})-Home" if ah_line is not None else None, ev_ah_h, k_ah_h, vi_ah_home, "ah_home")
        _maybe_add(f"AH({ah_line:+})-Away" if ah_line is not None else None, ev_ah_a, k_ah_a, vi_ah_away, "ah_away")
        _maybe_add(f"CRN({crn_main_line})-Over" if crn_main_line is not None else None, ev_crn_over, k_crn_over, vi_crn_over, "crn_main_over")
        _maybe_add(f"CRN({crn_main_line})-Under" if crn_main_line is not None else None, ev_crn_under, k_crn_under, vi_crn_under, "crn_main_under")
        cands.sort(key=lambda x: x[0], reverse=True)
        best_label = cands[0][1] if cands else None
        best_ev    = cands[0][2] if cands else None
        best_kelly = cands[0][3] if cands else None

        # ===== 写行 =====
        weight_fields = {
            f"lam_weight_{name}": round(lam_weights.get(name, 0.0), 3)
            for name, data in lambda_models.items()
            if data.get("lam_home") is not None and data.get("lam_away") is not None
        }

        ah_cnt_h_int = int(ah_cnt_h) if ah_cnt_h is not None else None
        ah_cnt_a_int = int(ah_cnt_a) if ah_cnt_a is not None else None
        ah_overround_val = float(ah_overround) if ah_overround is not None else None
        ev_alerts_str = " | ".join(ev_notes) if ev_notes else None

        row = {
            "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
            "home": home_name, "away": away_name,
            "league_tier": league_tier,
            "lam_home": round(lam_home,3), "lam_away": round(lam_away,3),
            "p_home": round(sim["p_home"],4), "p_draw": round(sim["p_draw"],4), "p_away": round(sim["p_away"],4),
            "p_over2.5": round(sim["p_over"],4), "p_under2.5": round(sim["p_under"],4),

            # Goals OU 主盘（含诊断 + EV）
            "ou_main_line": ou_main_line,
            "odds_ou_main_over": ou_main_over, "odds_ou_main_under": ou_main_under,
            "ou_main_over_cnt": ou_cnt_o, "ou_main_under_cnt": ou_cnt_u, "ou_main_overround": ou_overround,
            "ev_ou_main_over": ev_main_over, "kelly_ou_main_over": k_main_over, "vi_ou_main_over": vi_main_over,
            "ev_ou_main_under": ev_main_under, "kelly_ou_main_under": k_main_under, "vi_ou_main_under": vi_main_under,
            "status_ou_main_over": status_map.get("ou_main_over"),
            "status_ou_main_under": status_map.get("ou_main_under"),

            # OU@2.5 参考
            "odds_ou_over2.5": odds.get("ou_over_2_5"), "odds_ou_under2.5": odds.get("ou_under_2_5"),
            "ev_ou_over2.5": ev25_over, "kelly_ou_over2.5": k25_over, "vi_ou_over2.5": vi_25_over,
            "ev_ou_under2.5": ev25_under, "kelly_ou_under2.5": k25_under, "vi_ou_under2.5": vi_25_under,
            "status_ou_over2.5": status_map.get("ou_2_5_over"),
            "status_ou_under2.5": status_map.get("ou_2_5_under"),

            # 1X2
            "odds_1x2_home": o1_h, "odds_1x2_draw": o1_d, "odds_1x2_away": o1_a,
            "ev_1x2_home": ev1_h, "kelly_1x2_home": k1_h, "vi_1x2_home": vi_1x2_home,
            "ev_1x2_draw": ev1_d, "kelly_1x2_draw": k1_d, "vi_1x2_draw": vi_1x2_draw,
            "ev_1x2_away": ev1_a, "kelly_1x2_away": k1_a, "vi_1x2_away": vi_1x2_away,
            "status_1x2_home": status_map.get("1x2_home"),
            "status_1x2_draw": status_map.get("1x2_draw"),
            "status_1x2_away": status_map.get("1x2_away"),

            # AH（含诊断 + EV）
            "ah_line": ah_line, "odds_ah_home": ah_oh, "odds_ah_away": ah_oa,
            "ah_home_cnt": ah_cnt_h_int, "ah_away_cnt": ah_cnt_a_int, "ah_overround": ah_overround_val,
            "ev_ah_home": ev_ah_h, "kelly_ah_home": k_ah_h, "vi_ah_home": vi_ah_home,
            "ev_ah_away": ev_ah_a, "kelly_ah_away": k_ah_a, "vi_ah_away": vi_ah_away,
            "status_ah_home": status_map.get("ah_home"),
            "status_ah_away": status_map.get("ah_away"),

            # Corners OU 主盘（含诊断 + EV）
            "crn_main_line": crn_main_line,
            "odds_crn_main_over": crn_main_over, "odds_crn_main_under": crn_main_under,
            "crn_main_over_cnt": crn_cnt_o, "crn_main_under_cnt": crn_cnt_u, "crn_main_overround": crn_overround,
            "ev_crn_main_over": ev_crn_over, "kelly_crn_main_over": k_crn_over, "vi_crn_main_over": vi_crn_over,
            "ev_crn_main_under": ev_crn_under, "kelly_crn_main_under": k_crn_under, "vi_crn_main_under": vi_crn_under,
            "status_crn_main_over": status_map.get("crn_main_over"),
            "status_crn_main_under": status_map.get("crn_main_under"),

            "best_market": best_label, "best_ev": best_ev, "best_kelly": best_kelly,
            "value_index": value_index(best_ev, best_kelly) if (best_ev is not None and best_kelly is not None) else None,
            "ev_alerts": ev_alerts_str,
        }

        if lam_detail:
            row["lam_blend_detail"] = lam_detail
        for k, v in weight_fields.items():
            row[k] = v

        rows_all.append(row)

        done += 1
        if done % 30 == 0 or done == len(fixtures):
            print(f"……已处理 {done}/{len(fixtures)} 场")

    # ===== 导出全量 CSV =====
    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"daily_brief_{date_str}.csv")
    base_order = [
        "date_utc","kickoff_utc","league","league_tier","home","away",
        "lam_home","lam_away","lam_weight_season","lam_weight_recent","lam_blend_detail",
        "p_home","p_draw","p_away","p_over2.5","p_under2.5",
        "ou_main_line","odds_ou_main_over","odds_ou_main_under",
        "ou_main_over_cnt","ou_main_under_cnt","ou_main_overround",
        "ev_ou_main_over","kelly_ou_main_over","vi_ou_main_over","status_ou_main_over",
        "ev_ou_main_under","kelly_ou_main_under","vi_ou_main_under","status_ou_main_under",
        "odds_ou_over2.5","odds_ou_under2.5",
        "ev_ou_over2.5","kelly_ou_over2.5","vi_ou_over2.5","status_ou_over2.5",
        "ev_ou_under2.5","kelly_ou_under2.5","vi_ou_under2.5","status_ou_under2.5",
        "odds_1x2_home","odds_1x2_draw","odds_1x2_away",
        "ev_1x2_home","kelly_1x2_home","vi_1x2_home","status_1x2_home",
        "ev_1x2_draw","kelly_1x2_draw","vi_1x2_draw","status_1x2_draw",
        "ev_1x2_away","kelly_1x2_away","vi_1x2_away","status_1x2_away",
        "ah_line","odds_ah_home","odds_ah_away","ah_home_cnt","ah_away_cnt","ah_overround",
        "ev_ah_home","kelly_ah_home","vi_ah_home","status_ah_home",
        "ev_ah_away","kelly_ah_away","vi_ah_away","status_ah_away",
        "crn_main_line","odds_crn_main_over","odds_crn_main_under","crn_main_over_cnt","crn_main_under_cnt","crn_main_overround",
        "ev_crn_main_over","kelly_crn_main_over","vi_crn_main_over","status_crn_main_over",
        "ev_crn_main_under","kelly_crn_main_under","vi_crn_main_under","status_crn_main_under",
        "best_market","best_ev","best_kelly","value_index","ev_alerts"
    ]
    all_keys=set(); [all_keys.update(r.keys()) for r in rows_all]
    fieldnames = [c for c in base_order if c in all_keys] + [c for c in all_keys if c not in base_order]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
        w.writeheader(); [w.writerow(r) for r in rows_all]
    print(f"\n已导出全量数据到: {out_file}")

    # ===== 导出盘口矩阵（来自 *_lines） =====
    out_mat = os.path.join(out_dir, f"daily_brief_matrix_{date_str}.csv")
    if matrix_rows:
        mat_fields = [
            "date_utc","kickoff_utc","league","home","away","market","line",
            "median_over","median_under","median_home","median_away",
            "cnt_over","cnt_under","cnt_home","cnt_away","overround"
        ]
        with open(out_mat, "w", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=mat_fields, extrasaction="ignore")
            w.writeheader(); [w.writerow(r) for r in matrix_rows]
        print(f"已导出盘口矩阵到: {out_mat}")
    else:
        print("未获取到盘口矩阵（ou_lines/crn_lines/ah_lines），跳过导出。")

    # ===== 榜单打印 =====
    def top_list(rows: List[Dict], key_ev: str, key_k: str, label: str, suffix_fn=None, status_key: Optional[str] = None, vi_key: Optional[str] = None):
        items = []
        for r in rows:
            ev,k = r.get(key_ev), r.get(key_k)
            if ev is None or k is None or ev < MIN_EV: continue
            if status_key and r.get(status_key) != "keep": continue
            score = r.get(vi_key) if vi_key else None
            if score is None:
                score = value_index(ev,k)
            items.append((score, r, ev, k))
        items.sort(key=lambda x: x[0], reverse=True)
        print(f"\n=== Top {min(TOP_K, len(items))}（{label}，EV≥{MIN_EV:.2f}） ===")
        for i,(_,r,ev,k) in enumerate(items[:TOP_K], 1):
            extra = suffix_fn(r) if suffix_fn else ""
            print(f"[{i:02d}] {r['home']} vs {r['away']} | EV={ev:.3f} Kelly≈{k:.3f} | {label}{(' ' + extra) if extra else ''}")

    # Suffix 生成（去掉多余空格）
    suf_ou_over  = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False)
    suf_ou_under = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False)
    suf_1x2_home = lambda r: f"@{float(r['odds_1x2_home']):.2f}" if r.get("odds_1x2_home") else ""
    suf_1x2_draw = lambda r: f"@{float(r['odds_1x2_draw']):.2f}" if r.get("odds_1x2_draw") else ""
    suf_1x2_away = lambda r: f"@{float(r['odds_1x2_away']):.2f}" if r.get("odds_1x2_away") else ""
    suf_ah_home  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_home"), "home")
    suf_ah_away  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_away"), "away")
    suf_cr_over  = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True)
    suf_cr_under = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True)

    top_list(rows_all, "ev_ou_main_over",  "kelly_ou_main_over",  "OU主盘-Over",  suf_ou_over, status_key="status_ou_main_over", vi_key="vi_ou_main_over")
    top_list(rows_all, "ev_ou_main_under", "kelly_ou_main_under", "OU主盘-Under", suf_ou_under, status_key="status_ou_main_under", vi_key="vi_ou_main_under")
    top_list(rows_all, "ev_1x2_home", "kelly_1x2_home", "1X2-主胜", suf_1x2_home, status_key="status_1x2_home", vi_key="vi_1x2_home")
    top_list(rows_all, "ev_1x2_draw", "kelly_1x2_draw", "1X2-平局", suf_1x2_draw, status_key="status_1x2_draw", vi_key="vi_1x2_draw")
    top_list(rows_all, "ev_1x2_away", "kelly_1x2_away", "1X2-客胜", suf_1x2_away, status_key="status_1x2_away", vi_key="vi_1x2_away")
    top_list(rows_all, "ev_ah_home", "kelly_ah_home", "AH-主方向", suf_ah_home, status_key="status_ah_home", vi_key="vi_ah_home")
    top_list(rows_all, "ev_ah_away", "kelly_ah_away", "AH-客方向", suf_ah_away, status_key="status_ah_away", vi_key="vi_ah_away")
    top_list(rows_all, "ev_crn_main_over",  "kelly_crn_main_over",  "角球主盘-Over",  suf_cr_over, status_key="status_crn_main_over", vi_key="vi_crn_main_over")
    top_list(rows_all, "ev_crn_main_under", "kelly_crn_main_under", "角球主盘-Under", suf_cr_under, status_key="status_crn_main_under", vi_key="vi_crn_main_under")

    # ===== 全线 Top（按 VI 排序）=====
    def print_ou_crn_allline_top(title: str, arr: List[tuple], tag="OU"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [(vi,h,a,line,od,ev,k) for (vi,h,a,line,od,ev,k) in arr if ev is not None and k is not None and ev >= MIN_EV]
        arr2.sort(key=lambda x: x[0], reverse=True)
        for i,(vi,h,a,line,od,ev,k) in enumerate(arr2[:TOP_K],1):
            print(f"[{i:02d}] {h} vs {a} | 线={line:g} | EV={ev:.3f} Kelly≈{k:.3f} | {title} {tag}{line:g}@{od:.2f}")

    def print_ah_allline_top(title: str, arr: List[tuple], side="home"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [(vi,h,a,line,od,ev,k) for (vi,h,a,line,od,ev,k) in arr if ev is not None and k is not None and ev >= MIN_EV]
        arr2.sort(key=lambda x: x[0], reverse=True)
        for i,(vi,h,a,line,od,ev,k) in enumerate(arr2[:TOP_K],1):
            adj = line if side=="home" else -line
            sign = "+" if adj>0 else ""
            print(f"[{i:02d}] {h} vs {a} | 线={adj:g} | EV={ev:.3f} Kelly≈{k:.3f} | {title} AH{sign}{adj:g}@{od:.2f}")

    if ou_all_over:  print_ou_crn_allline_top("进球OU-Over（全线）",  ou_all_over,  "OU")
    if ou_all_under: print_ou_crn_allline_top("进球OU-Under（全线）", ou_all_under, "OU")
    if crn_all_over: print_ou_crn_allline_top("角球OU-Over（全线）",  crn_all_over,  "CRN")
    if crn_all_under:print_ou_crn_allline_top("角球OU-Under（全线）", crn_all_under, "CRN")
    if ah_all_home: print_ah_allline_top("AH-主方向（全线）", ah_all_home, side="home")
    if ah_all_away: print_ah_allline_top("AH-客方向（全线）", ah_all_away, side="away")

    print(f"\n[数据筛选] 缺统计跳过: {cnt_skipped_stats} 场；EV标记需复核: {cnt_ev_review} 条；剔除: {cnt_ev_discard} 条")

    # AH 诊断
    print(f"\n[AH诊断] 有主盘线的比赛: {cnt_ah_has_line} 场；出现正EV(主): {cnt_ah_ev_home} 场；正EV(客): {cnt_ah_ev_away} 场")

    # 导出 picks.csv
    if EXPORT_PICKS:
        export_picks(rows_all, date_str)

if __name__ == "__main__":
    try:
        if os.environ.get("DAILY_BRIEF_SELFTEST") == "1":
            _regression_check_quarter_under()
        main()
    except Exception as e:
        print("程序异常：", e)
        traceback.print_exc()
