# === daily_brief.py · 每日情报站（并发/快速版 + 主盘OU/AH + 角球OU + 全线榜单 + 盘口矩阵 + picks.csv）===
from __future__ import annotations
from datetime import datetime, timezone
from typing import Dict, List, Tuple, Optional, Set
import math, os, csv, traceback, random
from dataclasses import dataclass

from concurrent.futures import ThreadPoolExecutor, as_completed
import numpy as np

# —— 项目内模块
from src.api.football_api import fixtures_by_date, team_statistics, odds_by_fixture, recent_fixtures_by_team
from src.data.transform import league_goal_averages
from src.models.poisson_mc import expected_goals_from_strengths, monte_carlo_simulate, simulate_goals
from src.markets.asian_handicap import ah_probabilities_from_lams, ah_ev_kelly
from src.config import HOME_ADV

# ================== 可调参数 ==================
FAST_MODE = 1
N_SIMS_GOALS   = 12000 if FAST_MODE else 25000
N_SIMS_CORNERS = 12000 if FAST_MODE else 25000
USE_RECENT = 0 if FAST_MODE else 1

CONCURRENCY = 6

# 主盘诊断阈值
STRICT_OU_MAIN  = 1; OU_MIN_CNT  = 3; OU_MAX_OR  = 1.12
STRICT_CRN_MAIN = 1; CRN_MIN_CNT = 3; CRN_MAX_OR = 1.20

# —— 新增：AH 主盘诊断阈值（与 OU/CRN 一致思路）
STRICT_AH_MAIN = 1     # 开启严格筛选：样本数与超盘限制
AH_MIN_CNT     = 3     # home/away 各至少多少条报价
AH_MAX_OR      = 1.20  # 超盘上限（1/oh + 1/oa）

# 异常 EV 拦截
def is_ev_outlier(ev: float) -> bool: return ev > 0.35

# 噪声赛事过滤
EXCLUDE_NOISY = 0
EXCLUDE_KEYS = ["u21","u23","res.","reserve","friendly","club friendlies"]

TOP_K  = 10
MIN_EV = 0.00

# 角球 λ 兜底
CORNER_BASE = 7.5
CORNER_PER_GOAL = 0.9

# ===== 联赛层级与EV阈值配置 =====
TOP_TIER_LEAGUE_IDS = {
    2,   # Champions League
    3,   # Europa League
    5,   # Europa Conference League
    39,  # Premier League
    61,  # Ligue 1
    78,  # Bundesliga
    135, # Serie A
    140, # La Liga
}

TOP_TIER_KEYWORDS = {
    "premier league",
    "la liga",
    "bundesliga",
    "serie a",
    "ligue 1",
    "champions league",
    "europa league",
    "conference league",
}


@dataclass(frozen=True)
class EVThreshold:
    keep_min: float
    preferred_max: float
    review_max: float
    drop_max: float


EV_THRESHOLDS: Dict[Tuple[str, str], EVThreshold] = {
    ("top", "1x2"): EVThreshold(0.02, 0.06, 0.12, 0.12),
    ("top", "ou"):  EVThreshold(0.02, 0.06, 0.12, 0.12),
    ("top", "ah"):  EVThreshold(0.02, 0.06, 0.12, 0.12),
    ("top", "derivative"): EVThreshold(0.05, 0.12, 0.18, 0.25),

    ("other", "1x2"): EVThreshold(0.04, 0.10, 0.15, 0.18),
    ("other", "ou"):  EVThreshold(0.04, 0.10, 0.15, 0.18),
    ("other", "ah"):  EVThreshold(0.04, 0.10, 0.15, 0.18),
    ("other", "derivative"): EVThreshold(0.05, 0.12, 0.18, 0.25),
}

def _env_float(name: str, default: float) -> float:
    try:
        raw = os.getenv(name)
        if raw is None or raw == "":
            return float(default)
        return float(raw)
    except Exception:
        return float(default)

def _env_int(name: str, default: int) -> int:
    try:
        raw = os.getenv(name)
        if raw is None or raw == "":
            return int(default)
        return int(float(raw))
    except Exception:
        return int(default)

LAMBDA_MODEL_CONFIG = {
    "season": {
        "weight": _env_float("LAM_WEIGHT_SEASON", 0.6),
    },
    "recent": {
        "weight": _env_float("LAM_WEIGHT_RECENT", 0.4 if USE_RECENT else 0.0),
        "recent_games": _env_int("LAM_RECENT_GAMES", 6),
        "min_games": _env_int("LAM_RECENT_MIN_GAMES", 3),
        "decay": _env_float("LAM_RECENT_DECAY", 0.85),
        "fetch_last": _env_int("LAM_RECENT_FETCH_LAST", 12),
        "season_mix": _env_float("LAM_RECENT_SEASON_MIX", 0.3),
    },
}

if LAMBDA_MODEL_CONFIG["recent"]["min_games"] > LAMBDA_MODEL_CONFIG["recent"]["recent_games"]:
    LAMBDA_MODEL_CONFIG["recent"]["min_games"] = LAMBDA_MODEL_CONFIG["recent"]["recent_games"]

if LAMBDA_MODEL_CONFIG["recent"]["fetch_last"] < LAMBDA_MODEL_CONFIG["recent"]["recent_games"]:
    LAMBDA_MODEL_CONFIG["recent"]["fetch_last"] = LAMBDA_MODEL_CONFIG["recent"]["recent_games"]

LOG_LAMBDA_BLEND = _env_int("LAM_LOG_BLEND", 1)

# ===== Picks 导出配置 =====
EXPORT_PICKS = 1
PICKS_TOP_N = 100
PICKS_MIN_EV = 0.05
PICKS_MIN_KELLY = 0.05
PICKS_MIN_VI = 0.00
KELLY_FRACTION = 0.25
STAKE_CAP_PCT = 2.0
STAKE_MIN_PCT = 0.0

# ================== 工具函数 ==================
def _today_utc_date() -> str:
    return datetime.now(timezone.utc).date().isoformat()

def sanitize_ou_pair(o_over: float | None, o_under: float | None) -> Tuple[float, float] | None:
    if o_over is None or o_under is None: return None
    try: oo, uu = float(o_over), float(o_under)
    except: return None
    if not (1.10 <= oo <= 50.0 and 1.10 <= uu <= 50.0): return None
    imp = 1/oo + 1/uu
    if not (1.00 <= imp <= 1.25): return None
    return oo, uu

def sanitize_1x2(o_h: float | None, o_d: float | None, o_a: float | None):
    try:
        if None in (o_h, o_d, o_a): return None
        oh, od, oa = float(o_h), float(o_d), float(o_a)
    except: return None
    if not all(1.10 <= v <= 100.0 for v in (oh, od, oa)): return None
    imp = 1/oh + 1/od + 1/oa
    if not (1.00 <= imp <= 1.30): return None
    return oh, od, oa

def ev_kelly_binary(p: float, odds: float) -> Tuple[float, float]:
    b = odds - 1.0
    EV = p*b - (1-p)
    K  = 0.0 if b<=0 else max(0.0, (b*p - (1-p))/b)
    return float(EV), float(K)

def value_index(ev: float | None, kelly: float | None) -> float:
    if ev is None or kelly is None: return -999.0
    return float(ev * math.sqrt(max(0.0, kelly)))


def classify_league_tier(league_info: Dict) -> str:
    try:
        lid = int((league_info or {}).get("id"))
    except Exception:
        lid = None
    if lid in TOP_TIER_LEAGUE_IDS:
        return "top"

    name = str((league_info or {}).get("name", "")).lower()
    if any(key in name for key in TOP_TIER_KEYWORDS):
        return "top"

    return "other"


def get_ev_threshold(league_tier: str, market_group: str) -> EVThreshold:
    return EV_THRESHOLDS.get((league_tier, market_group)) or EV_THRESHOLDS.get(("other", market_group)) or EV_THRESHOLDS[("other", "derivative")]


def kelly_cap_for_league(league_tier: str) -> float:
    return 0.08 if league_tier == "top" else 0.05


def _to_float_or_none(value) -> Optional[float]:
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def assess_consensus(info: Dict[str, object] | None, league_tier: str) -> Tuple[bool, bool, str]:
    info = info or {}
    min_bm = 6 if league_tier == "top" else 8

    bm_raw = info.get("bookmakers")
    bm = _to_float_or_none(bm_raw)
    bm_int = int(bm) if bm is not None else 0

    oround = _to_float_or_none(info.get("overround"))
    update = _to_float_or_none(info.get("update"))

    ok = True
    reasons: List[str] = []
    if bm_int < min_bm:
        ok = False
        reasons.append(f"bookmakers<{min_bm}")
    if oround is None or not (1.02 <= oround <= 1.12):
        ok = False
        reasons.append("overround")
    if update is None or update > 10:
        ok = False
        reasons.append("stale")

    strong = bm_int >= 8 and update is not None and update <= 5 and ok
    return ok, strong, ",".join(reasons)


def evaluate_market_value(
    ev: Optional[float],
    kelly: Optional[float],
    market_group: str,
    league_tier: str,
    consensus_info: Dict[str, object] | None,
) -> Tuple[Optional[float], Optional[float], str, str, Optional[float]]:
    if ev is None or kelly is None:
        return None, None, "drop", "missing", None

    ev_val = _to_float_or_none(ev)
    k_val = _to_float_or_none(kelly)
    if ev_val is None or k_val is None or ev_val <= 0 or k_val <= 0:
        return None, None, "drop", "nonpositive", None

    cap = kelly_cap_for_league(league_tier)
    k_adj = min(cap, max(0.0, k_val))
    if k_adj <= 0:
        return None, None, "drop", "kelly_zero", None

    vi = value_index(ev_val, k_adj)
    consensus_ok, strong, reason = assess_consensus(consensus_info, league_tier)
    if not consensus_ok:
        return None, None, "drop", f"consensus:{reason}", None

    thr = get_ev_threshold(league_tier, market_group)
    ev_abs = abs(ev_val)

    if ev_abs < thr.keep_min:
        return None, None, "low", "below_min", None
    if ev_abs <= thr.preferred_max:
        quality = "keep"
    elif ev_abs <= thr.review_max:
        quality = "review"
    elif ev_abs <= thr.drop_max:
        quality = "review_high"
    else:
        return None, None, "drop", "above_max", None

    if ev_abs > 0.15 and not (strong and vi is not None and vi > 0):
        return None, None, "drop", "high_ev_weak_consensus", None

    return float(ev_val), float(k_adj), quality, "", float(vi)

# ===== 四分之一盘精结算（基于 totals 样本）=====
def ou_ev_kelly_from_totals_quarter(line: float, over_odds: float, under_odds: float, totals) -> dict:
    if totals is None:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}
    try:
        totals_list = list(totals)
    except TypeError:
        totals_list = [totals]
    if len(totals_list) == 0:
        return {"EV_over": None, "Kelly_over": None, "EV_under": None, "Kelly_under": None}

    a = int(line // 1)
    frac = round(line - a, 2)
    n = len(totals_list)

    def counts_over(a, frac):
        if frac == 0.0:
            fw = sum(t > a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t > a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t >= a + 1 for t in totals_list) / n
            hl = sum(t == a for t in totals_list) / n
            fl = sum(t <= a - 1 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, 0.0, hl, fl + max(0.0, remain)
        elif frac == 0.75:
            fw = sum(t >= a + 2 for t in totals_list) / n
            hw = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t <= a for t in totals_list) / n
            remain = 1.0 - fw - hw - fl
            return fw, hw, remain, 0.0, fl
        else:
            fw = sum(t > line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    def counts_under(a, frac):
        if frac == 0.0:
            fw = sum(t < a for t in totals_list) / n
            pu = sum(t == a for t in totals_list) / n
            fl = 1.0 - fw - pu
            return fw, 0.0, pu, 0.0, fl
        elif frac == 0.5:
            fw = sum(t < a + 0.5 for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl
        elif frac == 0.25:
            fw = sum(t < a for t in totals_list) / n
            hw = sum(t == a for t in totals_list) / n
            fl = sum(t >= a + 1 for t in totals_list) / n
            remain = max(0.0, 1.0 - fw - hw - fl)
            return fw, hw, remain, 0.0, fl
        elif frac == 0.75:
            fw = sum(t <= a for t in totals_list) / n
            hl = sum(t == a + 1 for t in totals_list) / n
            fl = sum(t >= a + 2 for t in totals_list) / n
            remain = 1.0 - fw - hl - fl
            return fw, 0.0, remain, hl, fl
        else:
            fw = sum(t < line for t in totals_list) / n
            fl = 1.0 - fw
            return fw, 0.0, 0.0, 0.0, fl

    fw_o, hw_o, pu_o, hl_o, fl_o = counts_over(a, frac)
    fw_u, hw_u, pu_u, hl_u, fl_u = counts_under(a, frac)

    b_over  = max(0.0, over_odds - 1.0)
    b_under = max(0.0, under_odds - 1.0)

    EV_over  = fw_o*b_over + hw_o*(0.5*b_over) - hl_o*0.5 - fl_o*1.0
    EV_under = fw_u*b_under + hw_u*(0.5*b_under) - hl_u*0.5 - fl_u*1.0

    pwin_o, plose_o = fw_o + 0.5*hw_o, fl_o + 0.5*hl_o
    pwin_u, plose_u = fw_u + 0.5*hw_u, fl_u + 0.5*hl_u

    K_over  = 0.0 if b_over  <= 0 else max(0.0, (b_over*pwin_o  - plose_o)/b_over)
    K_under = 0.0 if b_under <= 0 else max(0.0, (b_under*pwin_u - plose_u)/b_under)

    return {"EV_over": float(EV_over), "Kelly_over": float(K_over),
            "EV_under": float(EV_under), "Kelly_under": float(K_under)}

def _regression_check_quarter_under() -> None:
    """Verify under-quarter lines treat integer totals as half wins."""
    totals = [1, 2, 3, 4]
    res = ou_ev_kelly_from_totals_quarter(2.25, 2.0, 2.0, totals)
    expected_ev_under = -0.125
    if not math.isclose(res["EV_under"], expected_ev_under, rel_tol=1e-12, abs_tol=1e-12):
        raise AssertionError(
            f"Quarter-line under regression failed: expected EV_under {expected_ev_under}, got {res['EV_under']}"
        )

# ================== 预取与缓存 ==================
TEAM_STATS_CACHE: dict[tuple[int,int,int], dict] = {}

def prefetch_team_stats(fixtures: List[Dict]):
    tasks: Set[tuple[int,int,int]] = set()
    for fx in fixtures:
        try:
            lg = fx["league"]["id"]; ss = fx["league"]["season"]
            hid = fx["teams"]["home"]["id"]; aid = fx["teams"]["away"]["id"]
            tasks.add((lg, ss, hid)); tasks.add((lg, ss, aid))
        except: pass

    def _job(key):
        if key in TEAM_STATS_CACHE: return key, TEAM_STATS_CACHE[key]
        lg, ss, tid = key
        try:
            st = team_statistics(lg, ss, tid)
            TEAM_STATS_CACHE[key] = st or {}
            return key, TEAM_STATS_CACHE[key]
        except Exception:
            return key, {}

    if not tasks: return
    with ThreadPoolExecutor(max_workers=CONCURRENCY) as ex:
        futures = {ex.submit(_job, k): k for k in tasks}
        done = 0
        for _ in as_completed(futures):
            done += 1
            if done % 20 == 0 or done == len(tasks):
                print(f"……已预取球队统计 {done}/{len(tasks)}")

def compute_league_avg_from_cache(league_id: int, season: int) -> float:
    stats_list = []
    for (lg, ss, _tid), st in TEAM_STATS_CACHE.items():
        if lg == league_id and ss == season and st:
            stats_list.append(st)
    if not stats_list:
        return 2.6
    league_avg, _ = league_goal_averages(stats_list)
    return float(league_avg or 2.6)

def estimate_corners_lambda_total(h_stats: dict, a_stats: dict, lam_home: float, lam_away: float) -> float:
    def _safe(path, d):
        cur = d
        for k in path:
            if not isinstance(cur, dict): return None
            cur = cur.get(k)
            if cur is None: return None
        try: return float(cur)
        except: return None
    h_c_home = _safe(["corners","for","average","home"], h_stats)
    a_c_away = _safe(["corners","for","average","away"], a_stats)
    if h_c_home and a_c_away and h_c_home > 0 and a_c_away > 0:
        return float(h_c_home + a_c_away)
    return float(CORNER_BASE + CORNER_PER_GOAL * (lam_home + lam_away))

# ================== λ 多模型融合 ==================
RECENT_FORM_CACHE: dict[tuple[int, int, int, int], List[Dict]] = {}

def _safe_stat(path: List[str], data: dict, default: float) -> float:
    cur = data or {}
    for key in path:
        if not isinstance(cur, dict):
            return float(default)
        cur = cur.get(key)
        if cur is None:
            return float(default)
    try:
        return float(cur)
    except Exception:
        return float(default)

def _fixture_timestamp(fixture: Dict) -> float:
    info = (fixture or {}).get("fixture") or {}
    ts = info.get("timestamp")
    if isinstance(ts, (int, float)):
        return float(ts)
    date_str = info.get("date")
    if isinstance(date_str, str):
        try:
            if date_str.endswith("Z"):
                date_str = date_str[:-1] + "+00:00"
            return datetime.fromisoformat(date_str).timestamp()
        except Exception:
            pass
    return 0.0

def _recent_weighted_avg(fixtures: List[Dict], team_id: int, want_home: bool, max_games: int, decay: float) -> tuple[Optional[float], Optional[float], int]:
    if max_games <= 0:
        return None, None, 0
    entries: List[tuple[float, float, float]] = []
    for fx in fixtures or []:
        teams = fx.get("teams") or {}
        home = (teams.get("home") or {}).get("id")
        away = (teams.get("away") or {}).get("id")
        if want_home:
            if home != team_id:
                continue
            g_for = (fx.get("goals") or {}).get("home")
            g_against = (fx.get("goals") or {}).get("away")
        else:
            if away != team_id:
                continue
            g_for = (fx.get("goals") or {}).get("away")
            g_against = (fx.get("goals") or {}).get("home")
        if g_for is None or g_against is None:
            score_ft = ((fx.get("score") or {}).get("fulltime") or {})
            if g_for is None:
                g_for = score_ft.get("home" if want_home else "away")
            if g_against is None:
                g_against = score_ft.get("away" if want_home else "home")
        try:
            gf_val = float(g_for)
            ga_val = float(g_against)
        except (TypeError, ValueError):
            continue
        entries.append((_fixture_timestamp(fx), gf_val, ga_val))

    if not entries:
        return None, None, 0

    entries.sort(key=lambda x: x[0], reverse=True)
    try:
        decay_val = float(decay)
    except Exception:
        decay_val = 0.85
    if decay_val <= 0:
        decay_val = 0.85
    if decay_val > 1:
        decay_val = 1.0

    weight_sum = 0.0
    gf_sum = 0.0
    ga_sum = 0.0
    used = 0
    for _, gf_val, ga_val in entries:
        weight = decay_val ** used
        gf_sum += weight * gf_val
        ga_sum += weight * ga_val
        weight_sum += weight
        used += 1
        if used >= max_games:
            break

    if weight_sum <= 0:
        return None, None, used

    return gf_sum / weight_sum, ga_sum / weight_sum, used

def fetch_recent_form(team_id: int, league_id: int, season: int, fetch_last: int) -> List[Dict]:
    key = (league_id, season, team_id, fetch_last)
    if key in RECENT_FORM_CACHE:
        return RECENT_FORM_CACHE[key]
    try:
        fixtures = recent_fixtures_by_team(team_id=team_id, season=season, last=fetch_last, league_id=league_id)
    except Exception as e:
        fixtures = []
        if LOG_LAMBDA_BLEND:
            print(f"[λ模型] 获取近况赛程失败 team={team_id}: {e}")
    RECENT_FORM_CACHE[key] = fixtures or []
    return RECENT_FORM_CACHE[key]

def _blend_recent_value(recent_val: Optional[float], fallback_val: float, mix: float) -> float:
    if fallback_val is None and recent_val is None:
        return 0.0
    if recent_val is None:
        return float(fallback_val)
    if fallback_val is None:
        return float(recent_val)
    mix_clamped = max(0.0, min(1.0, float(mix)))
    return float(mix_clamped * float(fallback_val) + (1.0 - mix_clamped) * float(recent_val))

def lambda_from_season_stats(h_stats: dict, a_stats: dict, league_avg: float, home_adv: float) -> tuple[tuple[float, float], dict]:
    denom = max(float(league_avg or 0.0), 1e-6)
    h_gf_home = _safe_stat(["goals","for","average","home"], h_stats, 1.3)
    h_ga_home = _safe_stat(["goals","against","average","home"], h_stats, 1.3)
    a_gf_away = _safe_stat(["goals","for","average","away"], a_stats, 1.3)
    a_ga_away = _safe_stat(["goals","against","average","away"], a_stats, 1.3)

    h_att = max(0.05, h_gf_home) / denom
    h_def = max(0.05, h_ga_home) / denom
    a_att = max(0.05, a_gf_away) / denom
    a_def = max(0.05, a_ga_away) / denom

    lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, home_adv)
    meta = {
        "h_att": float(h_att),
        "h_def": float(h_def),
        "a_att": float(a_att),
        "a_def": float(a_def),
        "h_for_avg": float(h_gf_home),
        "h_against_avg": float(h_ga_home),
        "a_for_avg": float(a_gf_away),
        "a_against_avg": float(a_ga_away),
    }
    return (float(lam_home), float(lam_away)), meta

def lambda_from_recent_form(
    home_id: int,
    away_id: int,
    league_id: int,
    season: int,
    league_avg: float,
    home_adv: float,
    season_meta: dict,
    config: dict,
) -> tuple[tuple[float, float], dict]:
    recent_games = max(1, int(config.get("recent_games", 6)))
    min_games = max(1, int(config.get("min_games", 3)))
    if min_games > recent_games:
        min_games = recent_games
    try:
        decay = float(config.get("decay", 0.85))
    except Exception:
        decay = 0.85
    fetch_last = int(config.get("fetch_last", recent_games))
    fetch_last = max(fetch_last, recent_games * 2)

    home_fixtures = fetch_recent_form(home_id, league_id, season, fetch_last)
    away_fixtures = fetch_recent_form(away_id, league_id, season, fetch_last)

    h_recent_for, h_recent_against, cnt_home = _recent_weighted_avg(home_fixtures, home_id, True, recent_games, decay)
    a_recent_for, a_recent_against, cnt_away = _recent_weighted_avg(away_fixtures, away_id, False, recent_games, decay)

    coverage_home = min(1.0, cnt_home / recent_games) if recent_games else 0.0
    coverage_away = min(1.0, cnt_away / recent_games) if recent_games else 0.0

    try:
        base_mix = float(config.get("season_mix", 0.3))
    except Exception:
        base_mix = 0.3
    base_mix = max(0.0, min(1.0, base_mix))

    def _effective_mix(base: float, coverage: float, enough_games: bool) -> float:
        if not enough_games:
            return 1.0
        return base + (1.0 - coverage) * (1.0 - base)

    eff_mix_home = _effective_mix(base_mix, coverage_home, cnt_home >= min_games)
    eff_mix_away = _effective_mix(base_mix, coverage_away, cnt_away >= min_games)

    fallback_h_for = max(0.05, float(season_meta.get("h_for_avg", league_avg)))
    fallback_h_against = max(0.05, float(season_meta.get("h_against_avg", league_avg)))
    fallback_a_for = max(0.05, float(season_meta.get("a_for_avg", league_avg)))
    fallback_a_against = max(0.05, float(season_meta.get("a_against_avg", league_avg)))

    h_for_blend = max(0.05, _blend_recent_value(h_recent_for, fallback_h_for, eff_mix_home))
    h_against_blend = max(0.05, _blend_recent_value(h_recent_against, fallback_h_against, eff_mix_home))
    a_for_blend = max(0.05, _blend_recent_value(a_recent_for, fallback_a_for, eff_mix_away))
    a_against_blend = max(0.05, _blend_recent_value(a_recent_against, fallback_a_against, eff_mix_away))

    denom = max(float(league_avg or 0.0), 1e-6)
    h_att = h_for_blend / denom
    h_def = h_against_blend / denom
    a_att = a_for_blend / denom
    a_def = a_against_blend / denom

    lam_home, lam_away = expected_goals_from_strengths(h_att, a_def, a_att, h_def, league_avg, home_adv)
    meta = {
        "home_games_used": int(cnt_home),
        "away_games_used": int(cnt_away),
        "home_recent_for": None if h_recent_for is None else float(h_recent_for),
        "home_recent_against": None if h_recent_against is None else float(h_recent_against),
        "away_recent_for": None if a_recent_for is None else float(a_recent_for),
        "away_recent_against": None if a_recent_against is None else float(a_recent_against),
        "home_eff_mix": float(eff_mix_home),
        "away_eff_mix": float(eff_mix_away),
    }
    return (float(lam_home), float(lam_away)), meta

def compute_lambda_models(
    league_id: int,
    season: int,
    home_id: int,
    away_id: int,
    h_stats: dict,
    a_stats: dict,
    league_avg: float,
) -> Dict[str, dict]:
    models: Dict[str, dict] = {}
    (lam_season, lam_season_away), season_meta = lambda_from_season_stats(h_stats, a_stats, league_avg, HOME_ADV)
    models["season"] = {
        "lam_home": lam_season,
        "lam_away": lam_season_away,
        "meta": season_meta,
    }

    recent_cfg = LAMBDA_MODEL_CONFIG.get("recent") or {}
    if float(recent_cfg.get("weight", 0.0)) > 0:
        try:
            (lam_recent, lam_recent_away), recent_meta = lambda_from_recent_form(
                home_id, away_id, league_id, season, league_avg, HOME_ADV, season_meta, recent_cfg
            )
            models["recent"] = {
                "lam_home": lam_recent,
                "lam_away": lam_recent_away,
                "meta": recent_meta,
            }
        except Exception as e:
            if LOG_LAMBDA_BLEND:
                print(f"[λ模型] 近况模型计算失败 {home_id}-{away_id}: {e}")
    return models

def blend_lambda_models(models: Dict[str, dict], config: Dict[str, dict]) -> tuple[float, float, Dict[str, float]]:
    valid = {
        name: data
        for name, data in models.items()
        if isinstance(data, dict) and data.get("lam_home") is not None and data.get("lam_away") is not None
    }
    if not valid:
        raise RuntimeError("无可用 λ 模型")

    weights_used: Dict[str, float] = {}
    weighted_home = 0.0
    weighted_away = 0.0
    for name, data in valid.items():
        weight = float((config.get(name) or {}).get("weight", 0.0))
        if weight <= 0:
            continue
        lam_h = float(data.get("lam_home", 0.0))
        lam_a = float(data.get("lam_away", 0.0))
        weights_used[name] = weight
        weighted_home += weight * lam_h
        weighted_away += weight * lam_a

    if not weights_used:
        first_name, data = next(iter(valid.items()))
        fallback_weights = {name: (1.0 if name == first_name else 0.0) for name in valid}
        return float(data.get("lam_home", 1.4)), float(data.get("lam_away", 1.1)), fallback_weights

    total_weight = sum(weights_used.values()) or 1.0
    lam_home = weighted_home / total_weight
    lam_away = weighted_away / total_weight
    normalized = {name: (weights_used.get(name, 0.0) / total_weight) for name in valid}
    return float(lam_home), float(lam_away), normalized

def format_lambda_detail(models: Dict[str, dict], weights: Dict[str, float]) -> str:
    parts: List[str] = []
    for name, data in models.items():
        lam_h = data.get("lam_home")
        lam_a = data.get("lam_away")
        if lam_h is None or lam_a is None:
            continue
        weight = weights.get(name, 0.0)
        parts.append(f"{name}:{float(lam_h):.3f}/{float(lam_a):.3f} (w={weight:.2f})")
    return " | ".join(parts)

def log_lambda_blend(home_name: str, away_name: str, models: Dict[str, dict], weights: Dict[str, float], lam_home: float, lam_away: float) -> None:
    entries = []
    for name, data in models.items():
        lam_h = data.get("lam_home")
        lam_a = data.get("lam_away")
        if lam_h is None or lam_a is None:
            continue
        raw_weight = float((LAMBDA_MODEL_CONFIG.get(name) or {}).get("weight", 0.0))
        norm_weight = weights.get(name, 0.0)
        meta = data.get("meta") or {}
        extra = ""
        if name == "recent":
            extra = (
                f" cntH={meta.get('home_games_used', 0)} cntA={meta.get('away_games_used', 0)}"
                f" mixH={meta.get('home_eff_mix', 0):.2f} mixA={meta.get('away_eff_mix', 0):.2f}"
            )
        entries.append(
            f"{name}:λ=({float(lam_h):.2f},{float(lam_a):.2f}) w_cfg={raw_weight:.2f} w_norm={norm_weight:.2f}{extra}"
        )
    detail = " | ".join(entries)
    print(f"[λ模型] {home_name} vs {away_name} -> {detail} => blend=({lam_home:.2f},{lam_away:.2f})")

# ================== 打印 & 导出工具 ==================
def _fmt_ou_book(line, odds, is_corner=False):
    if line is None or odds is None: return ""
    tag = "CRN" if is_corner else "OU"
    try: return f"{tag}{float(line):g}@{float(odds):.2f}"
    except: return ""

def _fmt_ah_book(home_line, odds, side: str):
    if home_line is None or odds is None: return ""
    try:
        ln = float(home_line)
        ln_side = ln if side.lower()=="home" else -ln
        sign = "+" if ln_side > 0 else ""
        return f"AH{sign}{ln_side:g}@{float(odds):.2f}"
    except: return ""

def _stake_pct_from_kelly(k: Optional[float]) -> float:
    try:
        if k is None: return 0.0
        pct = 100.0 * float(k) * float(KELLY_FRACTION)
        return float(min(STAKE_CAP_PCT, max(STAKE_MIN_PCT, round(pct, 2))))
    except: return 0.0

def export_picks(rows_all: List[Dict], date_str: str):
    picks: List[Dict] = []
    for r in rows_all:
        base = {"date_utc": r.get("date_utc"), "kickoff_utc": r.get("kickoff_utc"),
                "league": r.get("league"), "home": r.get("home"), "away": r.get("away")}
        # Goals OU 主盘
        ev, k = r.get("ev_ou_main_over"), r.get("kelly_ou_main_over")
        if ev is not None and k is not None and r.get("quality_ou_main_over") == "keep":
            vi = r.get("vi_ou_main_over")
            vi = vi if vi is not None else value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base, "market":"OU-Over", "book":_fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(k)})
        ev, k = r.get("ev_ou_main_under"), r.get("kelly_ou_main_under")
        if ev is not None and k is not None and r.get("quality_ou_main_under") == "keep":
            vi = r.get("vi_ou_main_under")
            vi = vi if vi is not None else value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base, "market":"OU-Under", "book":_fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(k)})
        # 1X2
        for mk, evk, kel, odd in [
            ("1X2-Home", r.get("ev_1x2_home"), r.get("kelly_1x2_home"), r.get("odds_1x2_home")),
            ("1X2-Draw", r.get("ev_1x2_draw"), r.get("kelly_1x2_draw"), r.get("odds_1x2_draw")),
            ("1X2-Away", r.get("ev_1x2_away"), r.get("kelly_1x2_away"), r.get("odds_1x2_away")),
        ]:
            qual_key = {
                "1X2-Home": "quality_1x2_home",
                "1X2-Draw": "quality_1x2_draw",
                "1X2-Away": "quality_1x2_away",
            }[mk]
            vi_key = {
                "1X2-Home": "vi_1x2_home",
                "1X2-Draw": "vi_1x2_draw",
                "1X2-Away": "vi_1x2_away",
            }[mk]
            if evk is not None and kel is not None and odd is not None and r.get(qual_key) == "keep":
                vi = r.get(vi_key)
                vi = vi if vi is not None else value_index(evk, kel)
                if evk>=PICKS_MIN_EV and kel>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                    picks.append({**base, "market":mk, "book":f"{mk}@{float(odd):.2f}",
                                  "ev":float(evk),"kelly":float(kel),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(kel)})
        # AH 主盘
        ah_line = r.get("ah_line")
        if ah_line is not None:
            for side, evk, kel, odd in [
                ("home", r.get("ev_ah_home"), r.get("kelly_ah_home"), r.get("odds_ah_home")),
                ("away", r.get("ev_ah_away"), r.get("kelly_ah_away"), r.get("odds_ah_away")),
            ]:
                qual = r.get("quality_ah_home" if side == "home" else "quality_ah_away")
                vi_val = r.get("vi_ah_home" if side == "home" else "vi_ah_away")
                if evk is not None and kel is not None and odd is not None and qual == "keep":
                    vi = vi_val if vi_val is not None else value_index(evk, kel)
                    if evk>=PICKS_MIN_EV and kel>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                        picks.append({**base, "market":f"AH-{'Home' if side=='home' else 'Away'}",
                                      "book":_fmt_ah_book(ah_line, odd, side),
                                      "ev":float(evk),"kelly":float(kel),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(kel)})
        # 角球 OU 主盘
        ev, k = r.get("ev_crn_main_over"), r.get("kelly_crn_main_over")
        if ev is not None and k is not None and r.get("quality_crn_main_over") == "keep":
            vi = r.get("vi_crn_main_over")
            vi = vi if vi is not None else value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base,"market":"CRN-Over","book":_fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(k)})
        ev, k = r.get("ev_crn_main_under"), r.get("kelly_crn_main_under")
        if ev is not None and k is not None and r.get("quality_crn_main_under") == "keep":
            vi = r.get("vi_crn_main_under")
            vi = vi if vi is not None else value_index(ev, k)
            if ev>=PICKS_MIN_EV and k>=PICKS_MIN_KELLY and vi>=PICKS_MIN_VI:
                picks.append({**base,"market":"CRN-Under","book":_fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True),
                              "ev":float(ev),"kelly":float(k),"value_index":float(vi),"stake_pct":_stake_pct_from_kelly(k)})

    picks.sort(key=lambda x: x.get("value_index", -999), reverse=True)
    if PICKS_TOP_N is not None:
        picks = picks[:int(PICKS_TOP_N)]

    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"picks_{date_str}.csv")
    fieldnames = ["date_utc","kickoff_utc","league","home","away","market","book","ev","kelly","value_index","stake_pct"]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames); w.writeheader(); [w.writerow(p) for p in picks]
    print(f"\n已导出下注清单到: {out_file}  （{len(picks)} 条，阈值：EV≥{PICKS_MIN_EV}, Kelly≥{PICKS_MIN_KELLY}, VI≥{PICKS_MIN_VI}）")

def _median(arr: List[float]) -> Optional[float]:
    arr = [float(x) for x in arr if x];
    if not arr: return None
    arr.sort(); n=len(arr)
    return arr[n//2] if n%2==1 else 0.5*(arr[n//2-1]+arr[n//2])

def _ou_overround(oo: float, uu: float) -> float:
    try: return 1.0/float(oo) + 1.0/float(uu)
    except: return 9.9

# —— 新增：通用小工具 & AH 全线归一 & 主盘选择 —— #
def _to_float(x, default=None):
    try:
        if isinstance(x, str):
            x = x.replace("+", "")
        return float(x)
    except:
        return default

def build_ah_lines(odds: dict) -> dict:
    """
    统一把 AH 全线提取/归一（支持多个可能的键名和数据形态）：
    输出:
      { "0.25": {"home_median":..., "away_median":..., "home_cnt":..., "away_cnt":..., "overround":...}, ... }
    """
    if not isinstance(odds, dict):
        return {}

    # 1) 已有标准结构
    if isinstance(odds.get("ah_lines"), dict) and odds["ah_lines"]:
        return odds["ah_lines"]

    # 2) 多候选键名（容错）
    cand_keys = ["_raw_ah_map", "ah_raw_map", "asian_handicap_map", "asian_map", "AH", "ah"]
    raw = None
    for k in cand_keys:
        if isinstance(odds.get(k), dict) and odds[k]:
            raw = odds[k]; break
    if raw is None:
        return {}

    out = {}
    for line_key, sides in raw.items():
        ln = _to_float(line_key, default=None)
        if ln is None or not isinstance(sides, dict):
            continue

        hs = sides.get("home")
        as_ = sides.get("away")

        # 支持“列表/单值”
        if isinstance(hs, (list, tuple)):
            hs = [_to_float(v) for v in hs if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oh = _median(hs)
            cnt_h = len(hs)
        else:
            oh = _to_float(hs)
            cnt_h = 1 if oh is not None else 0

        if isinstance(as_, (list, tuple)):
            as_ = [_to_float(v) for v in as_ if _to_float(v) is not None and 1.10 <= _to_float(v) <= 100]
            oa = _median(as_)
            cnt_a = len(as_)
        else:
            oa = _to_float(as_)
            cnt_a = 1 if oa is not None else 0

        if oh is None or oa is None:
            continue

        oround = _ou_overround(oh, oa)
        entry = {
            "home_median": float(oh), "away_median": float(oa),
            "home_cnt": int(cnt_h), "away_cnt": int(cnt_a),
            "overround": float(oround)
        }
        bm_val = sides.get("bookmaker_count") if isinstance(sides, dict) else None
        if bm_val is None:
            entry["bookmaker_count"] = int(min(cnt_h, cnt_a))
        else:
            try:
                entry["bookmaker_count"] = int(float(bm_val))
            except (TypeError, ValueError):
                entry["bookmaker_count"] = int(min(cnt_h, cnt_a))
        if isinstance(sides, dict) and sides.get("max_update_minutes") is not None:
            try:
                entry["max_update_minutes"] = float(sides.get("max_update_minutes"))
            except (TypeError, ValueError):
                pass
        out[str(float(ln))] = entry
    return out

def select_best_ah_main(ah_lines: dict, strict: int = 1) -> tuple[float, float, float] | None:
    """
    从 ah_lines 中挑“主盘”：优先低超盘、样本多、|line|小。
    返回 (line, home_odds, away_odds) 或 None
    """
    if not isinstance(ah_lines, dict) or not ah_lines:
        return None

    cands = []
    for sline, info in ah_lines.items():
        ln = _to_float(sline, default=None)
        oh = _to_float((info or {}).get("home_median"), default=None)
        oa = _to_float((info or {}).get("away_median"), default=None)
        if ln is None or oh is None or oa is None:
            continue
        cnt_h = int((info or {}).get("home_cnt", 0) or 0)
        cnt_a = int((info or {}).get("away_cnt", 0) or 0)
        oround = _to_float((info or {}).get("overround"), default=9.9)

        if strict:
            if min(cnt_h, cnt_a) < AH_MIN_CNT:
                continue
            if not (1.00 <= oround <= AH_MAX_OR):
                continue

        cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        # 放宽再挑一次
        for sline, info in ah_lines.items():
            ln = _to_float(sline, default=None)
            oh = _to_float((info or {}).get("home_median"), default=None)
            oa = _to_float((info or {}).get("away_median"), default=None)
            if ln is None or oh is None or oa is None:
                continue
            cnt_h = int((info or {}).get("home_cnt", 0) or 0)
            cnt_a = int((info or {}).get("away_cnt", 0) or 0)
            oround = _to_float((info or {}).get("overround"), default=9.9)
            cands.append((oround, -min(cnt_h, cnt_a), abs(ln), ln, oh, oa))

    if not cands:
        return None

    cands.sort()
    _, _, _, ln, oh, oa = cands[0]
    return (float(ln), float(oh), float(oa))

# ================== 主流程 ==================
def main():
    random.seed(42); np.random.seed(42)
    date_str = _today_utc_date()
    print(f"=== 37号 · 每日情报站（并发/快速版）@ {date_str} ===")

    fixtures = fixtures_by_date(date_str)
    if not fixtures:
        print("该日期无赛程或 API 无返回。"); return

    if EXCLUDE_NOISY:
        kept = []
        for fx in fixtures:
            lgname = ((fx.get("league") or {}).get("name") or "").lower()
            if not any(k in lgname for k in EXCLUDE_KEYS):
                kept.append(fx)
        fixtures = kept
    print(f"拉取赛程：{len(fixtures)} 场。正在预取球队统计…")

    prefetch_team_stats(fixtures)

    rows_all: List[Dict] = []
    matrix_rows: List[Dict] = []

    # 全线榜单池
    ou_all_over, ou_all_under = [], []
    crn_all_over, crn_all_under = [], []
    ah_all_home, ah_all_away = [], []

    # AH 诊断计数
    cnt_ah_has_line = cnt_ah_ev_home = cnt_ah_ev_away = 0

    done = 0
    for fx in fixtures:
        try:
            league = fx["league"]; league_id = league["id"]; season = league["season"]
            league_name = league.get("name")
            fixture_info = fx.get("fixture", {}); kickoff_utc = fixture_info.get("date"); fx_id = fixture_info.get("id")
            home = fx["teams"]["home"]; away = fx["teams"]["away"]
            home_id, away_id = home["id"], away["id"]
            home_name, away_name = home["name"], away["name"]
        except Exception as e:
            print(f"跳过一场（解析失败）：{e}"); continue

        league_tier = classify_league_tier(league)

        league_avg = compute_league_avg_from_cache(league_id, season)

        h_st = TEAM_STATS_CACHE.get((league_id, season, home_id), {}) or {}
        a_st = TEAM_STATS_CACHE.get((league_id, season, away_id), {}) or {}

        lambda_models = compute_lambda_models(
            league_id=league_id,
            season=season,
            home_id=home_id,
            away_id=away_id,
            h_stats=h_st,
            a_stats=a_st,
            league_avg=league_avg,
        )
        lam_home, lam_away, lam_weights = blend_lambda_models(lambda_models, LAMBDA_MODEL_CONFIG)
        lam_detail = format_lambda_detail(lambda_models, lam_weights)
        if LOG_LAMBDA_BLEND:
            log_lambda_blend(home_name, away_name, lambda_models, lam_weights, lam_home, lam_away)

        sim = monte_carlo_simulate(lam_home, lam_away, n_sims=N_SIMS_GOALS, over_line=2.5)
        _, _, totals = simulate_goals(lam_home, lam_away, n_sims=N_SIMS_GOALS)
        try: totals = [int(x) for x in totals]
        except: totals = [int(totals)]

        odds = odds_by_fixture(fx_id) if fx_id else {}

        consensus_1x2 = {
            "bookmakers": odds.get("1x2_bookmaker_count"),
            "overround": odds.get("1x2_overround"),
            "update": odds.get("1x2_max_update_minutes"),
        }
        consensus_ou_main = {
            "bookmakers": odds.get("ou_main_bookmaker_count"),
            "overround": odds.get("ou_main_overround"),
            "update": odds.get("ou_main_max_update_minutes"),
        }
        consensus_ah_main = {
            "bookmakers": odds.get("ah_bookmaker_count"),
            "overround": odds.get("ah_overround"),
            "update": odds.get("ah_max_update_minutes"),
        }
        consensus_crn_main = {
            "bookmakers": odds.get("crn_main_bookmaker_count"),
            "overround": odds.get("crn_main_overround"),
            "update": odds.get("crn_main_max_update_minutes"),
        }

        # ===== 1X2 =====
        o1_h,o1_d,o1_a = odds.get("1x2_home"),odds.get("1x2_draw"),odds.get("1x2_away")
        ev1_h=ev1_d=ev1_a=k1_h=k1_d=k1_a=None
        ok1 = sanitize_1x2(o1_h,o1_d,o1_a)
        if ok1:
            o1_h,o1_d,o1_a = ok1
            ev1_h,k1_h = ev_kelly_binary(sim["p_home"], o1_h)
            ev1_d,k1_d = ev_kelly_binary(sim["p_draw"], o1_d)
            ev1_a,k1_a = ev_kelly_binary(sim["p_away"], o1_a)
            if is_ev_outlier(max([x for x in (ev1_h,ev1_d,ev1_a) if x is not None], default=0)):
                ev1_h=ev1_d=ev1_a=k1_h=k1_d=k1_a=None

        ev1_h, k1_h, q1_h, qnote1_h, vi1_h = evaluate_market_value(ev1_h, k1_h, "1x2", league_tier, consensus_1x2)
        ev1_d, k1_d, q1_d, qnote1_d, vi1_d = evaluate_market_value(ev1_d, k1_d, "1x2", league_tier, consensus_1x2)
        ev1_a, k1_a, q1_a, qnote1_a, vi1_a = evaluate_market_value(ev1_a, k1_a, "1x2", league_tier, consensus_1x2)

        # ===== Goals OU 主盘 =====
        ou_main_line   = odds.get("ou_main_line")
        ou_main_over   = odds.get("ou_main_over")
        ou_main_under  = odds.get("ou_main_under")
        ou_cnt_o       = odds.get("ou_main_over_cnt") or 0
        ou_cnt_u       = odds.get("ou_main_under_cnt") or 0
        ou_overround   = odds.get("ou_main_overround") or 9.9

        ev_main_over = ev_main_under = k_main_over = k_main_under = None
        if ou_main_line is not None and ou_main_over is not None and ou_main_under is not None:
            pair = sanitize_ou_pair(ou_main_over, ou_main_under)
            if pair and (not STRICT_OU_MAIN or (ou_cnt_o >= OU_MIN_CNT and ou_cnt_u >= OU_MIN_CNT and ou_overround <= OU_MAX_OR)):
                ou_main_over, ou_main_under = pair
                res = ou_ev_kelly_from_totals_quarter(float(ou_main_line), float(ou_main_over), float(ou_main_under), totals)
                ev_main_over, k_main_over = res["EV_over"],  res["Kelly_over"]
                ev_main_under, k_main_under = res["EV_under"], res["Kelly_under"]
                if is_ev_outlier(max([x for x in (ev_main_over, ev_main_under) if x is not None], default=0)):
                    ev_main_over = ev_main_under = k_main_over = k_main_under = None

        ev_main_over, k_main_over, q_ou_main_over, qnote_ou_main_over, vi_ou_main_over = evaluate_market_value(ev_main_over, k_main_over, "ou", league_tier, consensus_ou_main)
        ev_main_under, k_main_under, q_ou_main_under, qnote_ou_main_under, vi_ou_main_under = evaluate_market_value(ev_main_under, k_main_under, "ou", league_tier, consensus_ou_main)

        # ===== OU@2.5 参考 =====
        o25_over,o25_under = odds.get("ou_over_2_5"),odds.get("ou_under_2_5")
        ev25_over=ev25_under=k25_over=k25_under=None
        ok25 = sanitize_ou_pair(o25_over,o25_under)
        if ok25:
            o25_over,o25_under = ok25
            res25 = ou_ev_kelly_from_totals_quarter(2.5, float(o25_over), float(o25_under), totals)
            ev25_over, k25_over = res25["EV_over"],  res25["Kelly_over"]
            ev25_under, k25_under = res25["EV_under"], res25["Kelly_under"]
            if is_ev_outlier(max([x for x in (ev25_over,ev25_under) if x is not None], default=0)):
                ev25_over=ev25_under=k25_over=k25_under=None

        ou_lines_data = odds.get("ou_lines") or {}
        info_25 = None
        for key in ("2.5", str(2.5)):
            if key in ou_lines_data:
                info_25 = ou_lines_data[key]
                break
        consensus_ou_25 = {
            "bookmakers": (info_25 or {}).get("bookmaker_count") or (info_25 or {}).get("bookmakers"),
            "overround": (info_25 or {}).get("overround"),
            "update": (info_25 or {}).get("max_update_minutes"),
        }
        ev25_over, k25_over, q_ou25_over, qnote_ou25_over, vi_ou25_over = evaluate_market_value(ev25_over, k25_over, "ou", league_tier, consensus_ou_25)
        ev25_under, k25_under, q_ou25_under, qnote_ou25_under, vi_ou25_under = evaluate_market_value(ev25_under, k25_under, "ou", league_tier, consensus_ou_25)

        # ===== AH 全线（统一归一）
        ah_lines = build_ah_lines(odds)

        # ===== AH 主盘（缺就从全线里自选）
        ah_line, ah_oh, ah_oa = odds.get("ah_line"), odds.get("ah_home_odds"), odds.get("ah_away_odds")
        if ah_line is None or ah_oh is None or ah_oa is None:
            pick = select_best_ah_main(ah_lines, strict=STRICT_AH_MAIN)
            if pick:
                ah_line, ah_oh, ah_oa = pick

        ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None
        if ah_line is not None and ah_oh is not None and ah_oa is not None:
            cnt_ah_has_line += 1
            probs_ah = ah_probabilities_from_lams(lam_home, lam_away, h=float(ah_line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs_ah, odds_home=float(ah_oh), odds_away=float(ah_oa))
            if isinstance(evk.get("home"), dict):
                ev_ah_h, k_ah_h = evk["home"].get("EV"), evk["home"].get("Kelly")
            if isinstance(evk.get("away"), dict):
                ev_ah_a, k_ah_a = evk["away"].get("EV"), evk["away"].get("Kelly")
            if is_ev_outlier(max([x for x in (ev_ah_h, ev_ah_a) if x is not None], default=0)):
                ev_ah_h = ev_ah_a = k_ah_h = k_ah_a = None

        ev_ah_h, k_ah_h, q_ah_home, qnote_ah_home, vi_ah_home = evaluate_market_value(ev_ah_h, k_ah_h, "ah", league_tier, consensus_ah_main)
        ev_ah_a, k_ah_a, q_ah_away, qnote_ah_away, vi_ah_away = evaluate_market_value(ev_ah_a, k_ah_a, "ah", league_tier, consensus_ah_main)

        if ev_ah_h is not None:
            cnt_ah_ev_home += 1
        if ev_ah_a is not None:
            cnt_ah_ev_away += 1

        # ===== 角球 OU 主盘 =====
        crn_main_line  = odds.get("crn_main_line")
        crn_main_over  = odds.get("crn_main_over")
        crn_main_under = odds.get("crn_main_under")
        crn_cnt_o      = odds.get("crn_main_over_cnt") or 0
        crn_cnt_u      = odds.get("crn_main_under_cnt") or 0
        crn_overround  = odds.get("crn_main_overround") or 9.9

        ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None
        crn_totals_list: List[int] | None = None

        if crn_main_line is not None and crn_main_over is not None and crn_main_under is not None:
            pair = sanitize_ou_pair(crn_main_over, crn_main_under)
            if pair and (not STRICT_CRN_MAIN or (crn_cnt_o >= CRN_MIN_CNT and crn_cnt_u >= CRN_MIN_CNT and crn_overround <= CRN_MAX_OR)):
                crn_main_over, crn_main_under = pair
                lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
                crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
                crn_totals_list = [int(x) for x in crn_totals]
                resC = ou_ev_kelly_from_totals_quarter(float(crn_main_line), float(crn_main_over), float(crn_main_under), crn_totals_list)
                ev_crn_over, k_crn_over = resC["EV_over"],  resC["Kelly_over"]
                ev_crn_under, k_crn_under = resC["EV_under"], resC["Kelly_under"]
                if is_ev_outlier(max([x for x in (ev_crn_over,ev_crn_under) if x is not None], default=0)):
                    ev_crn_over = ev_crn_under = k_crn_over = k_crn_under = None

        ev_crn_over, k_crn_over, q_crn_over, qnote_crn_over, vi_crn_over = evaluate_market_value(ev_crn_over, k_crn_over, "derivative", league_tier, consensus_crn_main)
        ev_crn_under, k_crn_under, q_crn_under, qnote_crn_under, vi_crn_under = evaluate_market_value(ev_crn_under, k_crn_under, "derivative", league_tier, consensus_crn_main)

        # ===== 全线榜单池 & 盘口矩阵（优先使用 *_lines；无则回退 _raw_*） =====
        ou_lines = dict(ou_lines_data)
        crn_lines = odds.get("crn_lines") or {}
        # —— AH 用统一归一后的
        #   ah_lines 已在上面 build_ah_lines(odds) 生成

        # 回退：当 *_lines 缺失时，从 _raw_* 现算（OU/CRN 保持原逻辑）
        if not ou_lines and odds.get("_raw_ou_map"):
            for line, sides in odds["_raw_ou_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                ou_lines[str(float(line))] = {"over_median": om, "under_median": um,
                                              "over_cnt": len(ov), "under_cnt": len(un), "overround": oround}
        if not crn_lines and odds.get("_raw_crn_map"):
            for line, sides in odds["_raw_crn_map"].items():
                ov = [x for x in sides.get("over", []) if x]; un = [x for x in sides.get("under", []) if x]
                if not ov or not un: continue
                om, um = _median(ov), _median(un); oround = _ou_overround(om, um)
                crn_lines[str(float(line))] = {"over_median": om, "under_median": um,
                                               "over_cnt": len(ov), "under_cnt": len(un), "overround": oround}

        # —— 全线榜单池（OU）
        for sline, info in (ou_lines.items() if isinstance(ou_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            if om is None or um is None or not (1.00 <= float(oround) <= 1.25): continue
            consensus_line = {
                "bookmakers": info.get("bookmaker_count") or info.get("bookmakers"),
                "overround": info.get("overround"),
                "update": info.get("max_update_minutes"),
            }
            resL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), totals)
            if resL["EV_over"] is not None and resL["Kelly_over"] is not None:
                ev_f, k_f, q_line, _, vi_line = evaluate_market_value(resL["EV_over"], resL["Kelly_over"], "ou", league_tier, consensus_line)
                if ev_f is not None and vi_line is not None:
                    ou_all_over.append({
                        "vi": vi_line,
                        "home": home_name,
                        "away": away_name,
                        "line": float(line),
                        "odds": float(om),
                        "ev": ev_f,
                        "kelly": k_f,
                        "quality": q_line,
                    })
            if resL["EV_under"] is not None and resL["Kelly_under"] is not None:
                ev_f, k_f, q_line, _, vi_line = evaluate_market_value(resL["EV_under"], resL["Kelly_under"], "ou", league_tier, consensus_line)
                if ev_f is not None and vi_line is not None:
                    ou_all_under.append({
                        "vi": vi_line,
                        "home": home_name,
                        "away": away_name,
                        "line": float(line),
                        "odds": float(um),
                        "ev": ev_f,
                        "kelly": k_f,
                        "quality": q_line,
                    })

        # —— 全线榜单池（CRN）
        if crn_totals_list is None:
            lam_c_total = estimate_corners_lambda_total(h_st, a_st, lam_home, lam_away)
            crn_totals = np.random.poisson(lam=max(0.1, lam_c_total), size=N_SIMS_CORNERS)
            crn_totals_list = [int(x) for x in crn_totals]
        for sline, info in (crn_lines.items() if isinstance(crn_lines, dict) else []):
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            oround = info.get("overround", 9.9)
            if om is None or um is None or not (1.00 <= float(oround) <= 1.30): continue
            consensus_line = {
                "bookmakers": info.get("bookmaker_count") or info.get("bookmakers"),
                "overround": info.get("overround"),
                "update": info.get("max_update_minutes"),
            }
            resCL = ou_ev_kelly_from_totals_quarter(line, float(om), float(um), crn_totals_list)
            if resCL["EV_over"] is not None and resCL["Kelly_over"] is not None:
                ev_f, k_f, q_line, _, vi_line = evaluate_market_value(resCL["EV_over"], resCL["Kelly_over"], "derivative", league_tier, consensus_line)
                if ev_f is not None and vi_line is not None:
                    crn_all_over.append({
                        "vi": vi_line,
                        "home": home_name,
                        "away": away_name,
                        "line": float(line),
                        "odds": float(om),
                        "ev": ev_f,
                        "kelly": k_f,
                        "quality": q_line,
                    })
            if resCL["EV_under"] is not None and resCL["Kelly_under"] is not None:
                ev_f, k_f, q_line, _, vi_line = evaluate_market_value(resCL["EV_under"], resCL["Kelly_under"], "derivative", league_tier, consensus_line)
                if ev_f is not None and vi_line is not None:
                    crn_all_under.append({
                        "vi": vi_line,
                        "home": home_name,
                        "away": away_name,
                        "line": float(line),
                        "odds": float(um),
                        "ev": ev_f,
                        "kelly": k_f,
                        "quality": q_line,
                    })

        # —— 全线榜单池（AH）
        for sline, info in (ah_lines.items() if isinstance(ah_lines, dict) else []):
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            oround = info.get("overround", 9.9)
            if oh is None or oa is None or not (1.00 <= float(oround) <= 1.25): continue
            consensus_line = {
                "bookmakers": info.get("bookmaker_count") or info.get("bookmakers"),
                "overround": info.get("overround"),
                "update": info.get("max_update_minutes"),
            }
            probs = ah_probabilities_from_lams(lam_home, lam_away, h=float(line), n_sims=N_SIMS_GOALS)
            evk = ah_ev_kelly(probs, odds_home=float(oh), odds_away=float(oa))
            if isinstance(evk.get("home"), dict) and evk["home"]["EV"] is not None and evk["home"]["Kelly"] is not None:
                ev_f, k_f, q_line, _, vi_line = evaluate_market_value(evk["home"]["EV"], evk["home"]["Kelly"], "ah", league_tier, consensus_line)
                if ev_f is not None and vi_line is not None:
                    ah_all_home.append({
                        "vi": vi_line,
                        "home": home_name,
                        "away": away_name,
                        "line": float(line),
                        "odds": float(oh),
                        "ev": ev_f,
                        "kelly": k_f,
                        "quality": q_line,
                    })
            if isinstance(evk.get("away"), dict) and evk["away"]["EV"] is not None and evk["away"]["Kelly"] is not None:
                ev_f, k_f, q_line, _, vi_line = evaluate_market_value(evk["away"]["EV"], evk["away"]["Kelly"], "ah", league_tier, consensus_line)
                if ev_f is not None and vi_line is not None:
                    ah_all_away.append({
                        "vi": vi_line,
                        "home": home_name,
                        "away": away_name,
                        "line": float(line),
                        "odds": float(oa),
                        "ev": ev_f,
                        "kelly": k_f,
                        "quality": q_line,
                    })

        # ===== 盘口矩阵（用 *_lines 导出） =====
        for sline, info in ou_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
                matrix_rows.append({
                    "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                    "home": home_name, "away": away_name,
                    "market": "OU", "line": float(line),
                    "median_over": float(om), "median_under": float(um),
                    "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                    "overround": float(info.get("overround", 9.9)),
                    "bookmaker_count": int((info.get("bookmaker_count") or info.get("bookmakers") or 0)),
                    "max_update_minutes": info.get("max_update_minutes"),
                })
        for sline, info in crn_lines.items():
            try: line = float(sline)
            except: continue
            om, um = info.get("over_median"), info.get("under_median")
            if om is None or um is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "CRN", "line": float(line),
                "median_over": float(om), "median_under": float(um),
                "cnt_over": int(info.get("over_cnt", 0)), "cnt_under": int(info.get("under_cnt", 0)),
                "overround": float(info.get("overround", 9.9)),
                "bookmaker_count": int((info.get("bookmaker_count") or info.get("bookmakers") or 0)),
                "max_update_minutes": info.get("max_update_minutes"),
            })
        for sline, info in ah_lines.items():
            try: line = float(sline)
            except: continue
            oh, oa = info.get("home_median"), info.get("away_median")
            if oh is None or oa is None: continue
            matrix_rows.append({
                "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
                "home": home_name, "away": away_name,
                "market": "AH", "line": float(line),
                "median_home": float(oh), "median_away": float(oa),
                "cnt_home": int(info.get("home_cnt", 0)), "cnt_away": int(info.get("away_cnt", 0)),
                "overround": float(info.get("overround", 9.9)),
                "bookmaker_count": int((info.get("bookmaker_count") or info.get("bookmakers") or 0)),
                "max_update_minutes": info.get("max_update_minutes"),
            })

        # ===== 综合最佳 =====
        allowed_quality = {"keep", "review", "review_high"}
        cands: List[Tuple[float, str, float, float]] = []

        def _add_candidate(label: Optional[str], ev: Optional[float], kelly: Optional[float], vi: Optional[float], quality: str) -> None:
            if not label:
                return
            if quality not in allowed_quality:
                return
            if ev is None or kelly is None or vi is None:
                return
            cands.append((float(vi), str(label), float(ev), float(kelly)))

        cands = []
        _add_candidate("1X2-Home", ev1_h, k1_h, vi1_h, q1_h)
        _add_candidate("1X2-Draw", ev1_d, k1_d, vi1_d, q1_d)
        _add_candidate("1X2-Away", ev1_a, k1_a, vi1_a, q1_a)
        _add_candidate("OU(main)-Over", ev_main_over, k_main_over, vi_ou_main_over, q_ou_main_over)
        _add_candidate("OU(main)-Under", ev_main_under, k_main_under, vi_ou_main_under, q_ou_main_under)
        _add_candidate("OU2.5-Over", ev25_over, k25_over, vi_ou25_over, q_ou25_over)
        _add_candidate("OU2.5-Under", ev25_under, k25_under, vi_ou25_under, q_ou25_under)
        if ah_line is not None:
            _add_candidate(f"AH({ah_line:+})-Home", ev_ah_h, k_ah_h, vi_ah_home, q_ah_home)
            _add_candidate(f"AH({ah_line:+})-Away", ev_ah_a, k_ah_a, vi_ah_away, q_ah_away)
        if crn_main_line is not None:
            _add_candidate(f"CRN({crn_main_line})-Over", ev_crn_over, k_crn_over, vi_crn_over, q_crn_over)
            _add_candidate(f"CRN({crn_main_line})-Under", ev_crn_under, k_crn_under, vi_crn_under, q_crn_under)
        cands.sort(key=lambda x: x[0], reverse=True)
        best_label = cands[0][1] if cands else None
        best_ev    = cands[0][2] if cands else None
        best_kelly = cands[0][3] if cands else None

        # ===== 写行 =====
        weight_fields = {
            f"lam_weight_{name}": round(lam_weights.get(name, 0.0), 3)
            for name, data in lambda_models.items()
            if data.get("lam_home") is not None and data.get("lam_away") is not None
        }

        row = {
            "date_utc": date_str, "kickoff_utc": kickoff_utc, "league": league_name,
            "home": home_name, "away": away_name,
            "lam_home": round(lam_home,3), "lam_away": round(lam_away,3),
            "p_home": round(sim["p_home"],4), "p_draw": round(sim["p_draw"],4), "p_away": round(sim["p_away"],4),
            "p_over2.5": round(sim["p_over"],4), "p_under2.5": round(sim["p_under"],4),

            "league_tier": league_tier,

            "1x2_bookmaker_count": consensus_1x2.get("bookmakers"),
            "1x2_overround": consensus_1x2.get("overround"),
            "1x2_update_minutes": consensus_1x2.get("update"),

            # Goals OU 主盘（含诊断 + EV）
            "ou_main_line": ou_main_line,
            "odds_ou_main_over": ou_main_over, "odds_ou_main_under": ou_main_under,
            "ou_main_over_cnt": ou_cnt_o, "ou_main_under_cnt": ou_cnt_u, "ou_main_overround": ou_overround,
            "ou_main_bookmaker_count": consensus_ou_main.get("bookmakers"),
            "ou_main_update_minutes": consensus_ou_main.get("update"),
            "ev_ou_main_over": ev_main_over, "kelly_ou_main_over": k_main_over,
            "ev_ou_main_under": ev_main_under, "kelly_ou_main_under": k_main_under,

            # OU@2.5 参考
            "odds_ou_over2.5": odds.get("ou_over_2_5"), "odds_ou_under2.5": odds.get("ou_under_2_5"),
            "ev_ou_over2.5": ev25_over, "kelly_ou_over2.5": k25_over, "ev_ou_under2.5": ev25_under, "kelly_ou_under2.5": k25_under,

            # 1X2
            "odds_1x2_home": o1_h, "odds_1x2_draw": o1_d, "odds_1x2_away": o1_a,
            "ev_1x2_home": ev1_h, "kelly_1x2_home": k1_h,
            "ev_1x2_draw": ev1_d, "kelly_1x2_draw": k1_d,
            "ev_1x2_away": ev1_a, "kelly_1x2_away": k1_a,

            # AH（含诊断 + EV）
            "ah_line": ah_line, "odds_ah_home": ah_oh, "odds_ah_away": ah_oa,
            "ah_bookmaker_count": consensus_ah_main.get("bookmakers"),
            "ah_update_minutes": consensus_ah_main.get("update"),
            "ev_ah_home": ev_ah_h, "kelly_ah_home": k_ah_h,
            "ev_ah_away": ev_ah_a, "kelly_ah_away": k_ah_a,

            # Corners OU 主盘（含诊断 + EV）
            "crn_main_line": crn_main_line,
            "odds_crn_main_over": crn_main_over, "odds_crn_main_under": crn_main_under,
            "crn_main_over_cnt": crn_cnt_o, "crn_main_under_cnt": crn_cnt_u, "crn_main_overround": crn_overround,
            "crn_main_bookmaker_count": consensus_crn_main.get("bookmakers"),
            "crn_main_update_minutes": consensus_crn_main.get("update"),
            "ev_crn_main_over": ev_crn_over, "kelly_crn_main_over": k_crn_over,
            "ev_crn_main_under": ev_crn_under, "kelly_crn_main_under": k_crn_under,

            "best_market": best_label, "best_ev": best_ev, "best_kelly": best_kelly,
            "value_index": value_index(best_ev, best_kelly) if (best_ev is not None and best_kelly is not None) else None
        }

        row["quality_1x2_home"], row["quality_1x2_draw"], row["quality_1x2_away"] = q1_h, q1_d, q1_a
        row["quality_ou_main_over"], row["quality_ou_main_under"] = q_ou_main_over, q_ou_main_under
        row["quality_ou_over2.5"], row["quality_ou_under2.5"] = q_ou25_over, q_ou25_under
        row["quality_ah_home"], row["quality_ah_away"] = q_ah_home, q_ah_away
        row["quality_crn_main_over"], row["quality_crn_main_under"] = q_crn_over, q_crn_under

        row["vi_1x2_home"], row["vi_1x2_draw"], row["vi_1x2_away"] = vi1_h, vi1_d, vi1_a
        row["vi_ou_main_over"], row["vi_ou_main_under"] = vi_ou_main_over, vi_ou_main_under
        row["vi_ou_over2.5"], row["vi_ou_under2.5"] = vi_ou25_over, vi_ou25_under
        row["vi_ah_home"], row["vi_ah_away"] = vi_ah_home, vi_ah_away
        row["vi_crn_main_over"], row["vi_crn_main_under"] = vi_crn_over, vi_crn_under

        for label, note in [
            ("1x2_home", qnote1_h), ("1x2_draw", qnote1_d), ("1x2_away", qnote1_a),
            ("ou_main_over", qnote_ou_main_over), ("ou_main_under", qnote_ou_main_under),
            ("ou_over2.5", qnote_ou25_over), ("ou_under2.5", qnote_ou25_under),
            ("ah_home", qnote_ah_home), ("ah_away", qnote_ah_away),
            ("crn_main_over", qnote_crn_over), ("crn_main_under", qnote_crn_under),
        ]:
            if note:
                row[f"quality_{label}_note"] = note

        if lam_detail:
            row["lam_blend_detail"] = lam_detail
        for k, v in weight_fields.items():
            row[k] = v

        rows_all.append(row)

        done += 1
        if done % 30 == 0 or done == len(fixtures):
            print(f"……已处理 {done}/{len(fixtures)} 场")

    # ===== 导出全量 CSV =====
    out_dir = os.path.join(os.getcwd(), "out"); os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"daily_brief_{date_str}.csv")
    base_order = [
        "date_utc","kickoff_utc","league","home","away",
        "lam_home","lam_away","lam_weight_season","lam_weight_recent","lam_blend_detail",
        "p_home","p_draw","p_away","p_over2.5","p_under2.5","league_tier",
        "1x2_bookmaker_count","1x2_overround","1x2_update_minutes",
        "ou_main_line","odds_ou_main_over","odds_ou_main_under",
        "ou_main_over_cnt","ou_main_under_cnt","ou_main_overround","ou_main_bookmaker_count","ou_main_update_minutes",
        "ev_ou_main_over","kelly_ou_main_over","quality_ou_main_over","vi_ou_main_over",
        "ev_ou_main_under","kelly_ou_main_under","quality_ou_main_under","vi_ou_main_under",
        "odds_ou_over2.5","odds_ou_under2.5",
        "ev_ou_over2.5","kelly_ou_over2.5","quality_ou_over2.5","vi_ou_over2.5",
        "ev_ou_under2.5","kelly_ou_under2.5","quality_ou_under2.5","vi_ou_under2.5",
        "odds_1x2_home","odds_1x2_draw","odds_1x2_away",
        "ev_1x2_home","kelly_1x2_home","quality_1x2_home","vi_1x2_home",
        "ev_1x2_draw","kelly_1x2_draw","quality_1x2_draw","vi_1x2_draw",
        "ev_1x2_away","kelly_1x2_away","quality_1x2_away","vi_1x2_away",
        "ah_line","odds_ah_home","odds_ah_away","ah_bookmaker_count","ah_update_minutes",
        "ev_ah_home","kelly_ah_home","quality_ah_home","vi_ah_home",
        "ev_ah_away","kelly_ah_away","quality_ah_away","vi_ah_away",
        "crn_main_line","odds_crn_main_over","odds_crn_main_under",
        "crn_main_over_cnt","crn_main_under_cnt","crn_main_overround","crn_main_bookmaker_count","crn_main_update_minutes",
        "ev_crn_main_over","kelly_crn_main_over","quality_crn_main_over","vi_crn_main_over",
        "ev_crn_main_under","kelly_crn_main_under","quality_crn_main_under","vi_crn_main_under",
        "best_market","best_ev","best_kelly","value_index"
    ]
    all_keys=set(); [all_keys.update(r.keys()) for r in rows_all]
    fieldnames = [c for c in base_order if c in all_keys] + [c for c in all_keys if c not in base_order]
    with open(out_file, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
        w.writeheader(); [w.writerow(r) for r in rows_all]
    print(f"\n已导出全量数据到: {out_file}")

    # ===== 导出盘口矩阵（来自 *_lines） =====
    out_mat = os.path.join(out_dir, f"daily_brief_matrix_{date_str}.csv")
        if matrix_rows:
            mat_fields = [
                "date_utc","kickoff_utc","league","home","away","market","line",
                "median_over","median_under","median_home","median_away",
                "cnt_over","cnt_under","cnt_home","cnt_away","overround",
                "bookmaker_count","max_update_minutes"
            ]
        with open(out_mat, "w", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=mat_fields, extrasaction="ignore")
            w.writeheader(); [w.writerow(r) for r in matrix_rows]
        print(f"已导出盘口矩阵到: {out_mat}")
    else:
        print("未获取到盘口矩阵（ou_lines/crn_lines/ah_lines），跳过导出。")

    # ===== 榜单打印 =====
    allowed_quality = {"keep", "review", "review_high"}

    def top_list(rows: List[Dict], key_ev: str, key_k: str, label: str, suffix_fn=None, quality_key: Optional[str] = None, vi_key: Optional[str] = None):
        items = []
        for r in rows:
            ev,k = r.get(key_ev), r.get(key_k)
            if ev is None or k is None or ev < MIN_EV: continue
            quality = r.get(quality_key) if quality_key else "keep"
            if quality_key and quality not in allowed_quality:
                continue
            vi = r.get(vi_key) if vi_key else value_index(ev,k)
            if vi is None:
                continue
            items.append((float(vi), r, ev, k, quality))
        items.sort(key=lambda x: x[0], reverse=True)
        print(f"\n=== Top {min(TOP_K, len(items))}（{label}，EV≥{MIN_EV:.2f}） ===")
        for i,(vi,r,ev,k,quality) in enumerate(items[:TOP_K], 1):
            extra = suffix_fn(r) if suffix_fn else ""
            tag = "" if quality == "keep" else f" [{quality}]"
            print(f"[{i:02d}] {r['home']} vs {r['away']} | EV={ev:.3f} Kelly≈{k:.3f} | {label}{(' ' + extra) if extra else ''}{tag}")

    # Suffix 生成（去掉多余空格）
    suf_ou_over  = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_over"), False)
    suf_ou_under = lambda r: _fmt_ou_book(r.get("ou_main_line"), r.get("odds_ou_main_under"), False)
    suf_1x2_home = lambda r: f"@{float(r['odds_1x2_home']):.2f}" if r.get("odds_1x2_home") else ""
    suf_1x2_draw = lambda r: f"@{float(r['odds_1x2_draw']):.2f}" if r.get("odds_1x2_draw") else ""
    suf_1x2_away = lambda r: f"@{float(r['odds_1x2_away']):.2f}" if r.get("odds_1x2_away") else ""
    suf_ah_home  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_home"), "home")
    suf_ah_away  = lambda r: _fmt_ah_book(r.get("ah_line"), r.get("odds_ah_away"), "away")
    suf_cr_over  = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_over"), True)
    suf_cr_under = lambda r: _fmt_ou_book(r.get("crn_main_line"), r.get("odds_crn_main_under"), True)

    top_list(rows_all, "ev_ou_main_over",  "kelly_ou_main_over",  "OU主盘-Over",  suf_ou_over, quality_key="quality_ou_main_over", vi_key="vi_ou_main_over")
    top_list(rows_all, "ev_ou_main_under", "kelly_ou_main_under", "OU主盘-Under", suf_ou_under, quality_key="quality_ou_main_under", vi_key="vi_ou_main_under")
    top_list(rows_all, "ev_1x2_home", "kelly_1x2_home", "1X2-主胜", suf_1x2_home, quality_key="quality_1x2_home", vi_key="vi_1x2_home")
    top_list(rows_all, "ev_1x2_draw", "kelly_1x2_draw", "1X2-平局", suf_1x2_draw, quality_key="quality_1x2_draw", vi_key="vi_1x2_draw")
    top_list(rows_all, "ev_1x2_away", "kelly_1x2_away", "1X2-客胜", suf_1x2_away, quality_key="quality_1x2_away", vi_key="vi_1x2_away")
    top_list(rows_all, "ev_ah_home", "kelly_ah_home", "AH-主方向", suf_ah_home, quality_key="quality_ah_home", vi_key="vi_ah_home")
    top_list(rows_all, "ev_ah_away", "kelly_ah_away", "AH-客方向", suf_ah_away, quality_key="quality_ah_away", vi_key="vi_ah_away")
    top_list(rows_all, "ev_crn_main_over",  "kelly_crn_main_over",  "角球主盘-Over",  suf_cr_over, quality_key="quality_crn_main_over", vi_key="vi_crn_main_over")
    top_list(rows_all, "ev_crn_main_under", "kelly_crn_main_under", "角球主盘-Under", suf_cr_under, quality_key="quality_crn_main_under", vi_key="vi_crn_main_under")

    # ===== 全线 Top（按 VI 排序）=====
    def print_ou_crn_allline_top(title: str, arr: List[Dict[str, object]], tag="OU"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [
            entry for entry in arr
            if entry.get("ev") is not None and entry.get("kelly") is not None and entry.get("ev", 0) >= MIN_EV
            and entry.get("quality") in allowed_quality and entry.get("vi") is not None
        ]
        arr2.sort(key=lambda x: float(x.get("vi", -999)), reverse=True)
        for i, entry in enumerate(arr2[:TOP_K], 1):
            quality = entry.get("quality", "")
            tag_q = "" if quality == "keep" else f" [{quality}]"
            print(
                f"[{i:02d}] {entry['home']} vs {entry['away']} | 线={entry['line']:g} | EV={entry['ev']:.3f} "
                f"Kelly≈{entry['kelly']:.3f} | {title} {tag}{entry['line']:g}@{entry['odds']:.2f}{tag_q}"
            )

    def print_ah_allline_top(title: str, arr: List[Dict[str, object]], side="home"):
        print(f"\n=== 全线 Top {TOP_K}（{title}，EV≥{MIN_EV:.2f}） ===")
        arr2 = [
            entry for entry in arr
            if entry.get("ev") is not None and entry.get("kelly") is not None and entry.get("ev", 0) >= MIN_EV
            and entry.get("quality") in allowed_quality and entry.get("vi") is not None
        ]
        arr2.sort(key=lambda x: float(x.get("vi", -999)), reverse=True)
        for i, entry in enumerate(arr2[:TOP_K], 1):
            adj = entry["line"] if side == "home" else -entry["line"]
            sign = "+" if adj > 0 else ""
            quality = entry.get("quality", "")
            tag_q = "" if quality == "keep" else f" [{quality}]"
            print(
                f"[{i:02d}] {entry['home']} vs {entry['away']} | 线={adj:g} | EV={entry['ev']:.3f} "
                f"Kelly≈{entry['kelly']:.3f} | {title} AH{sign}{adj:g}@{entry['odds']:.2f}{tag_q}"
            )

    if ou_all_over:  print_ou_crn_allline_top("进球OU-Over（全线）",  ou_all_over,  "OU")
    if ou_all_under: print_ou_crn_allline_top("进球OU-Under（全线）", ou_all_under, "OU")
    if crn_all_over: print_ou_crn_allline_top("角球OU-Over（全线）",  crn_all_over,  "CRN")
    if crn_all_under:print_ou_crn_allline_top("角球OU-Under（全线）", crn_all_under, "CRN")
    if ah_all_home: print_ah_allline_top("AH-主方向（全线）", ah_all_home, side="home")
    if ah_all_away: print_ah_allline_top("AH-客方向（全线）", ah_all_away, side="away")

    # AH 诊断
    print(f"\n[AH诊断] 有主盘线的比赛: {cnt_ah_has_line} 场；出现正EV(主): {cnt_ah_ev_home} 场；正EV(客): {cnt_ah_ev_away} 场")

    # 导出 picks.csv
    if EXPORT_PICKS:
        export_picks(rows_all, date_str)

if __name__ == "__main__":
    try:
        if os.environ.get("DAILY_BRIEF_SELFTEST") == "1":
            _regression_check_quarter_under()
        main()
    except Exception as e:
        print("程序异常：", e)
        traceback.print_exc()
